!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).THREE = {}) }(this, function (e) {
    "use strict"; const R = "131", q = 100, L = 300, P = 301, I = 302, D = 303, N = 304, H = 306, O = 307, U = 1e3, Pe = 1001, z = 1002, Ae = 1003, G = 1004, W = 1005, B = 1006, j = 1007, Ie = 1008, De = 1009, X = 1012, Y = 1014, Ne = 1015, He = 1016, Z = 1020, J = 1022, Oe = 1023, K = 1026, Q = 1027, F = 33776, $ = 33777, ee = 33778, te = 33779, ne = 35840, re = 35841, ie = 35842, ae = 35843, se = 37492, oe = 37496, le = 2300, ce = 2301, he = 2302, ue = 2400, de = 2401, pe = 2402, me = 2500, fe = 2501, Fe = 3e3, ge = 3001, ve = 3007, ye = 3002, xe = 3004, _e = 35044, be = 35048, Me = "300 es"; class we { addEventListener(e, t) { void 0 === this._listeners && (this._listeners = {}); const n = this._listeners; void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t) } hasEventListener(e, t) { if (void 0 === this._listeners) return !1; const n = this._listeners; return void 0 !== n[e] && -1 !== n[e].indexOf(t) } removeEventListener(e, t) { if (void 0 !== this._listeners) { const n = this._listeners[e]; if (void 0 !== n) { const e = n.indexOf(t); -1 !== e && n.splice(e, 1) } } } dispatchEvent(n) { if (void 0 !== this._listeners) { const e = this._listeners[n.type]; if (void 0 !== e) { n.target = this; const r = e.slice(0); for (let e = 0, t = r.length; e < t; e++)r[e].call(this, n); n.target = null } } } } const i = []; for (let e = 0; e < 256; e++)i[e] = (e < 16 ? "0" : "") + e.toString(16); let Te = 1234567; const Ee = Math.PI / 180, Se = 180 / Math.PI; function Be() { var e = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, r = 4294967295 * Math.random() | 0; return (i[255 & e] + i[e >> 8 & 255] + i[e >> 16 & 255] + i[e >> 24 & 255] + "-" + i[255 & t] + i[t >> 8 & 255] + "-" + i[t >> 16 & 15 | 64] + i[t >> 24 & 255] + "-" + i[63 & n | 128] + i[n >> 8 & 255] + "-" + i[n >> 16 & 255] + i[n >> 24 & 255] + i[255 & r] + i[r >> 8 & 255] + i[r >> 16 & 255] + i[r >> 24 & 255]).toUpperCase() } function m(e, t, n) { return Math.max(t, Math.min(n, e)) } function Ue(e, t) { return (e % t + t) % t } function ze(e, t, n) { return (1 - n) * e + n * t } function Ge(e) { return 0 == (e & e - 1) && 0 !== e } function ke(e) { return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2)) } function Ve(e) { return Math.pow(2, Math.floor(Math.log(e) / Math.LN2)) } var We = Object.freeze({ __proto__: null, DEG2RAD: Ee, RAD2DEG: Se, generateUUID: Be, clamp: m, euclideanModulo: Ue, mapLinear: function (e, t, n, r, i) { return r + (e - t) * (i - r) / (n - t) }, inverseLerp: function (e, t, n) { return e !== t ? (n - e) / (t - e) : 0 }, lerp: ze, damp: function (e, t, n, r) { return ze(e, t, 1 - Math.exp(-n * r)) }, pingpong: function (e, t = 1) { return t - Math.abs(Ue(e, 2 * t) - t) }, smoothstep: function (e, t, n) { return e <= t ? 0 : n <= e ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e) }, smootherstep: function (e, t, n) { return e <= t ? 0 : n <= e ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10) }, randInt: function (e, t) { return e + Math.floor(Math.random() * (t - e + 1)) }, randFloat: function (e, t) { return e + Math.random() * (t - e) }, randFloatSpread: function (e) { return e * (.5 - Math.random()) }, seededRandom: function (e) { return ((Te = 16807 * (Te = void 0 !== e ? e % 2147483647 : Te) % 2147483647) - 1) / 2147483646 }, degToRad: function (e) { return e * Ee }, radToDeg: function (e) { return e * Se }, isPowerOfTwo: Ge, ceilPowerOfTwo: ke, floorPowerOfTwo: Ve, setQuaternionFromProperEuler: function (e, t, n, r, i) { const a = Math.cos, s = Math.sin, o = a(n / 2), l = s(n / 2), c = a((t + r) / 2), h = s((t + r) / 2), u = a((t - r) / 2), d = s((t - r) / 2), p = a((r - t) / 2), m = s((r - t) / 2); switch (i) { case "XYX": e.set(o * h, l * u, l * d, o * c); break; case "YZY": e.set(l * d, o * h, l * u, o * c); break; case "ZXZ": e.set(l * u, l * d, o * h, o * c); break; case "XZX": e.set(o * h, l * m, l * p, o * c); break; case "YXY": e.set(l * p, o * h, l * m, o * c); break; case "ZYZ": e.set(l * m, l * p, o * h, o * c); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i) } } }); class k { constructor(e = 0, t = 0) { this.x = e, this.y = t } get width() { return this.x } set width(e) { this.x = e } get height() { return this.y } set height(e) { this.y = e } set(e, t) { return this.x = e, this.y = t, this } setScalar(e) { return this.x = e, this.y = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y) } copy(e) { return this.x = e.x, this.y = e.y, this } add(e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this) } addScalar(e) { return this.x += e, this.y += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this } sub(e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this) } subScalar(e) { return this.x -= e, this.y -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this } divide(e) { return this.x /= e.x, this.y /= e.y, this } divideScalar(e) { return this.multiplyScalar(1 / e) } applyMatrix3(e) { var t = this.x, n = this.y, e = e.elements; return this.x = e[0] * t + e[3] * n + e[6], this.y = e[1] * t + e[4] * n + e[7], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this } clampLength(e, t) { var n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(e) { return this.x * e.x + this.y * e.y } cross(e) { return this.x * e.y - this.y * e.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { var t = this.x - e.x, e = this.y - e.y; return t * t + e * e } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this } equals(e) { return e.x === this.x && e.y === this.y } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e } fromBufferAttribute(e, t, n) { return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this } rotateAround(e, t) { var n = Math.cos(t), t = Math.sin(t), r = this.x - e.x, i = this.y - e.y; return this.x = r * n - i * t + e.x, this.y = r * t + i * n + e.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } } k.prototype.isVector2 = !0; class v { constructor() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") } set(e, t, n, r, i, a, s, o, l) { const c = this.elements; return c[0] = e, c[1] = r, c[2] = s, c[3] = t, c[4] = i, c[5] = o, c[6] = n, c[7] = a, c[8] = l, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(e) { const t = this.elements, n = e.elements; return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this } extractBasis(e, t, n) { return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this } setFromMatrix4(e) { e = e.elements; return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const n = e.elements, r = t.elements, i = this.elements, a = n[0], s = n[3], o = n[6], l = n[1], c = n[4], h = n[7], u = n[2], d = n[5], p = n[8], m = r[0], f = r[3], g = r[6], v = r[1], y = r[4], x = r[7], _ = r[2], b = r[5], M = r[8]; return i[0] = a * m + s * v + o * _, i[3] = a * f + s * y + o * b, i[6] = a * g + s * x + o * M, i[1] = l * m + c * v + h * _, i[4] = l * f + c * y + h * b, i[7] = l * g + c * x + h * M, i[2] = u * m + d * v + p * _, i[5] = u * f + d * y + p * b, i[8] = u * g + d * x + p * M, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this } determinant() { var e = this.elements, t = e[0], n = e[1], r = e[2], i = e[3], a = e[4], s = e[5], o = e[6], l = e[7], e = e[8]; return t * a * e - t * s * l - n * i * e + n * s * o + r * i * l - r * a * o } invert() { const e = this.elements, t = e[0], n = e[1], r = e[2], i = e[3], a = e[4], s = e[5], o = e[6], l = e[7], c = e[8], h = c * a - s * l, u = s * o - c * i, d = l * i - a * o, p = t * h + n * u + r * d; if (0 == p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); var m = 1 / p; return e[0] = h * m, e[1] = (r * l - c * n) * m, e[2] = (s * n - r * a) * m, e[3] = u * m, e[4] = (c * t - r * o) * m, e[5] = (r * i - s * t) * m, e[6] = d * m, e[7] = (n * o - l * t) * m, e[8] = (a * t - n * i) * m, this } transpose() { var e; const t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this } getNormalMatrix(e) { return this.setFromMatrix4(e).invert().transpose() } transposeIntoArray(e) { var t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this } setUvTransform(e, t, n, r, i, a, s) { var o = Math.cos(i), i = Math.sin(i); return this.set(n * o, n * i, -n * (o * a + i * s) + a + e, -r * i, r * o, -r * (-i * a + o * s) + s + t, 0, 0, 1), this } scale(e, t) { const n = this.elements; return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this } rotate(e) { const t = Math.cos(e), n = Math.sin(e), r = this.elements, i = r[0], a = r[3], s = r[6], o = r[1], l = r[4], c = r[7]; return r[0] = t * i + n * o, r[3] = t * a + n * l, r[6] = t * s + n * c, r[1] = -n * i + t * o, r[4] = -n * a + t * l, r[7] = -n * s + t * c, this } translate(e, t) { const n = this.elements; return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this } equals(e) { var t = this.elements, n = e.elements; for (let e = 0; e < 9; e++)if (t[e] !== n[e]) return !1; return !0 } fromArray(t, n = 0) { for (let e = 0; e < 9; e++)this.elements[e] = t[e + n]; return this } toArray(e = [], t = 0) { var n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e } clone() { return (new this.constructor).fromArray(this.elements) } } let je; v.prototype.isMatrix3 = !0; class qe { static getDataURL(e) { if (/^data:/i.test(e.src)) return e.src; if ("undefined" == typeof HTMLCanvasElement) return e.src; let t; if (e instanceof HTMLCanvasElement) t = e; else { (je = void 0 === je ? document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") : je).width = e.width, je.height = e.height; const n = je.getContext("2d"); e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = je } return 2048 < t.width || 2048 < t.height ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png") } } let Xe = 0; class h extends we { constructor(e = h.DEFAULT_IMAGE, t = h.DEFAULT_MAPPING, n = 1001, r = 1001, i = 1006, a = 1008, s = 1023, o = 1009, l = 1, c = 3e3) { super(), Object.defineProperty(this, "id", { value: Xe++ }), this.uuid = Be(), this.name = "", this.image = e, this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = a, this.anisotropy = l, this.format = s, this.internalFormat = null, this.type = o, this.offset = new k(0, 0), this.repeat = new k(1, 1), this.center = new k(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new v, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1 } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this } toJSON(e) { var t = void 0 === e || "string" == typeof e; if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid]; const n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if (void 0 !== this.image) { const r = this.image; if (void 0 === r.uuid && (r.uuid = Be()), !t && void 0 === e.images[r.uuid]) { let n; if (Array.isArray(r)) { n = []; for (let e = 0, t = r.length; e < t; e++)r[e].isDataTexture ? n.push(Ye(r[e].image)) : n.push(Ye(r[e])) } else n = Ye(r); e.images[r.uuid] = { uuid: r.uuid, url: n } } n.image = r.uuid } return t || (e.textures[this.uuid] = n), n } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(e) { if (this.mapping !== L) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || 1 < e.x) switch (this.wrapS) { case U: e.x = e.x - Math.floor(e.x); break; case Pe: e.x = e.x < 0 ? 0 : 1; break; case z: 1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x) }if (e.y < 0 || 1 < e.y) switch (this.wrapT) { case U: e.y = e.y - Math.floor(e.y); break; case Pe: e.y = e.y < 0 ? 0 : 1; break; case z: 1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y) }return this.flipY && (e.y = 1 - e.y), e } set needsUpdate(e) { !0 === e && this.version++ } } function Ye(e) { return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? qe.getDataURL(e) : e.data ? { data: Array.prototype.slice.call(e.data), width: e.width, height: e.height, type: e.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } h.DEFAULT_IMAGE = void 0, h.DEFAULT_MAPPING = L, h.prototype.isTexture = !0; class Re { constructor(e = 0, t = 0, n = 0, r = 1) { this.x = e, this.y = t, this.z = n, this.w = r } get width() { return this.z } set width(e) { this.z = e } get height() { return this.w } set height(e) { this.w = e } set(e, t, n, r) { return this.x = e, this.y = t, this.z = n, this.w = r, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setW(e) { return this.w = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; case 3: this.w = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this } add(e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this) } addScalar(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this } sub(e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this) } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } applyMatrix4(e) { var t = this.x, n = this.y, r = this.z, i = this.w, e = e.elements; return this.x = e[0] * t + e[4] * n + e[8] * r + e[12] * i, this.y = e[1] * t + e[5] * n + e[9] * r + e[13] * i, this.z = e[2] * t + e[6] * n + e[10] * r + e[14] * i, this.w = e[3] * t + e[7] * n + e[11] * r + e[15] * i, this } divideScalar(e) { return this.multiplyScalar(1 / e) } setAxisAngleFromQuaternion(e) { this.w = 2 * Math.acos(e.w); var t = Math.sqrt(1 - e.w * e.w); return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this } setAxisAngleFromRotationMatrix(e) { let t, n, r, i; const a = e.elements, s = a[0], o = a[4], l = a[8], c = a[1], h = a[5], u = a[9], d = a[2], p = a[6], m = a[10]; if (Math.abs(o - c) < .01 && Math.abs(l - d) < .01 && Math.abs(u - p) < .01) { if (Math.abs(o + c) < .1 && Math.abs(l + d) < .1 && Math.abs(u + p) < .1 && Math.abs(s + h + m - 3) < .1) return this.set(1, 0, 0, 0), this; t = Math.PI; const e = (s + 1) / 2, a = (h + 1) / 2, f = (m + 1) / 2, g = (o + c) / 4, v = (l + d) / 4, y = (u + p) / 4; return e > a && e > f ? i = e < .01 ? (n = 0, r = .707106781) : (n = Math.sqrt(e), r = g / n, v / n) : a > f ? i = a < .01 ? (n = .707106781, r = 0, .707106781) : (r = Math.sqrt(a), n = g / r, y / r) : f < .01 ? (n = .707106781, r = .707106781, i = 0) : (i = Math.sqrt(f), n = v / i, r = y / i), this.set(n, r, i, t), this } let f = Math.sqrt((p - u) * (p - u) + (l - d) * (l - d) + (c - o) * (c - o)); return Math.abs(f) < .001 && (f = 1), this.x = (p - u) / f, this.y = (l - d) / f, this.z = (c - o) / f, this.w = Math.acos((s + h + m - 1) / 2), this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this } clampLength(e, t) { var n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e } fromBufferAttribute(e, t, n) { return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } } Re.prototype.isVector4 = !0; class Ze extends we { constructor(e, t, n = {}) { super(), this.width = e, this.height = t, this.depth = 1, this.scissor = new Re(0, 0, e, t), this.scissorTest = !1, this.viewport = new Re(0, 0, e, t), this.texture = new h(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = { width: e, height: t, depth: 1 }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : B, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null } setTexture(e) { e.image = { width: this.width, height: this.height, depth: this.depth }, this.texture = e } setSize(e, t, n = 1) { this.width === e && this.height === t && this.depth === n || (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.image = { ...this.texture.image }, this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } Ze.prototype.isWebGLRenderTarget = !0; class Je extends Ze { constructor(e, t, n) { super(e, t); const r = this.texture; this.texture = []; for (let e = 0; e < n; e++)this.texture[e] = r.clone() } setSize(n, r, i = 1) { if (this.width !== n || this.height !== r || this.depth !== i) { this.width = n, this.height = r, this.depth = i; for (let e = 0, t = this.texture.length; e < t; e++)this.texture[e].image.width = n, this.texture[e].image.height = r, this.texture[e].image.depth = i; this.dispose() } return this.viewport.set(0, 0, n, r), this.scissor.set(0, 0, n, r), this } copy(n) { this.dispose(), this.width = n.width, this.height = n.height, this.depth = n.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.depthTexture = n.depthTexture; for (let e = this.texture.length = 0, t = n.texture.length; e < t; e++)this.texture[e] = n.texture[e].clone(); return this } } Je.prototype.isWebGLMultipleRenderTargets = !0; class Ke extends Ze { constructor(e, t, n) { super(e, t, n), this.samples = 4 } copy(e) { return super.copy.call(this, e), this.samples = e.samples, this } } Ke.prototype.isWebGLMultisampleRenderTarget = !0; class f { constructor(e = 0, t = 0, n = 0, r = 1) { this._x = e, this._y = t, this._z = n, this._w = r } static slerp(e, t, n, r) { return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(e, t, r) } static slerpFlat(t, n, r, i, a, s, o) { let l = r[i + 0], c = r[i + 1], h = r[i + 2], u = r[i + 3]; var d = a[s + 0], p = a[s + 1], m = a[s + 2], s = a[s + 3]; if (0 === o) return t[n + 0] = l, t[n + 1] = c, t[n + 2] = h, void (t[n + 3] = u); if (1 === o) return t[n + 0] = d, t[n + 1] = p, t[n + 2] = m, void (t[n + 3] = s); if (u !== s || l !== d || c !== p || h !== m) { let e = 1 - o; const n = l * d + c * p + h * m + u * s, r = 0 <= n ? 1 : -1, i = 1 - n * n; if (i > Number.EPSILON) { const a = Math.sqrt(i), s = Math.atan2(a, n * r); e = Math.sin(e * s) / a, o = Math.sin(o * s) / a } const a = o * r; if (l = l * e + d * a, c = c * e + p * a, h = h * e + m * a, u = u * e + s * a, e === 1 - o) { const t = 1 / Math.sqrt(l * l + c * c + h * h + u * u); l *= t, c *= t, h *= t, u *= t } } t[n] = l, t[n + 1] = c, t[n + 2] = h, t[n + 3] = u } static multiplyQuaternionsFlat(e, t, n, r, i, a) { var s = n[r], o = n[r + 1], l = n[r + 2], n = n[r + 3], r = i[a], c = i[a + 1], h = i[a + 2], i = i[a + 3]; return e[t] = s * i + n * r + o * h - l * c, e[t + 1] = o * i + n * c + l * r - s * h, e[t + 2] = l * i + n * h + s * c - o * r, e[t + 3] = n * i - s * r - o * c - l * h, e } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get w() { return this._w } set w(e) { this._w = e, this._onChangeCallback() } set(e, t, n, r) { return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this } setFromEuler(e, t) { if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); const n = e._x, r = e._y, i = e._z, a = e._order, s = Math.cos, o = Math.sin, l = s(n / 2), c = s(r / 2), h = s(i / 2), u = o(n / 2), d = o(r / 2), p = o(i / 2); switch (a) { case "XYZ": this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p; break; case "YXZ": this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p; break; case "ZXY": this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p; break; case "ZYX": this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p; break; case "YZX": this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p; break; case "XZY": this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a) }return !1 !== t && this._onChangeCallback(), this } setFromAxisAngle(e, t) { var t = t / 2, n = Math.sin(t); return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(t), this._onChangeCallback(), this } setFromRotationMatrix(e) { var e = e.elements, t = e[0], n = e[4], r = e[8], i = e[1], a = e[5], s = e[9], o = e[2], l = e[6], c = e[10], h = t + a + c; if (0 < h) { const e = .5 / Math.sqrt(h + 1); this._w = .25 / e, this._x = (l - s) * e, this._y = (r - o) * e, this._z = (i - n) * e } else if (a < t && c < t) { const e = 2 * Math.sqrt(1 + t - a - c); this._w = (l - s) / e, this._x = .25 * e, this._y = (n + i) / e, this._z = (r + o) / e } else if (c < a) { const e = 2 * Math.sqrt(1 + a - t - c); this._w = (r - o) / e, this._x = (n + i) / e, this._y = .25 * e, this._z = (s + l) / e } else { const e = 2 * Math.sqrt(1 + c - t - a); this._w = (i - n) / e, this._x = (r + o) / e, this._y = (s + l) / e, this._z = .25 * e } return this._onChangeCallback(), this } setFromUnitVectors(e, t) { let n = e.dot(t) + 1; return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0) : (this._x = 0, this._y = -e.z, this._z = e.y)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x), this._w = n, this.normalize() } angleTo(e) { return 2 * Math.acos(Math.abs(m(this.dot(e), -1, 1))) } rotateTowards(e, t) { var n = this.angleTo(e); if (0 === n) return this; t = Math.min(1, t / n); return this.slerp(e, t), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { var e = this.length(); return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (this._x = this._x * (e = 1 / e), this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this } multiply(e, t) { return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e) } premultiply(e) { return this.multiplyQuaternions(e, this) } multiplyQuaternions(e, t) { var n = e._x, r = e._y, i = e._z, e = e._w, a = t._x, s = t._y, o = t._z, t = t._w; return this._x = n * t + e * a + r * o - i * s, this._y = r * t + e * s + i * a - n * o, this._z = i * t + e * o + n * s - r * a, this._w = e * t - n * a - r * s - i * o, this._onChangeCallback(), this } slerp(e, t) { if (0 === t) return this; if (1 === t) return this.copy(e); var n = this._x, r = this._y, i = this._z, a = this._w; let s = a * e._w + n * e._x + r * e._y + i * e._z; if (s < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, s = -s) : this.copy(e), 1 <= s) return this._w = a, this._x = n, this._y = r, this._z = i, this; e = 1 - s * s; if (e <= Number.EPSILON) { const e = 1 - t; return this._w = e * a + t * this._w, this._x = e * n + t * this._x, this._y = e * r + t * this._y, this._z = e * i + t * this._z, this.normalize(), this._onChangeCallback(), this } var e = Math.sqrt(e), o = Math.atan2(e, s), l = Math.sin((1 - t) * o) / e, t = Math.sin(t * o) / e; return this._w = a * l + this._w * t, this._x = n * l + this._x * t, this._y = r * l + this._y * t, this._z = i * l + this._z * t, this._onChangeCallback(), this } slerpQuaternions(e, t, n) { this.copy(e).slerp(t, n) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w } fromArray(e, t = 0) { return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e } fromBufferAttribute(e, t) { return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } } f.prototype.isQuaternion = !0; class Le { constructor(e = 0, t = 0, n = 0) { this.x = e, this.y = t, this.z = n } set(e, t, n) { return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this } add(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this) } addScalar(e) { return this.x += e, this.y += e, this.z += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this } sub(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this) } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this } multiply(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this) } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this } multiplyVectors(e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this } applyEuler(e) { return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion($e.setFromEuler(e)) } applyAxisAngle(e, t) { return this.applyQuaternion($e.setFromAxisAngle(e, t)) } applyMatrix3(e) { var t = this.x, n = this.y, r = this.z, e = e.elements; return this.x = e[0] * t + e[3] * n + e[6] * r, this.y = e[1] * t + e[4] * n + e[7] * r, this.z = e[2] * t + e[5] * n + e[8] * r, this } applyNormalMatrix(e) { return this.applyMatrix3(e).normalize() } applyMatrix4(e) { var t = this.x, n = this.y, r = this.z, e = e.elements, i = 1 / (e[3] * t + e[7] * n + e[11] * r + e[15]); return this.x = (e[0] * t + e[4] * n + e[8] * r + e[12]) * i, this.y = (e[1] * t + e[5] * n + e[9] * r + e[13]) * i, this.z = (e[2] * t + e[6] * n + e[10] * r + e[14]) * i, this } applyQuaternion(e) { var t = this.x, n = this.y, r = this.z, i = e.x, a = e.y, s = e.z, e = e.w, o = e * t + a * r - s * n, l = e * n + s * t - i * r, c = e * r + i * n - a * t, t = -i * t - a * n - s * r; return this.x = o * e + t * -i + l * -s - c * -a, this.y = l * e + t * -a + c * -i - o * -s, this.z = c * e + t * -s + o * -a - l * -i, this } project(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) } unproject(e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) } transformDirection(e) { var t = this.x, n = this.y, r = this.z, e = e.elements; return this.x = e[0] * t + e[4] * n + e[8] * r, this.y = e[1] * t + e[5] * n + e[9] * r, this.z = e[2] * t + e[6] * n + e[10] * r, this.normalize() } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this } divideScalar(e) { return this.multiplyScalar(1 / e) } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this } clampLength(e, t) { var n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this } cross(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e) } crossVectors(e, t) { var n = e.x, r = e.y, e = e.z, i = t.x, a = t.y, t = t.z; return this.x = r * t - e * a, this.y = e * i - n * t, this.z = n * a - r * i, this } projectOnVector(e) { var t = e.lengthSq(); if (0 === t) return this.set(0, 0, 0); t = e.dot(this) / t; return this.copy(e).multiplyScalar(t) } projectOnPlane(e) { return Qe.copy(this).projectOnVector(e), this.sub(Qe) } reflect(e) { return this.sub(Qe.copy(e).multiplyScalar(2 * this.dot(e))) } angleTo(e) { var t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (0 === t) return Math.PI / 2; e = this.dot(e) / t; return Math.acos(m(e, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { var t = this.x - e.x, n = this.y - e.y, e = this.z - e.z; return t * t + n * n + e * e } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) } setFromSpherical(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) } setFromSphericalCoords(e, t, n) { var r = Math.sin(t) * e; return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this } setFromCylindrical(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) } setFromCylindricalCoords(e, t, n) { return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this } setFromMatrixPosition(e) { e = e.elements; return this.x = e[12], this.y = e[13], this.z = e[14], this } setFromMatrixScale(e) { var t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), e = this.setFromMatrixColumn(e, 2).length(); return this.x = t, this.y = n, this.z = e, this } setFromMatrixColumn(e, t) { return this.fromArray(e.elements, 4 * t) } setFromMatrix3Column(e, t) { return this.fromArray(e.elements, 3 * t) } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e } fromBufferAttribute(e, t, n) { return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } } Le.prototype.isVector3 = !0; const Qe = new Le, $e = new f; class et { constructor(e = new Le(1 / 0, 1 / 0, 1 / 0), t = new Le(-1 / 0, -1 / 0, -1 / 0)) { this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromArray(n) { let r = 1 / 0, i = 1 / 0, a = 1 / 0, s = -1 / 0, o = -1 / 0, l = -1 / 0; for (let e = 0, t = n.length; e < t; e += 3) { var c = n[e], h = n[e + 1], u = n[e + 2]; c < r && (r = c), h < i && (i = h), u < a && (a = u), c > s && (s = c), h > o && (o = h), u > l && (l = u) } return this.min.set(r, i, a), this.max.set(s, o, l), this } setFromBufferAttribute(n) { let r = 1 / 0, i = 1 / 0, a = 1 / 0, s = -1 / 0, o = -1 / 0, l = -1 / 0; for (let e = 0, t = n.count; e < t; e++) { var c = n.getX(e), h = n.getY(e), u = n.getZ(e); c < r && (r = c), h < i && (i = h), u < a && (a = u), c > s && (s = c), h > o && (o = h), u > l && (l = u) } return this.min.set(r, i, a), this.max.set(s, o, l), this } setFromPoints(n) { this.makeEmpty(); for (let e = 0, t = n.length; e < t; e++)this.expandByPoint(n[e]); return this } setFromCenterAndSize(e, t) { t = nt.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(t), this.max.copy(e).add(t), this } setFromObject(e) { return this.makeEmpty(), this.expandByObject(e) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } expandByObject(e) { e.updateWorldMatrix(!1, !1); const t = e.geometry; void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), rt.copy(t.boundingBox), rt.applyMatrix4(e.matrixWorld), this.union(rt)); var n = e.children; for (let e = 0, t = n.length; e < t; e++)this.expandByObject(n[e]); return this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z) } intersectsSphere(e) { return this.clampPoint(e.center, nt), nt.distanceToSquared(e.center) <= e.radius * e.radius } intersectsPlane(e) { let t, n; return n = 0 < e.normal.x ? (t = e.normal.x * this.min.x, e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, e.normal.x * this.min.x), 0 < e.normal.y ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), 0 < e.normal.z ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant } intersectsTriangle(e) { return !this.isEmpty() && (this.getCenter(ht), ut.subVectors(this.max, ht), it.subVectors(e.a, ht), at.subVectors(e.b, ht), st.subVectors(e.c, ht), ot.subVectors(at, it), lt.subVectors(st, at), ct.subVectors(it, st), !!mt([0, -ot.z, ot.y, 0, -lt.z, lt.y, 0, -ct.z, ct.y, ot.z, 0, -ot.x, lt.z, 0, -lt.x, ct.z, 0, -ct.x, -ot.y, ot.x, 0, -lt.y, lt.x, 0, -ct.y, ct.x, 0], it, at, st, ut) && (!!mt([1, 0, 0, 0, 1, 0, 0, 0, 1], it, at, st, ut) && (dt.crossVectors(ot, lt), mt([dt.x, dt.y, dt.z], it, at, st, ut)))) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return nt.copy(e).clamp(this.min, this.max).sub(e).length() } getBoundingSphere(e) { return this.getCenter(e.center), e.radius = .5 * this.getSize(nt).length(), e } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } applyMatrix4(e) { return this.isEmpty() || (tt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), tt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), tt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), tt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), tt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), tt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), tt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), tt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(tt)), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } et.prototype.isBox3 = !0; const tt = [new Le, new Le, new Le, new Le, new Le, new Le, new Le, new Le], nt = new Le, rt = new et, it = new Le, at = new Le, st = new Le, ot = new Le, lt = new Le, ct = new Le, ht = new Le, ut = new Le, dt = new Le, pt = new Le; function mt(n, r, i, a, s) { for (let e = 0, t = n.length - 3; e <= t; e += 3) { pt.fromArray(n, e); var o = s.x * Math.abs(pt.x) + s.y * Math.abs(pt.y) + s.z * Math.abs(pt.z), l = r.dot(pt), c = i.dot(pt), h = a.dot(pt); if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > o) return !1 } return !0 } const ft = new et, gt = new Le, vt = new Le, yt = new Le; class xt { constructor(e = new Le, t = -1) { this.center = e, this.radius = t } set(e, t) { return this.center.copy(e), this.radius = t, this } setFromPoints(n, e) { const r = this.center; void 0 !== e ? r.copy(e) : ft.setFromPoints(n).getCenter(r); let i = 0; for (let e = 0, t = n.length; e < t; e++)i = Math.max(i, r.distanceToSquared(n[e])); return this.radius = Math.sqrt(i), this } copy(e) { return this.center.copy(e.center), this.radius = e.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(e) { return e.distanceTo(this.center) - this.radius } intersectsSphere(e) { var t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t } intersectsBox(e) { return e.intersectsSphere(this) } intersectsPlane(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius } clampPoint(e, t) { var n = this.center.distanceToSquared(e); return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t } getBoundingBox(e) { return this.isEmpty() ? e.makeEmpty() : (e.set(this.center, this.center), e.expandByScalar(this.radius)), e } applyMatrix4(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this } translate(e) { return this.center.add(e), this } expandByPoint(e) { yt.subVectors(e, this.center); var t = yt.lengthSq(); if (t > this.radius * this.radius) { const e = Math.sqrt(t), n = .5 * (e - this.radius); this.center.add(yt.multiplyScalar(n / e)), this.radius += n } return this } union(e) { return vt.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(gt.copy(e.center).add(vt)), this.expandByPoint(gt.copy(e.center).sub(vt)), this } equals(e) { return e.center.equals(this.center) && e.radius === this.radius } clone() { return (new this.constructor).copy(this) } } const _t = new Le, bt = new Le, Mt = new Le, wt = new Le, Tt = new Le, Et = new Le, St = new Le; class At { constructor(e = new Le, t = new Le(0, 0, -1)) { this.origin = e, this.direction = t } set(e, t) { return this.origin.copy(e), this.direction.copy(t), this } copy(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this } at(e, t) { return t.copy(this.direction).multiplyScalar(e).add(this.origin) } lookAt(e) { return this.direction.copy(e).sub(this.origin).normalize(), this } recast(e) { return this.origin.copy(this.at(e, _t)), this } closestPointToPoint(e, t) { t.subVectors(e, this.origin); e = t.dot(this.direction); return e < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(e).add(this.origin) } distanceToPoint(e) { return Math.sqrt(this.distanceSqToPoint(e)) } distanceSqToPoint(e) { var t = _t.subVectors(e, this.origin).dot(this.direction); return t < 0 ? this.origin.distanceToSquared(e) : (_t.copy(this.direction).multiplyScalar(t).add(this.origin), _t.distanceToSquared(e)) } distanceSqToSegment(e, t, n, r) { bt.copy(e).add(t).multiplyScalar(.5), Mt.copy(t).sub(e).normalize(), wt.copy(this.origin).sub(bt); var e = .5 * e.distanceTo(t), t = -this.direction.dot(Mt), i = wt.dot(this.direction), a = -wt.dot(Mt), s = wt.lengthSq(), o = Math.abs(1 - t * t); let l, c, h, u; if (0 < o) if (l = t * a - i, c = t * i - a, u = e * o, 0 <= l) if (c >= -u) if (c <= u) { const e = 1 / o; l *= e, c *= e, h = l * (l + t * c + 2 * i) + c * (t * l + c + 2 * a) + s } else c = e, l = Math.max(0, -(t * c + i)), h = -l * l + c * (c + 2 * a) + s; else c = -e, l = Math.max(0, -(t * c + i)), h = -l * l + c * (c + 2 * a) + s; else h = c <= -u ? (l = Math.max(0, -(-t * e + i)), c = 0 < l ? -e : Math.min(Math.max(-e, -a), e), -l * l + c * (c + 2 * a) + s) : c <= u ? (l = 0, (c = Math.min(Math.max(-e, -a), e)) * (c + 2 * a) + s) : (l = Math.max(0, -(t * e + i)), c = 0 < l ? e : Math.min(Math.max(-e, -a), e), -l * l + c * (c + 2 * a) + s); else c = 0 < t ? -e : e, l = Math.max(0, -(t * c + i)), h = -l * l + c * (c + 2 * a) + s; return n && n.copy(this.direction).multiplyScalar(l).add(this.origin), r && r.copy(Mt).multiplyScalar(c).add(bt), h } intersectSphere(e, t) { _t.subVectors(e.center, this.origin); var n = _t.dot(this.direction), r = _t.dot(_t) - n * n, e = e.radius * e.radius; if (e < r) return null; e = Math.sqrt(e - r), r = n - e, n += e; return r < 0 && n < 0 ? null : r < 0 ? this.at(n, t) : this.at(r, t) } intersectsSphere(e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius } distanceToPlane(e) { var t = e.normal.dot(this.direction); if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null; e = -(this.origin.dot(e.normal) + e.constant) / t; return 0 <= e ? e : null } intersectPlane(e, t) { e = this.distanceToPlane(e); return null === e ? null : this.at(e, t) } intersectsPlane(e) { var t = e.distanceToPoint(this.origin); return 0 === t || e.normal.dot(this.direction) * t < 0 } intersectBox(e, t) { let n, r, i, a, s, o; var l = 1 / this.direction.x, c = 1 / this.direction.y, h = 1 / this.direction.z, u = this.origin; return r = 0 <= l ? (n = (e.min.x - u.x) * l, (e.max.x - u.x) * l) : (n = (e.max.x - u.x) * l, (e.min.x - u.x) * l), a = 0 <= c ? (i = (e.min.y - u.y) * c, (e.max.y - u.y) * c) : (i = (e.max.y - u.y) * c, (e.min.y - u.y) * c), n > a || i > r ? null : ((i > n || n != n) && (n = i), (a < r || r != r) && (r = a), o = 0 <= h ? (s = (e.min.z - u.z) * h, (e.max.z - u.z) * h) : (s = (e.max.z - u.z) * h, (e.min.z - u.z) * h), n > o || s > r ? null : ((s > n || n != n) && (n = s), (r = o < r || r != r ? o : r) < 0 ? null : this.at(0 <= n ? n : r, t))) } intersectsBox(e) { return null !== this.intersectBox(e, _t) } intersectTriangle(e, t, n, r, i) { Tt.subVectors(t, e), Et.subVectors(n, e), St.crossVectors(Tt, Et); let a, s = this.direction.dot(St); if (0 < s) { if (r) return null; a = 1 } else { if (!(s < 0)) return null; a = -1, s = -s } wt.subVectors(this.origin, e); t = a * this.direction.dot(Et.crossVectors(wt, Et)); if (t < 0) return null; n = a * this.direction.dot(Tt.cross(wt)); if (n < 0) return null; if (t + n > s) return null; r = -a * wt.dot(St); return r < 0 ? null : this.at(r / s, i) } applyMatrix4(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this } equals(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } clone() { return (new this.constructor).copy(this) } } class Ce { constructor() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") } set(e, t, n, r, i, a, s, o, l, c, h, u, d, p, m, f) { const g = this.elements; return g[0] = e, g[4] = t, g[8] = n, g[12] = r, g[1] = i, g[5] = a, g[9] = s, g[13] = o, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = m, g[15] = f, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return (new Ce).fromArray(this.elements) } copy(e) { const t = this.elements, n = e.elements; return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this } copyPosition(e) { const t = this.elements, n = e.elements; return t[12] = n[12], t[13] = n[13], t[14] = n[14], this } setFromMatrix3(e) { e = e.elements; return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this } extractBasis(e, t, n) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this } makeBasis(e, t, n) { return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this } extractRotation(e) { const t = this.elements, n = e.elements, r = 1 / Rt.setFromMatrixColumn(e, 0).length(), i = 1 / Rt.setFromMatrixColumn(e, 1).length(), a = 1 / Rt.setFromMatrixColumn(e, 2).length(); return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromEuler(e) { e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); const t = this.elements, n = e.x, r = e.y, i = e.z, a = Math.cos(n), s = Math.sin(n), o = Math.cos(r), l = Math.sin(r), c = Math.cos(i), h = Math.sin(i); if ("XYZ" === e.order) { const e = a * c, n = a * h, r = s * c, i = s * h; t[0] = o * c, t[4] = -o * h, t[8] = l, t[1] = n + r * l, t[5] = e - i * l, t[9] = -s * o, t[2] = i - e * l, t[6] = r + n * l, t[10] = a * o } else if ("YXZ" === e.order) { const e = o * c, n = o * h, r = l * c, i = l * h; t[0] = e + i * s, t[4] = r * s - n, t[8] = a * l, t[1] = a * h, t[5] = a * c, t[9] = -s, t[2] = n * s - r, t[6] = i + e * s, t[10] = a * o } else if ("ZXY" === e.order) { const e = o * c, n = o * h, r = l * c, i = l * h; t[0] = e - i * s, t[4] = -a * h, t[8] = r + n * s, t[1] = n + r * s, t[5] = a * c, t[9] = i - e * s, t[2] = -a * l, t[6] = s, t[10] = a * o } else if ("ZYX" === e.order) { const e = a * c, n = a * h, r = s * c, i = s * h; t[0] = o * c, t[4] = r * l - n, t[8] = e * l + i, t[1] = o * h, t[5] = i * l + e, t[9] = n * l - r, t[2] = -l, t[6] = s * o, t[10] = a * o } else if ("YZX" === e.order) { const e = a * o, n = a * l, r = s * o, i = s * l; t[0] = o * c, t[4] = i - e * h, t[8] = r * h + n, t[1] = h, t[5] = a * c, t[9] = -s * c, t[2] = -l * c, t[6] = n * h + r, t[10] = e - i * h } else if ("XZY" === e.order) { const e = a * o, n = a * l, r = s * o, i = s * l; t[0] = o * c, t[4] = -h, t[8] = l * c, t[1] = e * h + i, t[5] = a * c, t[9] = n * h - r, t[2] = r * h - n, t[6] = s * c, t[10] = i * h + e } return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromQuaternion(e) { return this.compose(Ct, e, Pt) } lookAt(e, t, n) { const r = this.elements; return Nt.subVectors(e, t), 0 === Nt.lengthSq() && (Nt.z = 1), Nt.normalize(), It.crossVectors(n, Nt), 0 === It.lengthSq() && (1 === Math.abs(n.z) ? Nt.x += 1e-4 : Nt.z += 1e-4, Nt.normalize(), It.crossVectors(n, Nt)), It.normalize(), Dt.crossVectors(Nt, It), r[0] = It.x, r[4] = Dt.x, r[8] = Nt.x, r[1] = It.y, r[5] = Dt.y, r[9] = Nt.y, r[2] = It.z, r[6] = Dt.z, r[10] = Nt.z, this } multiply(e, t) { return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, O) { const t = e.elements, n = O.elements, r = this.elements, i = t[0], a = t[4], s = t[8], o = t[12], l = t[1], c = t[5], h = t[9], u = t[13], d = t[2], p = t[6], m = t[10], f = t[14], g = t[3], v = t[7], y = t[11], x = t[15], _ = n[0], b = n[4], M = n[8], w = n[12], T = n[1], E = n[5], S = n[9], A = n[13], R = n[2], L = n[6], C = n[10], P = n[14], I = n[3], D = n[7], N = n[11], H = n[15]; return r[0] = i * _ + a * T + s * R + o * I, r[4] = i * b + a * E + s * L + o * D, r[8] = i * M + a * S + s * C + o * N, r[12] = i * w + a * A + s * P + o * H, r[1] = l * _ + c * T + h * R + u * I, r[5] = l * b + c * E + h * L + u * D, r[9] = l * M + c * S + h * C + u * N, r[13] = l * w + c * A + h * P + u * H, r[2] = d * _ + p * T + m * R + f * I, r[6] = d * b + p * E + m * L + f * D, r[10] = d * M + p * S + m * C + f * N, r[14] = d * w + p * A + m * P + f * H, r[3] = g * _ + v * T + y * R + x * I, r[7] = g * b + v * E + y * L + x * D, r[11] = g * M + v * S + y * C + x * N, r[15] = g * w + v * A + y * P + x * H, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this } determinant() { var e = this.elements, t = e[0], n = e[4], r = e[8], i = e[12], a = e[1], s = e[5], o = e[9], l = e[13], c = e[2], h = e[6], u = e[10], d = e[14]; return e[3] * (+i * o * h - r * l * h - i * s * u + n * l * u + r * s * d - n * o * d) + e[7] * (+t * o * d - t * l * u + i * a * u - r * a * d + r * l * c - i * o * c) + e[11] * (+t * l * h - t * s * d - i * a * h + n * a * d + i * s * c - n * l * c) + e[15] * (-r * s * c - t * o * h + t * s * u + r * a * h - n * a * u + n * o * c) } transpose() { const e = this.elements; var t = e[1]; return e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this } setPosition(e, t, n) { const r = this.elements; return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this } invert() { const e = this.elements, t = e[0], n = e[1], r = e[2], i = e[3], a = e[4], s = e[5], o = e[6], l = e[7], c = e[8], h = e[9], u = e[10], d = e[11], p = e[12], m = e[13], f = e[14], g = e[15], v = h * f * l - m * u * l + m * o * d - s * f * d - h * o * g + s * u * g, y = p * u * l - c * f * l - p * o * d + a * f * d + c * o * g - a * u * g, x = c * m * l - p * h * l + p * s * d - a * m * d - c * s * g + a * h * g, _ = p * h * o - c * m * o - p * s * u + a * m * u + c * s * f - a * h * f, b = t * v + n * y + r * x + i * _; if (0 == b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); var M = 1 / b; return e[0] = v * M, e[1] = (m * u * i - h * f * i - m * r * d + n * f * d + h * r * g - n * u * g) * M, e[2] = (s * f * i - m * o * i + m * r * l - n * f * l - s * r * g + n * o * g) * M, e[3] = (h * o * i - s * u * i - h * r * l + n * u * l + s * r * d - n * o * d) * M, e[4] = y * M, e[5] = (c * f * i - p * u * i + p * r * d - t * f * d - c * r * g + t * u * g) * M, e[6] = (p * o * i - a * f * i - p * r * l + t * f * l + a * r * g - t * o * g) * M, e[7] = (a * u * i - c * o * i + c * r * l - t * u * l - a * r * d + t * o * d) * M, e[8] = x * M, e[9] = (p * h * i - c * m * i - p * n * d + t * m * d + c * n * g - t * h * g) * M, e[10] = (a * m * i - p * s * i + p * n * l - t * m * l - a * n * g + t * s * g) * M, e[11] = (c * s * i - a * h * i - c * n * l + t * h * l + a * n * d - t * s * d) * M, e[12] = _ * M, e[13] = (c * m * r - p * h * r + p * n * u - t * m * u - c * n * f + t * h * f) * M, e[14] = (p * s * r - a * m * r - p * n * o + t * m * o + a * n * f - t * s * f) * M, e[15] = (a * h * r - c * s * r + c * n * o - t * h * o - a * n * u + t * s * u) * M, this } scale(e) { const t = this.elements, n = e.x, r = e.y, i = e.z; return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *= n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *= r, t[10] *= i, t[3] *= n, t[7] *= r, t[11] *= i, this } getMaxScaleOnAxis() { var e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], e = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(t, n, e)) } makeTranslation(e, t, n) { return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this } makeRotationX(e) { var t = Math.cos(e), e = Math.sin(e); return this.set(1, 0, 0, 0, 0, t, -e, 0, 0, e, t, 0, 0, 0, 0, 1), this } makeRotationY(e) { var t = Math.cos(e), e = Math.sin(e); return this.set(t, 0, e, 0, 0, 1, 0, 0, -e, 0, t, 0, 0, 0, 0, 1), this } makeRotationZ(e) { var t = Math.cos(e), e = Math.sin(e); return this.set(t, -e, 0, 0, e, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(e, t) { var n = Math.cos(t), t = Math.sin(t), r = 1 - n, i = e.x, a = e.y, e = e.z, s = r * i, o = r * a; return this.set(s * i + n, s * a - t * e, s * e + t * a, 0, s * a + t * e, o * a + n, o * e - t * i, 0, s * e - t * a, o * e + t * i, r * e * e + n, 0, 0, 0, 0, 1), this } makeScale(e, t, n) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this } makeShear(e, t, n, r, i, a) { return this.set(1, n, i, 0, e, 1, a, 0, t, r, 1, 0, 0, 0, 0, 1), this } compose(e, t, n) { const r = this.elements, i = t._x, a = t._y, s = t._z, o = t._w, l = i + i, c = a + a, h = s + s, u = i * l, d = i * c, p = i * h, m = a * c, f = a * h, g = s * h, v = o * l, y = o * c, x = o * h, _ = n.x, b = n.y, M = n.z; return r[0] = (1 - (m + g)) * _, r[1] = (d + x) * _, r[2] = (p - y) * _, r[3] = 0, r[4] = (d - x) * b, r[5] = (1 - (u + g)) * b, r[6] = (f + v) * b, r[7] = 0, r[8] = (p + y) * M, r[9] = (f - v) * M, r[10] = (1 - (u + m)) * M, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this } decompose(e, t, n) { var r = this.elements; let i = Rt.set(r[0], r[1], r[2]).length(); var a = Rt.set(r[4], r[5], r[6]).length(), s = Rt.set(r[8], r[9], r[10]).length(), e = (this.determinant() < 0 && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], Lt.copy(this), 1 / i), r = 1 / a, o = 1 / s; return Lt.elements[0] *= e, Lt.elements[1] *= e, Lt.elements[2] *= e, Lt.elements[4] *= r, Lt.elements[5] *= r, Lt.elements[6] *= r, Lt.elements[8] *= o, Lt.elements[9] *= o, Lt.elements[10] *= o, t.setFromRotationMatrix(Lt), n.x = i, n.y = a, n.z = s, this } makePerspective(e, t, n, r, i, a) { void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); const s = this.elements, o = 2 * i / (t - e), l = 2 * i / (n - r), c = (t + e) / (t - e), h = (n + r) / (n - r), u = -(a + i) / (a - i), d = -2 * a * i / (a - i); return s[0] = o, s[4] = 0, s[8] = c, s[12] = 0, s[1] = 0, s[5] = l, s[9] = h, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = u, s[14] = d, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this } makeOrthographic(e, t, n, r, i, a) { const s = this.elements, o = 1 / (t - e), l = 1 / (n - r), c = 1 / (a - i), h = (t + e) * o, u = (n + r) * l, d = (a + i) * c; return s[0] = 2 * o, s[4] = 0, s[8] = 0, s[12] = -h, s[1] = 0, s[5] = 2 * l, s[9] = 0, s[13] = -u, s[2] = 0, s[6] = 0, s[10] = -2 * c, s[14] = -d, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this } equals(e) { var t = this.elements, n = e.elements; for (let e = 0; e < 16; e++)if (t[e] !== n[e]) return !1; return !0 } fromArray(t, n = 0) { for (let e = 0; e < 16; e++)this.elements[e] = t[e + n]; return this } toArray(e = [], t = 0) { var n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e } } Ce.prototype.isMatrix4 = !0; const Rt = new Le, Lt = new Ce, Ct = new Le(0, 0, 0), Pt = new Le(1, 1, 1), It = new Le, Dt = new Le, Nt = new Le, Ht = new Ce, Ot = new f; class Ft { constructor(e = 0, t = 0, n = 0, r = Ft.DefaultOrder) { this._x = e, this._y = t, this._z = n, this._order = r } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get order() { return this._order } set order(e) { this._order = e, this._onChangeCallback() } set(e, t, n, r = this._order) { return this._x = e, this._y = t, this._z = n, this._order = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this } setFromRotationMatrix(e, t = this._order, n = !0) { var e = e.elements, r = e[0], i = e[4], a = e[8], s = e[1], o = e[5], l = e[9], c = e[2], h = e[6], u = e[10]; switch (t) { case "XYZ": this._y = Math.asin(m(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-l, u), this._z = Math.atan2(-i, r)) : (this._x = Math.atan2(h, o), this._z = 0); break; case "YXZ": this._x = Math.asin(-m(l, -1, 1)), Math.abs(l) < .9999999 ? (this._y = Math.atan2(a, u), this._z = Math.atan2(s, o)) : (this._y = Math.atan2(-c, r), this._z = 0); break; case "ZXY": this._x = Math.asin(m(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-c, u), this._z = Math.atan2(-i, o)) : (this._y = 0, this._z = Math.atan2(s, r)); break; case "ZYX": this._y = Math.asin(-m(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(h, u), this._z = Math.atan2(s, r)) : (this._x = 0, this._z = Math.atan2(-i, o)); break; case "YZX": this._z = Math.asin(m(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-l, o), this._y = Math.atan2(-c, r)) : (this._x = 0, this._y = Math.atan2(a, u)); break; case "XZY": this._z = Math.asin(-m(i, -1, 1)), Math.abs(i) < .9999999 ? (this._x = Math.atan2(h, o), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-l, u), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t) }return this._order = t, !0 === n && this._onChangeCallback(), this } setFromQuaternion(e, t, n) { return Ht.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Ht, t, n) } setFromVector3(e, t = this._order) { return this.set(e.x, e.y, e.z, t) } reorder(e) { return Ot.setFromEuler(this), this.setFromQuaternion(Ot, e) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order } fromArray(e) { return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e } toVector3(e) { return e ? e.set(this._x, this._y, this._z) : new Le(this._x, this._y, this._z) } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } } Ft.prototype.isEuler = !0, Ft.DefaultOrder = "XYZ", Ft.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]; class Bt { constructor() { this.mask = 1 } set(e) { this.mask = 1 << e | 0 } enable(e) { this.mask |= 1 << e | 0 } enableAll() { this.mask = -1 } toggle(e) { this.mask ^= 1 << e | 0 } disable(e) { this.mask &= ~(1 << e | 0) } disableAll() { this.mask = 0 } test(e) { return 0 != (this.mask & e.mask) } } let Ut = 0; const zt = new Le, Gt = new f, kt = new Ce, Vt = new Le, Wt = new Le, jt = new Le, qt = new f, Xt = new Le(1, 0, 0), Yt = new Le(0, 1, 0), Zt = new Le(0, 0, 1), Jt = { type: "added" }, Kt = { type: "removed" }; class u extends we { constructor() { super(), Object.defineProperty(this, "id", { value: Ut++ }), this.uuid = Be(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = u.DefaultUp.clone(); const e = new Le, t = new Ft, n = new f, r = new Le(1, 1, 1); t._onChange(function () { n.setFromEuler(t, !1) }), n._onChange(function () { t.setFromQuaternion(n, void 0, !1) }), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new Ce }, normalMatrix: { value: new v } }), this.matrix = new Ce, this.matrixWorld = new Ce, this.matrixAutoUpdate = u.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Bt, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } onBeforeRender() { } onAfterRender() { } applyMatrix4(e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(e) { return this.quaternion.premultiply(e), this } setRotationFromAxisAngle(e, t) { this.quaternion.setFromAxisAngle(e, t) } setRotationFromEuler(e) { this.quaternion.setFromEuler(e, !0) } setRotationFromMatrix(e) { this.quaternion.setFromRotationMatrix(e) } setRotationFromQuaternion(e) { this.quaternion.copy(e) } rotateOnAxis(e, t) { return Gt.setFromAxisAngle(e, t), this.quaternion.multiply(Gt), this } rotateOnWorldAxis(e, t) { return Gt.setFromAxisAngle(e, t), this.quaternion.premultiply(Gt), this } rotateX(e) { return this.rotateOnAxis(Xt, e) } rotateY(e) { return this.rotateOnAxis(Yt, e) } rotateZ(e) { return this.rotateOnAxis(Zt, e) } translateOnAxis(e, t) { return zt.copy(e).applyQuaternion(this.quaternion), this.position.add(zt.multiplyScalar(t)), this } translateX(e) { return this.translateOnAxis(Xt, e) } translateY(e) { return this.translateOnAxis(Yt, e) } translateZ(e) { return this.translateOnAxis(Zt, e) } localToWorld(e) { return e.applyMatrix4(this.matrixWorld) } worldToLocal(e) { return e.applyMatrix4(kt.copy(this.matrixWorld).invert()) } lookAt(e, t, n) { e.isVector3 ? Vt.copy(e) : Vt.set(e, t, n); e = this.parent; this.updateWorldMatrix(!0, !1), Wt.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? kt.lookAt(Wt, Vt, this.up) : kt.lookAt(Vt, Wt, this.up), this.quaternion.setFromRotationMatrix(kt), e && (kt.extractRotation(e.matrixWorld), Gt.setFromRotationMatrix(kt), this.quaternion.premultiply(Gt.invert())) } add(e) { if (1 < arguments.length) { for (let e = 0; e < arguments.length; e++)this.add(arguments[e]); return this } return e === this ? console.error("THREE.Object3D.add: object can't be added as a child of itself.", e) : e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), (e.parent = this).children.push(e), e.dispatchEvent(Jt)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this } remove(e) { if (1 < arguments.length) { for (let e = 0; e < arguments.length; e++)this.remove(arguments[e]); return this } var t = this.children.indexOf(e); return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Kt)), this } removeFromParent() { const e = this.parent; return null !== e && e.remove(this), this } clear() { for (let e = 0; e < this.children.length; e++) { const t = this.children[e]; t.parent = null, t.dispatchEvent(Kt) } return this.children.length = 0, this } attach(e) { return this.updateWorldMatrix(!0, !1), kt.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), kt.multiply(e.parent.matrixWorld)), e.applyMatrix4(kt), this.add(e), e.updateWorldMatrix(!1, !0), this } getObjectById(e) { return this.getObjectByProperty("id", e) } getObjectByName(e) { return this.getObjectByProperty("name", e) } getObjectByProperty(n, r) { if (this[n] === r) return this; for (let e = 0, t = this.children.length; e < t; e++) { var i = this.children[e].getObjectByProperty(n, r); if (void 0 !== i) return i } } getWorldPosition(e) { return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Wt, e, jt), e } getWorldScale(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Wt, qt, e), e } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); var t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() } raycast() { } traverse(n) { n(this); const r = this.children; for (let e = 0, t = r.length; e < t; e++)r[e].traverse(n) } traverseVisible(n) { if (!1 !== this.visible) { n(this); const r = this.children; for (let e = 0, t = r.length; e < t; e++)r[e].traverseVisible(n) } } traverseAncestors(e) { const t = this.parent; null !== t && (e(t), t.traverseAncestors(e)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(n) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || n) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), n = !(this.matrixWorldNeedsUpdate = !1)); const r = this.children; for (let e = 0, t = r.length; e < t; e++)r[e].updateMatrixWorld(n) } updateWorldMatrix(n, e) { const t = this.parent; if (!0 === n && null !== t && t.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) { const n = this.children; for (let e = 0, t = n.length; e < t; e++)n[e].updateWorldMatrix(!1, !0) } } toJSON(n) { const r = void 0 === n || "string" == typeof n, i = {}, a = (r && (n = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, i.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }), {}); function s(e, t) { return void 0 === e[t.uuid] && (e[t.uuid] = t.toJSON(n)), t.uuid } if (a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), !0 === this.castShadow && (a.castShadow = !0), !0 === this.receiveShadow && (a.receiveShadow = !0), !1 === this.visible && (a.visible = !1), !1 === this.frustumCulled && (a.frustumCulled = !1), 0 !== this.renderOrder && (a.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (a.userData = this.userData), a.layers = this.layers.mask, a.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (a.matrixAutoUpdate = !1), this.isInstancedMesh && (a.type = "InstancedMesh", a.count = this.count, a.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (a.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? a.background = this.background.toJSON() : this.background.isTexture && (a.background = this.background.toJSON(n).uuid)), this.environment && this.environment.isTexture && (a.environment = this.environment.toJSON(n).uuid); else if (this.isMesh || this.isLine || this.isPoints) { a.geometry = s(n.geometries, this.geometry); const r = this.geometry.parameters; if (void 0 !== r && void 0 !== r.shapes) { const i = r.shapes; if (Array.isArray(i)) for (let e = 0, t = i.length; e < t; e++) { const a = i[e]; s(n.shapes, a) } else s(n.shapes, i) } } if (this.isSkinnedMesh && (a.bindMode = this.bindMode, a.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (s(n.skeletons, this.skeleton), a.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) { const r = []; for (let e = 0, t = this.material.length; e < t; e++)r.push(s(n.materials, this.material[e])); a.material = r } else a.material = s(n.materials, this.material); if (0 < this.children.length) { a.children = []; for (let e = 0; e < this.children.length; e++)a.children.push(this.children[e].toJSON(n).object) } if (0 < this.animations.length) { a.animations = []; for (let e = 0; e < this.animations.length; e++) { const i = this.animations[e]; a.animations.push(s(n.animations, i)) } } if (r) { const r = e(n.geometries), a = e(n.materials), s = e(n.textures), t = e(n.images), o = e(n.shapes), l = e(n.skeletons), c = e(n.animations); 0 < r.length && (i.geometries = r), 0 < a.length && (i.materials = a), 0 < s.length && (i.textures = s), 0 < t.length && (i.images = t), 0 < o.length && (i.shapes = o), 0 < l.length && (i.skeletons = l), 0 < c.length && (i.animations = c) } return i.object = a, i; function e(e) { const t = []; for (const n in e) { const r = e[n]; delete r.metadata, t.push(r) } return t } } clone(e) { return (new this.constructor).copy(this, e) } copy(t, e = !0) { if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (let e = 0; e < t.children.length; e++) { const n = t.children[e]; this.add(n.clone()) } return this } } u.DefaultUp = new Le(0, 1, 0), u.DefaultMatrixAutoUpdate = !0, u.prototype.isObject3D = !0; const Qt = new Le, $t = new Le, en = new Le, tn = new Le, nn = new Le, rn = new Le, an = new Le, sn = new Le, on = new Le, ln = new Le; class g { constructor(e = new Le, t = new Le, n = new Le) { this.a = e, this.b = t, this.c = n } static getNormal(e, t, n, r) { r.subVectors(n, t), Qt.subVectors(e, t), r.cross(Qt); n = r.lengthSq(); return 0 < n ? r.multiplyScalar(1 / Math.sqrt(n)) : r.set(0, 0, 0) } static getBarycoord(e, t, n, r, i) { Qt.subVectors(r, t), $t.subVectors(n, t), en.subVectors(e, t); var r = Qt.dot(Qt), n = Qt.dot($t), e = Qt.dot(en), t = $t.dot($t), a = $t.dot(en), s = r * t - n * n; if (0 == s) return i.set(-2, -1, -1); s = 1 / s, t = (t * e - n * a) * s, r = (r * a - n * e) * s; return i.set(1 - t - r, r, t) } static containsPoint(e, t, n, r) { return this.getBarycoord(e, t, n, r, tn), 0 <= tn.x && 0 <= tn.y && tn.x + tn.y <= 1 } static getUV(e, t, n, r, i, a, s, o) { return this.getBarycoord(e, t, n, r, tn), o.set(0, 0), o.addScaledVector(i, tn.x), o.addScaledVector(a, tn.y), o.addScaledVector(s, tn.z), o } static isFrontFacing(e, t, n, r) { return Qt.subVectors(n, t), $t.subVectors(e, t), Qt.cross($t).dot(r) < 0 } set(e, t, n) { return this.a.copy(e), this.b.copy(t), this.c.copy(n), this } setFromPointsAndIndices(e, t, n, r) { return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this } clone() { return (new this.constructor).copy(this) } copy(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this } getArea() { return Qt.subVectors(this.c, this.b), $t.subVectors(this.a, this.b), .5 * Qt.cross($t).length() } getMidpoint(e) { return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(e) { return g.getNormal(this.a, this.b, this.c, e) } getPlane(e) { return e.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(e, t) { return g.getBarycoord(e, this.a, this.b, this.c, t) } getUV(e, t, n, r, i) { return g.getUV(e, this.a, this.b, this.c, t, n, r, i) } containsPoint(e) { return g.containsPoint(e, this.a, this.b, this.c) } isFrontFacing(e) { return g.isFrontFacing(this.a, this.b, this.c, e) } intersectsBox(e) { return e.intersectsTriangle(this) } closestPointToPoint(e, t) { var n = this.a, r = this.b, i = this.c; let a, s; nn.subVectors(r, n), rn.subVectors(i, n), sn.subVectors(e, n); var o = nn.dot(sn), l = rn.dot(sn); if (o <= 0 && l <= 0) return t.copy(n); on.subVectors(e, r); var c = nn.dot(on), h = rn.dot(on); if (0 <= c && h <= c) return t.copy(r); var u = o * h - c * l; if (u <= 0 && 0 <= o && c <= 0) return a = o / (o - c), t.copy(n).addScaledVector(nn, a); ln.subVectors(e, i); var e = nn.dot(ln), d = rn.dot(ln); if (0 <= d && e <= d) return t.copy(i); o = e * l - o * d; if (o <= 0 && 0 <= l && d <= 0) return s = l / (l - d), t.copy(n).addScaledVector(rn, s); l = c * d - e * h; if (l <= 0 && 0 <= h - c && 0 <= e - d) return an.subVectors(i, r), s = (h - c) / (h - c + (e - d)), t.copy(r).addScaledVector(an, s); i = 1 / (l + o + u); return a = o * i, s = u * i, t.copy(n).addScaledVector(nn, a).addScaledVector(rn, s) } equals(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } } let cn = 0; class t extends we { constructor() { super(), Object.defineProperty(this, "id", { value: cn++ }), this.uuid = Be(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = q, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0 } onBuild() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(e) { if (void 0 !== e) for (const n in e) { var t = e[n]; if (void 0 === t) console.warn("THREE.Material: '" + n + "' parameter is undefined."); else if ("shading" === n) console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t; else { const r = this[n]; void 0 !== r ? r && r.isColor ? r.set(t) : r && r.isVector3 && t && t.isVector3 ? r.copy(t) : this[n] = t : console.warn("THREE." + this.type + ": '" + n + "' is not a property of this material.") } } } toJSON(e) { const t = void 0 === e || "string" == typeof e, n = (t && (e = { textures: {}, images: {} }), { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }); function r(e) { const t = []; for (const n in e) { const r = e[n]; delete r.metadata, t.push(r) } return t } if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularTint && this.specularTint.isColor && (n.specularTint = this.specularTint.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularTintMap && this.specularTintMap.isTexture && (n.specularTintMap = this.specularTintMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationTint && (n.attenuationTint = this.attenuationTint.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) { const t = r(e.textures), i = r(e.images); 0 < t.length && (n.textures = t), 0 < i.length && (n.images = i) } return n } clone() { return (new this.constructor).copy(this) } copy(t) { this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite; const n = t.clippingPlanes; let r = null; if (null !== n) { const t = n.length; r = new Array(t); for (let e = 0; e !== t; ++e)r[e] = n[e].clone() } return this.clippingPlanes = r, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(e) { !0 === e && this.version++ } } t.prototype.isMaterial = !0; const hn = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, un = { h: 0, s: 0, l: 0 }, dn = { h: 0, s: 0, l: 0 }; function pn(e, t, n) { return n < 0 && (n += 1), 1 < n && --n, n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e } function mn(e) { return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4) } function fn(e) { return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055 } class y { constructor(e, t, n) { return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n) } set(e) { return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this } setScalar(e) { return this.r = e, this.g = e, this.b = e, this } setHex(e) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this } setRGB(e, t, n) { return this.r = e, this.g = t, this.b = n, this } setHSL(e, t, n) { return e = Ue(e, 1), t = m(t, 0, 1), n = m(n, 0, 1), 0 === t ? this.r = this.g = this.b = n : (this.r = pn(t = 2 * n - (n = n <= .5 ? n * (1 + t) : n + t - n * t), n, e + 1 / 3), this.g = pn(t, n, e), this.b = pn(t, n, e - 1 / 3)), this } setStyle(t) { function n(e) { void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.") } let r; if (r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) { let e; var i = r[1], a = r[2]; switch (i) { case "rgb": case "rgba": if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, n(e[4]), this; if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, n(e[4]), this; break; case "hsl": case "hsla": if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) { const r = parseFloat(e[1]) / 360, s = parseInt(e[2], 10) / 100, o = parseInt(e[3], 10) / 100; return n(e[4]), this.setHSL(r, s, o) } } } else if (r = /^\#([A-Fa-f\d]+)$/.exec(t)) { const t = r[1], n = t.length; if (3 === n) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this; if (6 === n) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this } return t && 0 < t.length ? this.setColorName(t) : this } setColorName(e) { var t = hn[e.toLowerCase()]; return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } copyGammaToLinear(e, t = 2) { return this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this } copyLinearToGamma(e, t = 2) { t = 0 < t ? 1 / t : 1; return this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this } convertGammaToLinear(e) { return this.copyGammaToLinear(this, e), this } convertLinearToGamma(e) { return this.copyLinearToGamma(this, e), this } copySRGBToLinear(e) { return this.r = mn(e.r), this.g = mn(e.g), this.b = mn(e.b), this } copyLinearToSRGB(e) { return this.r = fn(e.r), this.g = fn(e.g), this.b = fn(e.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex() { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 } getHexString() { return ("000000" + this.getHex().toString(16)).slice(-6) } getHSL(e) { var t = this.r, n = this.g, r = this.b, i = Math.max(t, n, r), a = Math.min(t, n, r); let s, o; var l = (a + i) / 2; if (a === i) s = 0, o = 0; else { const e = i - a; switch (o = l <= .5 ? e / (i + a) : e / (2 - i - a), i) { case t: s = (n - r) / e + (n < r ? 6 : 0); break; case n: s = (r - t) / e + 2; break; case r: s = (t - n) / e + 4 }s /= 6 } return e.h = s, e.s = o, e.l = l, e } getStyle() { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" } offsetHSL(e, t, n) { return this.getHSL(un), un.h += e, un.s += t, un.l += n, this.setHSL(un.h, un.s, un.l), this } add(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this } addColors(e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this } addScalar(e) { return this.r += e, this.g += e, this.b += e, this } sub(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this } multiply(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this } multiplyScalar(e) { return this.r *= e, this.g *= e, this.b *= e, this } lerp(e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this } lerpColors(e, t, n) { return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this } lerpHSL(e, t) { this.getHSL(un), e.getHSL(dn); var e = ze(un.h, dn.h, t), n = ze(un.s, dn.s, t), t = ze(un.l, dn.l, t); return this.setHSL(e, n, t), this } equals(e) { return e.r === this.r && e.g === this.g && e.b === this.b } fromArray(e, t = 0) { return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e } fromBufferAttribute(e, t) { return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this } toJSON() { return this.getHex() } } y.NAMES = hn, y.prototype.isColor = !0, y.prototype.r = 1, y.prototype.g = 1, y.prototype.b = 1; class gn extends t { constructor(e) { super(), this.type = "MeshBasicMaterial", this.color = new y(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this } } gn.prototype.isMeshBasicMaterial = !0; const r = new Le, vn = new k; class E { constructor(e, t, n) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = _e, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } onUploadCallback() { } set needsUpdate(e) { !0 === e && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this } copyAt(n, r, i) { n *= this.itemSize, i *= r.itemSize; for (let e = 0, t = this.itemSize; e < t; e++)this.array[n + e] = r.array[i + e]; return this } copyArray(e) { return this.array.set(e), this } copyColorsArray(n) { const r = this.array; let i = 0; for (let t = 0, e = n.length; t < e; t++) { let e = n[t]; void 0 === e && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", t), e = new y), r[i++] = e.r, r[i++] = e.g, r[i++] = e.b } return this } copyVector2sArray(n) { const r = this.array; let i = 0; for (let t = 0, e = n.length; t < e; t++) { let e = n[t]; void 0 === e && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", t), e = new k), r[i++] = e.x, r[i++] = e.y } return this } copyVector3sArray(n) { const r = this.array; let i = 0; for (let t = 0, e = n.length; t < e; t++) { let e = n[t]; void 0 === e && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", t), e = new Le), r[i++] = e.x, r[i++] = e.y, r[i++] = e.z } return this } copyVector4sArray(n) { const r = this.array; let i = 0; for (let t = 0, e = n.length; t < e; t++) { let e = n[t]; void 0 === e && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", t), e = new Re), r[i++] = e.x, r[i++] = e.y, r[i++] = e.z, r[i++] = e.w } return this } applyMatrix3(n) { if (2 === this.itemSize) for (let e = 0, t = this.count; e < t; e++)vn.fromBufferAttribute(this, e), vn.applyMatrix3(n), this.setXY(e, vn.x, vn.y); else if (3 === this.itemSize) for (let e = 0, t = this.count; e < t; e++)r.fromBufferAttribute(this, e), r.applyMatrix3(n), this.setXYZ(e, r.x, r.y, r.z); return this } applyMatrix4(n) { for (let e = 0, t = this.count; e < t; e++)r.x = this.getX(e), r.y = this.getY(e), r.z = this.getZ(e), r.applyMatrix4(n), this.setXYZ(e, r.x, r.y, r.z); return this } applyNormalMatrix(n) { for (let e = 0, t = this.count; e < t; e++)r.x = this.getX(e), r.y = this.getY(e), r.z = this.getZ(e), r.applyNormalMatrix(n), this.setXYZ(e, r.x, r.y, r.z); return this } transformDirection(n) { for (let e = 0, t = this.count; e < t; e++)r.x = this.getX(e), r.y = this.getY(e), r.z = this.getZ(e), r.transformDirection(n), this.setXYZ(e, r.x, r.y, r.z); return this } set(e, t = 0) { return this.array.set(e, t), this } getX(e) { return this.array[e * this.itemSize] } setX(e, t) { return this.array[e * this.itemSize] = t, this } getY(e) { return this.array[e * this.itemSize + 1] } setY(e, t) { return this.array[e * this.itemSize + 1] = t, this } getZ(e) { return this.array[e * this.itemSize + 2] } setZ(e, t) { return this.array[e * this.itemSize + 2] = t, this } getW(e) { return this.array[e * this.itemSize + 3] } setW(e, t) { return this.array[e * this.itemSize + 3] = t, this } setXY(e, t, n) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this } setXYZ(e, t, n, r) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this } setXYZW(e, t, n, r, i) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this } onUpload(e) { return this.onUploadCallback = e, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized }; return "" !== this.name && (e.name = this.name), this.usage !== _e && (e.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange), e } } E.prototype.isBufferAttribute = !0; class yn extends E { constructor(e, t, n) { super(new Int8Array(e), t, n) } } class xn extends E { constructor(e, t, n) { super(new Uint8Array(e), t, n) } } class _n extends E { constructor(e, t, n) { super(new Uint8ClampedArray(e), t, n) } } class bn extends E { constructor(e, t, n) { super(new Int16Array(e), t, n) } } class Mn extends E { constructor(e, t, n) { super(new Uint16Array(e), t, n) } } class wn extends E { constructor(e, t, n) { super(new Int32Array(e), t, n) } } class Tn extends E { constructor(e, t, n) { super(new Uint32Array(e), t, n) } } class En extends E { constructor(e, t, n) { super(new Uint16Array(e), t, n) } } En.prototype.isFloat16BufferAttribute = !0; class V extends E { constructor(e, t, n) { super(new Float32Array(e), t, n) } } class Sn extends E { constructor(e, t, n) { super(new Float64Array(e), t, n) } } function An(n) { if (0 === n.length) return -1 / 0; let r = n[0]; for (let e = 1, t = n.length; e < t; ++e)n[e] > r && (r = n[e]); return r } const Rn = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: Uint8ClampedArray, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; function Ln(e, t) { return new Rn[e](t) } let Cn = 0; const Pn = new Ce, In = new u, Dn = new Le, Nn = new et, Hn = new et, c = new Le; class T extends we { constructor() { super(), Object.defineProperty(this, "id", { value: Cn++ }), this.uuid = Be(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(e) { return Array.isArray(e) ? this.index = new (65535 < An(e) ? Tn : Mn)(e, 1) : this.index = e, this } getAttribute(e) { return this.attributes[e] } setAttribute(e, t) { return this.attributes[e] = t, this } deleteAttribute(e) { return delete this.attributes[e], this } hasAttribute(e) { return void 0 !== this.attributes[e] } addGroup(e, t, n = 0) { this.groups.push({ start: e, count: t, materialIndex: n }) } clearGroups() { this.groups = [] } setDrawRange(e, t) { this.drawRange.start = e, this.drawRange.count = t } applyMatrix4(e) { const t = this.attributes.position, n = (void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0), this.attributes.normal); if (void 0 !== n) { const t = (new v).getNormalMatrix(e); n.applyNormalMatrix(t), n.needsUpdate = !0 } const r = this.attributes.tangent; return void 0 !== r && (r.transformDirection(e), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this } applyQuaternion(e) { return Pn.makeRotationFromQuaternion(e), this.applyMatrix4(Pn), this } rotateX(e) { return Pn.makeRotationX(e), this.applyMatrix4(Pn), this } rotateY(e) { return Pn.makeRotationY(e), this.applyMatrix4(Pn), this } rotateZ(e) { return Pn.makeRotationZ(e), this.applyMatrix4(Pn), this } translate(e, t, n) { return Pn.makeTranslation(e, t, n), this.applyMatrix4(Pn), this } scale(e, t, n) { return Pn.makeScale(e, t, n), this.applyMatrix4(Pn), this } lookAt(e) { return In.lookAt(e), In.updateMatrix(), this.applyMatrix4(In.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(Dn).negate(), this.translate(Dn.x, Dn.y, Dn.z), this } setFromPoints(n) { const r = []; for (let e = 0, t = n.length; e < t; e++) { var i = n[e]; r.push(i.x, i.y, i.z || 0) } return this.setAttribute("position", new V(r, 3)), this } computeBoundingBox() { null === this.boundingBox && (this.boundingBox = new et); var e = this.attributes.position, n = this.morphAttributes.position; if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Le(-1 / 0, -1 / 0, -1 / 0), new Le(1 / 0, 1 / 0, 1 / 0)); if (void 0 !== e) { if (this.boundingBox.setFromBufferAttribute(e), n) for (let e = 0, t = n.length; e < t; e++) { var r = n[e]; Nn.setFromBufferAttribute(r), this.morphTargetsRelative ? (c.addVectors(this.boundingBox.min, Nn.min), this.boundingBox.expandByPoint(c), c.addVectors(this.boundingBox.max, Nn.max), this.boundingBox.expandByPoint(c)) : (this.boundingBox.expandByPoint(Nn.min), this.boundingBox.expandByPoint(Nn.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { null === this.boundingSphere && (this.boundingSphere = new xt); var r = this.attributes.position, i = this.morphAttributes.position; if (r && r.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Le, 1 / 0); if (r) { const l = this.boundingSphere.center; if (Nn.setFromBufferAttribute(r), i) for (let e = 0, t = i.length; e < t; e++) { var a = i[e]; Hn.setFromBufferAttribute(a), this.morphTargetsRelative ? (c.addVectors(Nn.min, Hn.min), Nn.expandByPoint(c), c.addVectors(Nn.max, Hn.max), Nn.expandByPoint(c)) : (Nn.expandByPoint(Hn.min), Nn.expandByPoint(Hn.max)) } Nn.getCenter(l); let n = 0; for (let e = 0, t = r.count; e < t; e++)c.fromBufferAttribute(r, e), n = Math.max(n, l.distanceToSquared(c)); if (i) for (let e = 0, t = i.length; e < t; e++) { var s = i[e], o = this.morphTargetsRelative; for (let e = 0, t = s.count; e < t; e++)c.fromBufferAttribute(s, e), o && (Dn.fromBufferAttribute(r, e), c.add(Dn)), n = Math.max(n, l.distanceToSquared(c)) } this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeFaceNormals() { } computeTangents() { const e = this.index, r = this.attributes; if (null === e || void 0 === r.position || void 0 === r.normal || void 0 === r.uv) console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); else { const s = e.array, o = r.position.array, l = r.normal.array, c = r.uv.array, t = o.length / 3, h = (void 0 === r.tangent && this.setAttribute("tangent", new E(new Float32Array(4 * t), 4)), r.tangent.array), u = [], d = []; for (let e = 0; e < t; e++)u[e] = new Le, d[e] = new Le; const p = new Le, m = new Le, f = new Le, g = new k, v = new k, y = new k, x = new Le, _ = new Le; let n = this.groups; for (let e = 0, t = (n = 0 === n.length ? [{ start: 0, count: s.length }] : n).length; e < t; ++e) { const r = n[e], o = r.start; for (let e = o, t = o + r.count; e < t; e += 3)i(s[e + 0], s[e + 1], s[e + 2]) } const b = new Le, M = new Le, w = new Le, T = new Le; for (let e = 0, t = n.length; e < t; ++e) { const r = n[e], o = r.start; for (let e = o, t = o + r.count; e < t; e += 3)a(s[e + 0]), a(s[e + 1]), a(s[e + 2]) } function i(e, t, n) { p.fromArray(o, 3 * e), m.fromArray(o, 3 * t), f.fromArray(o, 3 * n), g.fromArray(c, 2 * e), v.fromArray(c, 2 * t), y.fromArray(c, 2 * n), m.sub(p), f.sub(p), v.sub(g), y.sub(g); var r = 1 / (v.x * y.y - y.x * v.y); isFinite(r) && (x.copy(m).multiplyScalar(y.y).addScaledVector(f, -v.y).multiplyScalar(r), _.copy(f).multiplyScalar(v.x).addScaledVector(m, -y.x).multiplyScalar(r), u[e].add(x), u[t].add(x), u[n].add(x), d[e].add(_), d[t].add(_), d[n].add(_)) } function a(e) { w.fromArray(l, 3 * e), T.copy(w); var t = u[e], t = (b.copy(t), b.sub(w.multiplyScalar(w.dot(t))).normalize(), M.crossVectors(T, t), M.dot(d[e]) < 0 ? -1 : 1); h[4 * e] = b.x, h[4 * e + 1] = b.y, h[4 * e + 2] = b.z, h[4 * e + 3] = t } } } computeVertexNormals() { const r = this.index, i = this.getAttribute("position"); if (void 0 !== i) { let n = this.getAttribute("normal"); if (void 0 === n) n = new E(new Float32Array(3 * i.count), 3), this.setAttribute("normal", n); else for (let e = 0, t = n.count; e < t; e++)n.setXYZ(e, 0, 0, 0); const l = new Le, c = new Le, h = new Le, u = new Le, d = new Le, p = new Le, m = new Le, f = new Le; if (r) for (let e = 0, t = r.count; e < t; e += 3) { var a = r.getX(e + 0), s = r.getX(e + 1), o = r.getX(e + 2); l.fromBufferAttribute(i, a), c.fromBufferAttribute(i, s), h.fromBufferAttribute(i, o), m.subVectors(h, c), f.subVectors(l, c), m.cross(f), u.fromBufferAttribute(n, a), d.fromBufferAttribute(n, s), p.fromBufferAttribute(n, o), u.add(m), d.add(m), p.add(m), n.setXYZ(a, u.x, u.y, u.z), n.setXYZ(s, d.x, d.y, d.z), n.setXYZ(o, p.x, p.y, p.z) } else for (let e = 0, t = i.count; e < t; e += 3)l.fromBufferAttribute(i, e + 0), c.fromBufferAttribute(i, e + 1), h.fromBufferAttribute(i, e + 2), m.subVectors(h, c), f.subVectors(l, c), m.cross(f), n.setXYZ(e + 0, m.x, m.y, m.z), n.setXYZ(e + 1, m.x, m.y, m.z), n.setXYZ(e + 2, m.x, m.y, m.z); this.normalizeNormals(), n.needsUpdate = !0 } } merge(e, t) { if (e && e.isBufferGeometry) { void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); var n = this.attributes; for (const r in n) if (void 0 !== e.attributes[r]) { const i = n[r].array, a = e.attributes[r], s = a.array, o = a.itemSize * t, l = Math.min(s.length, i.length - o); for (let e = 0, t = o; e < l; e++, t++)i[t] = s[e] } return this } console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e) } normalizeNormals() { const n = this.attributes.normal; for (let e = 0, t = n.count; e < t; e++)c.fromBufferAttribute(n, e), c.normalize(), n.setXYZ(e, c.x, c.y, c.z) } toNonIndexed() { function n(n, r) { const i = n.array, a = n.itemSize, e = n.normalized, s = new i.constructor(r.length * a); let o = 0, l = 0; for (let e = 0, t = r.length; e < t; e++) { o = n.isInterleavedBufferAttribute ? r[e] * n.data.stride + n.offset : r[e] * a; for (let e = 0; e < a; e++)s[l++] = i[o++] } return new E(s, a, e) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const r = new T, i = this.index.array, a = this.attributes; for (const e in a) { const s = n(a[e], i); r.setAttribute(e, s) } const e = this.morphAttributes; for (const a in e) { const s = [], o = e[a]; for (let e = 0, t = o.length; e < t; e++) { const a = n(o[e], i); s.push(a) } r.morphAttributes[a] = s } r.morphTargetsRelative = this.morphTargetsRelative; const s = this.groups; for (let e = 0, t = s.length; e < t; e++) { const i = s[e]; r.addGroup(i.start, i.count, i.materialIndex) } return r } toJSON() { const n = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), 0 < Object.keys(this.userData).length && (n.userData = this.userData), void 0 !== this.parameters) { const e = this.parameters; for (const r in e) void 0 !== e[r] && (n[r] = e[r]); return n } n.data = { attributes: {} }; const e = this.index, r = (null !== e && (n.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) }), this.attributes); for (const e in r) { const i = r[e]; n.data.attributes[e] = i.toJSON(n.data) } const i = {}; let t = !1; for (const e in this.morphAttributes) { const r = this.morphAttributes[e], a = []; for (let e = 0, t = r.length; e < t; e++) { const i = r[e]; a.push(i.toJSON(n.data)) } 0 < a.length && (i[e] = a, t = !0) } t && (n.data.morphAttributes = i, n.data.morphTargetsRelative = this.morphTargetsRelative); const a = this.groups, s = (0 < a.length && (n.data.groups = JSON.parse(JSON.stringify(a))), this.boundingSphere); return null !== s && (n.data.boundingSphere = { center: s.center.toArray(), radius: s.radius }), n } clone() { return (new T).copy(this) } copy(e) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const n = {}, r = (this.name = e.name, e.index), i = (null !== r && this.setIndex(r.clone(n)), e.attributes); for (const e in i) { const r = i[e]; this.setAttribute(e, r.clone(n)) } var t = e.morphAttributes; for (const e in t) { const r = [], i = t[e]; for (let e = 0, t = i.length; e < t; e++)r.push(i[e].clone(n)); this.morphAttributes[e] = r } this.morphTargetsRelative = e.morphTargetsRelative; var a = e.groups; for (let e = 0, t = a.length; e < t; e++) { const n = a[e]; this.addGroup(n.start, n.count, n.materialIndex) } const s = e.boundingBox, o = (null !== s && (this.boundingBox = s.clone()), e.boundingSphere); return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } T.prototype.isBufferGeometry = !0; const On = new Ce, Fn = new At, Bn = new xt, Un = new Le, zn = new Le, Gn = new Le, kn = new Le, Vn = new Le, Wn = new Le, jn = new Le, qn = new Le, Xn = new Le, Yn = new k, Zn = new k, Jn = new k, Kn = new Le, Qn = new Le; class S extends u { constructor(e = new T, t = new gn) { super(), this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e) { return super.copy(e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this } updateMorphTargets() { const n = this.geometry; if (n.isBufferGeometry) { var e = n.morphAttributes, t = Object.keys(e); if (0 < t.length) { const n = e[t[0]]; if (void 0 !== n) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, t = n.length; e < t; e++) { var r = n[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[r] = e } } } } else { e = n.morphTargets; void 0 !== e && 0 < e.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } } raycast(r, i) { const e = this.geometry, a = this.material, s = this.matrixWorld; if (void 0 !== a && (null === e.boundingSphere && e.computeBoundingSphere(), Bn.copy(e.boundingSphere), Bn.applyMatrix4(s), !1 !== r.ray.intersectsSphere(Bn) && (On.copy(s).invert(), Fn.copy(r.ray).applyMatrix4(On), null === e.boundingBox || !1 !== Fn.intersectsBox(e.boundingBox)))) { let n; if (e.isBufferGeometry) { const s = e.index, d = e.attributes.position, p = e.morphAttributes.position, m = e.morphTargetsRelative, f = e.attributes.uv, g = e.attributes.uv2, v = e.groups, y = e.drawRange; if (null !== s) if (Array.isArray(a)) for (let e = 0, t = v.length; e < t; e++) { var o = v[e], l = a[o.materialIndex]; for (let e = Math.max(o.start, y.start), t = Math.min(o.start + o.count, y.start + y.count); e < t; e += 3) { const a = s.getX(e), x = s.getX(e + 1), _ = s.getX(e + 2); (n = $n(this, l, r, Fn, d, p, m, f, g, a, x, _)) && (n.faceIndex = Math.floor(e / 3), n.face.materialIndex = o.materialIndex, i.push(n)) } } else for (let e = Math.max(0, y.start), t = Math.min(s.count, y.start + y.count); e < t; e += 3) { var c = s.getX(e), h = s.getX(e + 1), u = s.getX(e + 2); (n = $n(this, a, r, Fn, d, p, m, f, g, c, h, u)) && (n.faceIndex = Math.floor(e / 3), i.push(n)) } else if (void 0 !== d) if (Array.isArray(a)) for (let e = 0, t = v.length; e < t; e++) { const s = v[e], b = a[s.materialIndex]; for (let e = Math.max(s.start, y.start), t = Math.min(s.start + s.count, y.start + y.count); e < t; e += 3)(n = $n(this, b, r, Fn, d, p, m, f, g, e, e + 1, e + 2)) && (n.faceIndex = Math.floor(e / 3), n.face.materialIndex = s.materialIndex, i.push(n)) } else for (let e = Math.max(0, y.start), t = Math.min(d.count, y.start + y.count); e < t; e += 3)(n = $n(this, a, r, Fn, d, p, m, f, g, e, e + 1, e + 2)) && (n.faceIndex = Math.floor(e / 3), i.push(n)) } else e.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } } } function $n(e, n, r, t, i, a, s, o, l, c, h, u) { Un.fromBufferAttribute(i, c), zn.fromBufferAttribute(i, h), Gn.fromBufferAttribute(i, u); var d = e.morphTargetInfluences; if (a && d) { jn.set(0, 0, 0), qn.set(0, 0, 0), Xn.set(0, 0, 0); for (let e = 0, t = a.length; e < t; e++) { const n = d[e], r = a[e]; 0 !== n && (kn.fromBufferAttribute(r, c), Vn.fromBufferAttribute(r, h), Wn.fromBufferAttribute(r, u), s ? (jn.addScaledVector(kn, n), qn.addScaledVector(Vn, n), Xn.addScaledVector(Wn, n)) : (jn.addScaledVector(kn.sub(Un), n), qn.addScaledVector(Vn.sub(zn), n), Xn.addScaledVector(Wn.sub(Gn), n))) } Un.add(jn), zn.add(qn), Gn.add(Xn) } e.isSkinnedMesh && (e.boneTransform(c, Un), e.boneTransform(h, zn), e.boneTransform(u, Gn)); const p = function (e, t, n, r, i, a, s, o) { if (null === (1 === t.side ? r.intersectTriangle(s, a, i, !0, o) : r.intersectTriangle(i, a, s, 2 !== t.side, o))) return null; Qn.copy(o), Qn.applyMatrix4(e.matrixWorld); r = n.ray.origin.distanceTo(Qn); return r < n.near || r > n.far ? null : { distance: r, point: Qn.clone(), object: e } }(e, n, r, t, Un, zn, Gn, Kn); if (p) { o && (Yn.fromBufferAttribute(o, c), Zn.fromBufferAttribute(o, h), Jn.fromBufferAttribute(o, u), p.uv = g.getUV(Kn, Un, zn, Gn, Yn, Zn, Jn, new k)), l && (Yn.fromBufferAttribute(l, c), Zn.fromBufferAttribute(l, h), Jn.fromBufferAttribute(l, u), p.uv2 = g.getUV(Kn, Un, zn, Gn, Yn, Zn, Jn, new k)); const e = { a: c, b: h, c: u, normal: new Le, materialIndex: 0 }; g.getNormal(Un, zn, Gn, e.normal), p.face = e } return p } S.prototype.isMesh = !0; class er extends T { constructor(e = 1, t = 1, n = 1, r = 1, i = 1, a = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: n, widthSegments: r, heightSegments: i, depthSegments: a }; const b = this, M = (r = Math.floor(r), i = Math.floor(i), a = Math.floor(a), []), w = [], T = [], E = []; let S = 0, A = 0; function s(n, r, i, a, s, o, e, l, c, h, t) { var u = o / c, d = e / h, p = o / 2, m = e / 2, f = l / 2, g = c + 1, v = h + 1; let y = 0, x = 0; const _ = new Le; for (let t = 0; t < v; t++) { const b = t * d - m; for (let e = 0; e < g; e++) { const S = e * u - p; _[n] = S * a, _[r] = b * s, _[i] = f, w.push(_.x, _.y, _.z), _[n] = 0, _[r] = 0, _[i] = 0 < l ? 1 : -1, T.push(_.x, _.y, _.z), E.push(e / c), E.push(1 - t / h), y += 1 } } for (let t = 0; t < h; t++)for (let e = 0; e < c; e++) { const i = S + e + g * t, a = S + e + g * (t + 1), s = S + (e + 1) + g * (t + 1), o = S + (e + 1) + g * t; M.push(i, a, o), M.push(a, s, o), x += 6 } b.addGroup(A, x, t), A += x, S += y } s("z", "y", "x", -1, -1, n, t, e, a, i, 0), s("z", "y", "x", 1, -1, n, t, -e, a, i, 1), s("x", "z", "y", 1, 1, e, n, t, r, a, 2), s("x", "z", "y", 1, -1, e, n, -t, r, a, 3), s("x", "y", "z", 1, -1, e, t, n, r, i, 4), s("x", "y", "z", -1, -1, e, t, -n, r, i, 5), this.setIndex(M), this.setAttribute("position", new V(w, 3)), this.setAttribute("normal", new V(T, 3)), this.setAttribute("uv", new V(E, 2)) } static fromJSON(e) { return new er(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments) } } function tr(e) { const t = {}; for (const n in e) { t[n] = {}; for (const r in e[n]) { const i = e[n][r]; i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i } } return t } function n(t) { const n = {}; for (let e = 0; e < t.length; e++) { var r = tr(t[e]); for (const t in r) n[t] = r[t] } return n } const nr = { clone: tr, merge: n }; class rr extends t { constructor(e) { super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e)) } copy(e) { return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = tr(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this } toJSON(e) { const t = super.toJSON(e); t.glslVersion = this.glslVersion, t.uniforms = {}; for (const n in this.uniforms) { const r = this.uniforms[n].value; r && r.isTexture ? t.uniforms[n] = { type: "t", value: r.toJSON(e).uuid } : r && r.isColor ? t.uniforms[n] = { type: "c", value: r.getHex() } : r && r.isVector2 ? t.uniforms[n] = { type: "v2", value: r.toArray() } : r && r.isVector3 ? t.uniforms[n] = { type: "v3", value: r.toArray() } : r && r.isVector4 ? t.uniforms[n] = { type: "v4", value: r.toArray() } : r && r.isMatrix3 ? t.uniforms[n] = { type: "m3", value: r.toArray() } : r && r.isMatrix4 ? t.uniforms[n] = { type: "m4", value: r.toArray() } : t.uniforms[n] = { value: r } } 0 < Object.keys(this.defines).length && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader; const n = {}; for (const e in this.extensions) !0 === this.extensions[e] && (n[e] = !0); return 0 < Object.keys(n).length && (t.extensions = n), t } } rr.prototype.isShaderMaterial = !0; class ir extends u { constructor() { super(), this.type = "Camera", this.matrixWorldInverse = new Ce, this.projectionMatrix = new Ce, this.projectionMatrixInverse = new Ce } copy(e, t) { return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); var t = this.matrixWorld.elements; return e.set(-t[8], -t[9], -t[10]).normalize() } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(e, t) { super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return (new this.constructor).copy(this) } } ir.prototype.isCamera = !0; class C extends ir { constructor(e = 50, t = 1, n = .1, r = 2e3) { super(), this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this } setFocalLength(e) { e = .5 * this.getFilmHeight() / e; this.fov = 2 * Se * Math.atan(e), this.updateProjectionMatrix() } getFocalLength() { var e = Math.tan(.5 * Ee * this.fov); return .5 * this.getFilmHeight() / e } getEffectiveFOV() { return 2 * Se * Math.atan(Math.tan(.5 * Ee * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } setViewOffset(e, t, n, r, i, a) { this.aspect = e / t, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = this.near; let t = e * Math.tan(.5 * Ee * this.fov) / this.zoom, n = 2 * t, r = this.aspect * n, i = -.5 * r; var a = this.view; if (null !== this.view && this.view.enabled) { const e = a.fullWidth, s = a.fullHeight; i += a.offsetX * r / e, t -= a.offsetY * n / s, r *= a.width / e, n *= a.height / s } const s = this.filmOffset; 0 !== s && (i += e * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } } C.prototype.isPerspectiveCamera = !0; class ar extends u { constructor(e, t, n) { if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."); else { this.renderTarget = n; const r = new C(90, 1, e, t), i = (r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Le(1, 0, 0)), this.add(r), new C(90, 1, e, t)), a = (i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new Le(-1, 0, 0)), this.add(i), new C(90, 1, e, t)), s = (a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(new Le(0, 1, 0)), this.add(a), new C(90, 1, e, t)), o = (s.layers = this.layers, s.up.set(0, 0, -1), s.lookAt(new Le(0, -1, 0)), this.add(s), new C(90, 1, e, t)), l = (o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new Le(0, 0, 1)), this.add(o), new C(90, 1, e, t)); l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Le(0, 0, -1)), this.add(l) } } update(e, t) { null === this.parent && this.updateMatrixWorld(); const n = this.renderTarget, [r, i, a, s, o, l] = this.children, c = e.xr.enabled, h = e.getRenderTarget(); e.xr.enabled = !1; var u = n.texture.generateMipmaps; n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, r), e.setRenderTarget(n, 1), e.render(t, i), e.setRenderTarget(n, 2), e.render(t, a), e.setRenderTarget(n, 3), e.render(t, s), e.setRenderTarget(n, 4), e.render(t, o), n.texture.generateMipmaps = u, e.setRenderTarget(n, 5), e.render(t, l), e.setRenderTarget(h), e.xr.enabled = c } } class sr extends h { constructor(e, t, n, r, i, a, s, o, l, c) { super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : P, n, r, i, a, s = void 0 !== s ? s : J, o, l, c), this.flipY = !1 } get images() { return this.image } set images(e) { this.image = e } } sr.prototype.isCubeTexture = !0; class or extends Ze { constructor(e, t, n) { Number.isInteger(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), t = n), super(e, e, t), t = t || {}, this.texture = new sr(void 0, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : B, this.texture._needsFlipEnvMap = !1 } fromEquirectangularTexture(e, t) { this.texture.type = t.type, this.texture.format = Oe, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter; const n = { tEquirect: { value: null } }, r = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t", i = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t", a = new er(5, 5, 5), s = new rr({ name: "CubemapFromEquirect", uniforms: tr(n), vertexShader: r, fragmentShader: i, side: 1, blending: 0 }), o = (s.uniforms.tEquirect.value = t, new S(a, s)), l = t.minFilter; return t.minFilter === Ie && (t.minFilter = B), new ar(1, 10, this).update(e, o), t.minFilter = l, o.geometry.dispose(), o.material.dispose(), this } clear(t, n, r, i) { var e = t.getRenderTarget(); for (let e = 0; e < 6; e++)t.setRenderTarget(this, e), t.clear(n, r, i); t.setRenderTarget(e) } } or.prototype.isWebGLCubeRenderTarget = !0; const lr = new Le, cr = new Le, hr = new v; class ur { constructor(e = new Le(1, 0, 0), t = 0) { this.normal = e, this.constant = t } set(e, t) { return this.normal.copy(e), this.constant = t, this } setComponents(e, t, n, r) { return this.normal.set(e, t, n), this.constant = r, this } setFromNormalAndCoplanarPoint(e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this } setFromCoplanarPoints(e, t, n) { n = lr.subVectors(n, t).cross(cr.subVectors(e, t)).normalize(); return this.setFromNormalAndCoplanarPoint(n, e), this } copy(e) { return this.normal.copy(e.normal), this.constant = e.constant, this } normalize() { var e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(e) { return this.normal.dot(e) + this.constant } distanceToSphere(e) { return this.distanceToPoint(e.center) - e.radius } projectPoint(e, t) { return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e) } intersectLine(e, t) { var n = e.delta(lr), r = this.normal.dot(n); if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null; r = -(e.start.dot(this.normal) + this.constant) / r; return r < 0 || 1 < r ? null : t.copy(n).multiplyScalar(r).add(e.start) } intersectsLine(e) { var t = this.distanceToPoint(e.start), e = this.distanceToPoint(e.end); return t < 0 && 0 < e || e < 0 && 0 < t } intersectsBox(e) { return e.intersectsPlane(this) } intersectsSphere(e) { return e.intersectsPlane(this) } coplanarPoint(e) { return e.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(e, t) { const n = t || hr.getNormalMatrix(e), r = this.coplanarPoint(lr).applyMatrix4(e), i = this.normal.applyMatrix3(n).normalize(); return this.constant = -r.dot(i), this } translate(e) { return this.constant -= e.dot(this.normal), this } equals(e) { return e.normal.equals(this.normal) && e.constant === this.constant } clone() { return (new this.constructor).copy(this) } } ur.prototype.isPlane = !0; const dr = new xt, pr = new Le; class mr { constructor(e = new ur, t = new ur, n = new ur, r = new ur, i = new ur, a = new ur) { this.planes = [e, t, n, r, i, a] } set(e, t, n, r, i, a) { const s = this.planes; return s[0].copy(e), s[1].copy(t), s[2].copy(n), s[3].copy(r), s[4].copy(i), s[5].copy(a), this } copy(t) { const n = this.planes; for (let e = 0; e < 6; e++)n[e].copy(t.planes[e]); return this } setFromProjectionMatrix(e) { const t = this.planes, n = e.elements, r = n[0], i = n[1], a = n[2], s = n[3], o = n[4], l = n[5], c = n[6], h = n[7], u = n[8], d = n[9], p = n[10], m = n[11], f = n[12], g = n[13], v = n[14], y = n[15]; return t[0].setComponents(s - r, h - o, m - u, y - f).normalize(), t[1].setComponents(s + r, h + o, m + u, y + f).normalize(), t[2].setComponents(s + i, h + l, m + d, y + g).normalize(), t[3].setComponents(s - i, h - l, m - d, y - g).normalize(), t[4].setComponents(s - a, h - c, m - p, y - v).normalize(), t[5].setComponents(s + a, h + c, m + p, y + v).normalize(), this } intersectsObject(e) { const t = e.geometry; return null === t.boundingSphere && t.computeBoundingSphere(), dr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(dr) } intersectsSprite(e) { return dr.center.set(0, 0, 0), dr.radius = .7071067811865476, dr.applyMatrix4(e.matrixWorld), this.intersectsSphere(dr) } intersectsSphere(e) { const t = this.planes, n = e.center, r = -e.radius; for (let e = 0; e < 6; e++)if (t[e].distanceToPoint(n) < r) return !1; return !0 } intersectsBox(t) { var n = this.planes; for (let e = 0; e < 6; e++) { const r = n[e]; if (pr.x = (0 < r.normal.x ? t.max : t.min).x, pr.y = (0 < r.normal.y ? t.max : t.min).y, pr.z = (0 < r.normal.z ? t.max : t.min).z, r.distanceToPoint(pr) < 0) return !1 } return !0 } containsPoint(t) { const n = this.planes; for (let e = 0; e < 6; e++)if (n[e].distanceToPoint(t) < 0) return !1; return !0 } clone() { return (new this.constructor).copy(this) } } function fr() { let n = null, e = !1, r = null, i = null; function a(e, t) { r(e, t), i = n.requestAnimationFrame(a) } return { start: function () { !0 !== e && null !== r && (i = n.requestAnimationFrame(a), e = !0) }, stop: function () { n.cancelAnimationFrame(i), e = !1 }, setAnimationLoop: function (e) { r = e }, setContext: function (e) { n = e } } } function gr(o, e) { const l = e.isWebGL2, c = new WeakMap; return { get: function (e) { return e.isInterleavedBufferAttribute && (e = e.data), c.get(e) }, remove: function (e) { e.isInterleavedBufferAttribute && (e = e.data); var t = c.get(e); t && (o.deleteBuffer(t.buffer), c.delete(e)) }, update: function (e, t) { if (e.isGLBufferAttribute) { const o = c.get(e); void ((!o || o.version < e.version) && c.set(e, { buffer: e.buffer, type: e.type, bytesPerElement: e.elementSize, version: e.version })) } else { e.isInterleavedBufferAttribute && (e = e.data); const i = c.get(e); if (void 0 === i) c.set(e, function (e, t) { var n = e.array, r = e.usage, i = o.createBuffer(); o.bindBuffer(t, i), o.bufferData(t, n, r), e.onUploadCallback(); let a = 5126; return n instanceof Float32Array ? a = 5126 : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? e.isFloat16BufferAttribute ? l ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : n instanceof Int16Array ? a = 5122 : n instanceof Uint32Array ? a = 5125 : n instanceof Int32Array ? a = 5124 : n instanceof Int8Array ? a = 5120 : (n instanceof Uint8Array || n instanceof Uint8ClampedArray) && (a = 5121), { buffer: i, type: a, bytesPerElement: n.BYTES_PER_ELEMENT, version: e.version } }(e, t)); else if (i.version < e.version) { { var n = i.buffer, r = e; const a = r.array, s = r.updateRange; o.bindBuffer(t, n), -1 === s.count ? o.bufferSubData(t, 0, a) : (l ? o.bufferSubData(t, s.offset * a.BYTES_PER_ELEMENT, a, s.offset, s.count) : o.bufferSubData(t, s.offset * a.BYTES_PER_ELEMENT, a.subarray(s.offset, s.offset + s.count)), s.count = -1) } i.version = e.version } } } } } class vr extends T { constructor(e = 1, n = 1, r = 1, i = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: n, widthSegments: r, heightSegments: i }; const a = e / 2, s = n / 2, o = Math.floor(r), l = Math.floor(i), c = o + 1, h = l + 1, u = e / o, d = n / l, p = [], m = [], f = [], g = []; for (let t = 0; t < h; t++) { const n = t * d - s; for (let e = 0; e < c; e++) { const i = e * u - a; m.push(i, -n, 0), f.push(0, 0, 1), g.push(e / o), g.push(1 - t / l) } } for (let t = 0; t < l; t++)for (let e = 0; e < o; e++) { const r = e + c * t, i = e + c * (t + 1), a = e + 1 + c * (t + 1), s = e + 1 + c * t; p.push(r, i, s), p.push(i, a, s) } this.setIndex(p), this.setAttribute("position", new V(m, 3)), this.setAttribute("normal", new V(f, 3)), this.setAttribute("uv", new V(g, 2)) } static fromJSON(e) { return new vr(e.width, e.height, e.widthSegments, e.heightSegments) } } const w = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in vec3 f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn ( f90 - f0 ) * fresnel + f0;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in vec3 f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, vec3( 1.0 ), dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\t#ifdef SPECULAR\n\t\tvec3 specularIntensityFactor = vec3( specularIntensity );\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularColorF90 = mix( specularIntensityFactor, vec3( 1.0 ), metalnessFactor );\n\t#else\n\t\tvec3 specularIntensityFactor = vec3( 1.0 );\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularColorF90 = vec3( 1.0 );\n\t#endif\n\tmaterial.specularColor = mix( min( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularColorF90 = vec3( 1.0 );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n\tvec3 specularColorF90;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(\t\t0, 1,\t\t0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), vec3( 1.0 ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularColorF90, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(\t1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,\t1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,\t1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t\t#ifdef USE_TANGENT\n\t\t\tvTangent = normalize( transformedTangent );\n\t\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t\t#endif\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" }, A = { common: { diffuse: { value: new y(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new v }, uv2Transform: { value: new v }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new k(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new y(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new y(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new v } }, sprite: { diffuse: { value: new y(16777215) }, opacity: { value: 1 }, center: { value: new k(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new v } } }, yr = { basic: { uniforms: n([A.common, A.specularmap, A.envmap, A.aomap, A.lightmap, A.fog]), vertexShader: w.meshbasic_vert, fragmentShader: w.meshbasic_frag }, lambert: { uniforms: n([A.common, A.specularmap, A.envmap, A.aomap, A.lightmap, A.emissivemap, A.fog, A.lights, { emissive: { value: new y(0) } }]), vertexShader: w.meshlambert_vert, fragmentShader: w.meshlambert_frag }, phong: { uniforms: n([A.common, A.specularmap, A.envmap, A.aomap, A.lightmap, A.emissivemap, A.bumpmap, A.normalmap, A.displacementmap, A.fog, A.lights, { emissive: { value: new y(0) }, specular: { value: new y(1118481) }, shininess: { value: 30 } }]), vertexShader: w.meshphong_vert, fragmentShader: w.meshphong_frag }, standard: { uniforms: n([A.common, A.envmap, A.aomap, A.lightmap, A.emissivemap, A.bumpmap, A.normalmap, A.displacementmap, A.roughnessmap, A.metalnessmap, A.fog, A.lights, { emissive: { value: new y(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: w.meshphysical_vert, fragmentShader: w.meshphysical_frag }, toon: { uniforms: n([A.common, A.aomap, A.lightmap, A.emissivemap, A.bumpmap, A.normalmap, A.displacementmap, A.gradientmap, A.fog, A.lights, { emissive: { value: new y(0) } }]), vertexShader: w.meshtoon_vert, fragmentShader: w.meshtoon_frag }, matcap: { uniforms: n([A.common, A.bumpmap, A.normalmap, A.displacementmap, A.fog, { matcap: { value: null } }]), vertexShader: w.meshmatcap_vert, fragmentShader: w.meshmatcap_frag }, points: { uniforms: n([A.points, A.fog]), vertexShader: w.points_vert, fragmentShader: w.points_frag }, dashed: { uniforms: n([A.common, A.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: w.linedashed_vert, fragmentShader: w.linedashed_frag }, depth: { uniforms: n([A.common, A.displacementmap]), vertexShader: w.depth_vert, fragmentShader: w.depth_frag }, normal: { uniforms: n([A.common, A.bumpmap, A.normalmap, A.displacementmap, { opacity: { value: 1 } }]), vertexShader: w.normal_vert, fragmentShader: w.normal_frag }, sprite: { uniforms: n([A.sprite, A.fog]), vertexShader: w.sprite_vert, fragmentShader: w.sprite_frag }, background: { uniforms: { uvTransform: { value: new v }, t2D: { value: null } }, vertexShader: w.background_vert, fragmentShader: w.background_frag }, cube: { uniforms: n([A.envmap, { opacity: { value: 1 } }]), vertexShader: w.cube_vert, fragmentShader: w.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: w.equirect_vert, fragmentShader: w.equirect_frag }, distanceRGBA: { uniforms: n([A.common, A.displacementmap, { referencePosition: { value: new Le }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: w.distanceRGBA_vert, fragmentShader: w.distanceRGBA_frag }, shadow: { uniforms: n([A.lights, A.fog, { color: { value: new y(0) }, opacity: { value: 1 } }]), vertexShader: w.shadow_vert, fragmentShader: w.shadow_frag } }; function xr(s, o, n, l, r) { const c = new y(0); let h, u, d = 0, p = null, m = 0, f = null; function g(e, t) { n.buffers.color.setClear(e.r, e.g, e.b, t, r) } return { getClearColor: function () { return c }, setClearColor: function (e, t = 1) { c.set(e), d = t, g(c, d) }, getClearAlpha: function () { return d }, setClearAlpha: function (e) { d = e, g(c, d) }, render: function (e, t) { let n = !1, r = !0 === t.isScene ? t.background : null; r && r.isTexture && (r = o.get(r)); const i = s.xr, a = i.getSession && i.getSession(); null === (r = a && "additive" === a.environmentBlendMode ? null : r) ? g(c, d) : r && r.isColor && (g(r, 1), n = !0), (s.autoClear || n) && s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil), r && (r.isCubeTexture || r.mapping === H) ? (void 0 === u && ((u = new S(new er(1, 1, 1), new rr({ name: "BackgroundCubeMaterial", uniforms: tr(yr.cube.uniforms), vertexShader: yr.cube.vertexShader, fragmentShader: yr.cube.fragmentShader, side: 1, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function (e, t, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, Object.defineProperty(u.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), l.update(u)), u.material.uniforms.envMap.value = r, u.material.uniforms.flipEnvMap.value = r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1, p === r && m === r.version && f === s.toneMapping || (u.material.needsUpdate = !0, p = r, m = r.version, f = s.toneMapping), e.unshift(u, u.geometry, u.material, 0, 0, null)) : r && r.isTexture && (void 0 === h && ((h = new S(new vr(2, 2), new rr({ name: "BackgroundMaterial", uniforms: tr(yr.background.uniforms), vertexShader: yr.background.vertexShader, fragmentShader: yr.background.fragmentShader, side: 0, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), Object.defineProperty(h.material, "map", { get: function () { return this.uniforms.t2D.value } }), l.update(h)), !0 === (h.material.uniforms.t2D.value = r).matrixAutoUpdate && r.updateMatrix(), h.material.uniforms.uvTransform.value.copy(r.matrix), p === r && m === r.version && f === s.toneMapping || (h.material.needsUpdate = !0, p = r, m = r.version, f = s.toneMapping), e.unshift(h, h.geometry, h.material, 0, 0, null)) } } } function _r(x, _, b, M) { const i = x.getParameter(34921), w = M.isWebGL2 ? null : _.get("OES_vertex_array_object"), T = M.isWebGL2 || null !== w, E = {}, e = R(null); let S = e; function A(e) { M.isWebGL2 ? x.bindVertexArray(e) : w.bindVertexArrayOES(e) } function a(e) { M.isWebGL2 ? x.deleteVertexArray(e) : w.deleteVertexArrayOES(e) } function R(e) { const t = [], n = [], r = []; for (let e = 0; e < i; e++)t[e] = 0, n[e] = 0, r[e] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: t, enabledAttributes: n, attributeDivisors: r, object: e, attributes: {}, index: null } } function L() { const n = S.newAttributes; for (let e = 0, t = n.length; e < t; e++)n[e] = 0 } function C(e) { P(e, 0) } function P(e, t) { const n = S.newAttributes, r = S.enabledAttributes, i = S.attributeDivisors; n[e] = 1, 0 === r[e] && (x.enableVertexAttribArray(e), r[e] = 1), i[e] !== t && ((M.isWebGL2 ? x : _.get("ANGLE_instanced_arrays"))[M.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](e, t), i[e] = t) } function I() { const n = S.newAttributes, r = S.enabledAttributes; for (let e = 0, t = r.length; e < t; e++)r[e] !== n[e] && (x.disableVertexAttribArray(e), r[e] = 0) } function D(e, t, n, r, i, a) { !0 !== M.isWebGL2 || 5124 !== n && 5125 !== n ? x.vertexAttribPointer(e, t, n, r, i, a) : x.vertexAttribIPointer(e, t, n, i, a) } function s() { t(), S !== e && A((S = e).object) } function t() { e.geometry = null, e.program = null, e.wireframe = !1 } return { setup: function (e, s, t, n, r) { let i = !1; if (T) { const _ = function (e, t) { var n = !0 === s.wireframe; let r = E[e.id], i = (void 0 === r && (r = {}, E[e.id] = r), r[t.id]), a = (void 0 === i && (i = {}, r[t.id] = i), i[n]); return void 0 === a && (a = R(M.isWebGL2 ? x.createVertexArray() : w.createVertexArrayOES()), i[n] = a), a }(n, t); if (S !== _ && A((S = _).object), i = function (e, t) { var n = S.attributes, r = e.attributes; let i = 0; for (const e in r) { const t = n[e], a = r[e]; if (void 0 === t) return !0; if (t.attribute !== a) return !0; if (t.data !== a.data) return !0; i++ } return S.attributesNum !== i || S.index !== t }(n, r)) { var a = n; var o = r; const d = {}, p = a.attributes; let e = 0; for (const a in p) { const o = p[a], m = {}; (m.attribute = o).data && (m.data = o.data), d[a] = m, e++ } S.attributes = d, S.attributesNum = e, S.index = o } } else { const x = !0 === s.wireframe; S.geometry === n.id && S.program === t.id && S.wireframe === x || (S.geometry = n.id, S.program = t.id, S.wireframe = x, i = !0) } if (!0 === e.isInstancedMesh && (i = !0), null !== r && b.update(r, 34963), i) { var l = e, c = s, h = t, u = n; if (!1 !== M.isWebGL2 || !l.isInstancedMesh && !u.isInstancedBufferGeometry || null !== _.get("ANGLE_instanced_arrays")) { L(); const f = u.attributes, g = h.getAttributes(), v = c.defaultAttributeValues; for (const _ in g) { const M = g[_]; if (0 <= M) { const c = f[_]; if (void 0 !== c) { const _ = c.normalized, l = c.itemSize, h = b.get(c); if (void 0 !== h) { const f = h.buffer, g = h.type, v = h.bytesPerElement; if (c.isInterleavedBufferAttribute) { const b = c.data, h = b.stride, y = c.offset; b && b.isInstancedInterleavedBuffer ? (P(M, b.meshPerAttribute), void 0 === u._maxInstanceCount && (u._maxInstanceCount = b.meshPerAttribute * b.count)) : C(M), x.bindBuffer(34962, f), D(M, l, g, _, h * v, y * v) } else c.isInstancedBufferAttribute ? (P(M, c.meshPerAttribute), void 0 === u._maxInstanceCount && (u._maxInstanceCount = c.meshPerAttribute * c.count)) : C(M), x.bindBuffer(34962, f), D(M, l, g, _, 0, 0) } } else if ("instanceMatrix" === _) { const _ = b.get(l.instanceMatrix); if (void 0 !== _) { const c = _.buffer, h = _.type; P(M + 0, 1), P(M + 1, 1), P(M + 2, 1), P(M + 3, 1), x.bindBuffer(34962, c), x.vertexAttribPointer(M + 0, 4, h, !1, 64, 0), x.vertexAttribPointer(M + 1, 4, h, !1, 64, 16), x.vertexAttribPointer(M + 2, 4, h, !1, 64, 32), x.vertexAttribPointer(M + 3, 4, h, !1, 64, 48) } } else if ("instanceColor" === _) { const _ = b.get(l.instanceColor); if (void 0 !== _) { const c = _.buffer, h = _.type; P(M, 1), x.bindBuffer(34962, c), x.vertexAttribPointer(M, 3, h, !1, 12, 0) } } else if (void 0 !== v) { const b = v[_]; if (void 0 !== b) switch (b.length) { case 2: x.vertexAttrib2fv(M, b); break; case 3: x.vertexAttrib3fv(M, b); break; case 4: x.vertexAttrib4fv(M, b); break; default: x.vertexAttrib1fv(M, b) } } } } I() } null !== r && x.bindBuffer(34963, b.get(r).buffer) } }, reset: s, resetDefaultState: t, dispose: function () { s(); for (const e in E) { const t = E[e]; for (const n in t) { const r = t[n]; for (const i in r) a(r[i].object), delete r[i]; delete t[n] } delete E[e] } }, releaseStatesOfGeometry: function (e) { if (void 0 !== E[e.id]) { const t = E[e.id]; for (const e in t) { const n = t[e]; for (const e in n) a(n[e].object), delete n[e]; delete t[e] } delete E[e.id] } }, releaseStatesOfProgram: function (e) { for (const t in E) { const n = E[t]; if (void 0 !== n[e.id]) { const r = n[e.id]; for (const e in r) a(r[e].object), delete r[e]; delete n[e.id] } } }, initAttributes: L, enableAttribute: C, disableUnusedAttributes: I } } function br(a, s, o, e) { const l = e.isWebGL2; let c; this.setMode = function (e) { c = e }, this.render = function (e, t) { a.drawArrays(c, e, t), o.update(t, c, 1) }, this.renderInstances = function (n, r, i) { if (0 !== i) { let e, t; if (l) e = a, t = "drawArraysInstanced"; else if (e = s.get("ANGLE_instanced_arrays"), t = "drawArraysInstancedANGLE", null === e) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); e[t](c, n, r, i), o.update(r, c, i) } } } function Mr(t, n, e) { let r; function i(e) { if ("highp" === e) { if (0 < t.getShaderPrecisionFormat(35633, 36338).precision && 0 < t.getShaderPrecisionFormat(35632, 36338).precision) return "highp"; e = "mediump" } return "mediump" === e && 0 < t.getShaderPrecisionFormat(35633, 36337).precision && 0 < t.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp" } var a = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext; let s = void 0 !== e.precision ? e.precision : "highp"; var o = i(s), o = (o !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", o, "instead."), s = o), a || n.has("WEBGL_draw_buffers")), e = !0 === e.logarithmicDepthBuffer, l = t.getParameter(34930), c = t.getParameter(35660), h = t.getParameter(3379), u = t.getParameter(34076), d = t.getParameter(34921), p = t.getParameter(36347), m = t.getParameter(36348), f = t.getParameter(36349), g = 0 < c, v = a || n.has("OES_texture_float"); return { isWebGL2: a, drawBuffers: o, getMaxAnisotropy: function () { return void 0 !== r ? r : r = !0 === n.has("EXT_texture_filter_anisotropic") ? (e = n.get("EXT_texture_filter_anisotropic"), t.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT)) : 0; var e }, getMaxPrecision: i, precision: s, logarithmicDepthBuffer: e, maxTextures: l, maxVertexTextures: c, maxTextureSize: h, maxCubemapSize: u, maxAttributes: d, maxVertexUniforms: p, maxVaryings: m, maxFragmentUniforms: f, vertexTextures: g, floatFragmentTextures: v, floatVertexTextures: g && v, maxSamples: a ? t.getParameter(36183) : 0 } } function wr(o) { const t = this; let l = null, c = 0, h = !1, u = !1; const d = new ur, p = new v, m = { value: null, needsUpdate: !1 }; function f() { m.value !== l && (m.value = l, m.needsUpdate = 0 < c), t.numPlanes = c, t.numIntersection = 0 } function g(n, e, r, i) { var a = null !== n ? n.length : 0; let s = null; if (0 !== a) { if (s = m.value, !0 !== i || null === s) { const t = r + 4 * a, i = e.matrixWorldInverse; p.getNormalMatrix(i), (null === s || s.length < t) && (s = new Float32Array(t)); for (let e = 0, t = r; e !== a; ++e, t += 4)d.copy(n[e]).applyMatrix4(i, p), d.normal.toArray(s, t), s[t + 3] = d.constant } m.value = s, m.needsUpdate = !0 } return t.numPlanes = a, t.numIntersection = 0, s } this.uniform = m, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t, n) { var r = 0 !== e.length || t || 0 !== c || h; return h = t, l = g(e, n, 0), c = e.length, r }, this.beginShadows = function () { u = !0, g(null) }, this.endShadows = function () { u = !1, f() }, this.setState = function (n, e, r) { const i = n.clippingPlanes, a = n.clipIntersection, t = n.clipShadows, s = o.get(n); if (!h || null === i || 0 === i.length || u && !t) u ? g(null) : f(); else { const o = u ? 0 : c, n = 4 * o; let t = s.clippingState || null; m.value = t, t = g(i, e, n, r); for (let e = 0; e !== n; ++e)t[e] = l[e]; s.clippingState = t, this.numIntersection = a ? this.numPlanes : 0, this.numPlanes += o } } } function Tr(n) { let r = new WeakMap; function i(e, t) { return t === D ? e.mapping = P : t === N && (e.mapping = I), e } function a(e) { const t = e.target, n = (t.removeEventListener("dispose", a), r.get(t)); void 0 !== n && (r.delete(t), n.dispose()) } return { get: function (e) { if (e && e.isTexture && !1 === e.isRenderTargetTexture) { var t = e.mapping; if (t === D || t === N) { if (r.has(e)) return i(r.get(e).texture, e.mapping); t = e.image; if (t && 0 < t.height) { const D = n.getRenderTarget(), N = new or(t.height / 2); return N.fromEquirectangularTexture(n, e), r.set(e, N), n.setRenderTarget(D), e.addEventListener("dispose", a), i(N.texture, e.mapping) } return null } } return e }, dispose: function () { r = new WeakMap } } } yr.physical = { uniforms: n([yr.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new k(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new y(0) }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new k }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationTint: { value: new y(0) }, specularIntensity: { value: 0 }, specularIntensityMap: { value: null }, specularTint: { value: new y(1, 1, 1) }, specularTintMap: { value: null } }]), vertexShader: w.meshphysical_vert, fragmentShader: w.meshphysical_frag }; class Er extends ir { constructor(e = -1, t = 1, n = 1, r = -1, i = .1, a = 2e3) { super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = i, this.far = a, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this } setViewOffset(e, t, n, r, i, a) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2; let i = n - e, a = n + e, s = r + t, o = r - t; if (null !== this.view && this.view.enabled) { const e = (this.right - this.left) / this.view.fullWidth / this.zoom, t = (this.top - this.bottom) / this.view.fullHeight / this.zoom; i += e * this.view.offsetX, a = i + e * this.view.width, s -= t * this.view.offsetY, o = s - t * this.view.height } this.projectionMatrix.makeOrthographic(i, a, s, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t } } Er.prototype.isOrthographicCamera = !0; class Sr extends rr { constructor(e) { super(e), this.type = "RawShaderMaterial" } } Sr.prototype.isRawShaderMaterial = !0; const Ar = Math.pow(2, 8), Rr = [.125, .215, .35, .446, .526, .582], Lr = 5 + Rr.length, Cr = { [Fe]: 0, 3001: 1, 3002: 2, 3004: 3, 3005: 4, 3006: 5, 3007: 6 }, Pr = new gn({ side: 1, depthWrite: !1, depthTest: !1 }), Ir = new S(new er, Pr), Dr = new Er, { _lodPlanes: Nr, _sizeLods: Hr, _sigmas: Or } = function () { const n = [], r = [], i = []; let a = 8; for (let t = 0; t < Lr; t++) { var s = Math.pow(2, a); r.push(s); let e = 1 / s; 4 < t ? e = Rr[t - 8 + 4 - 1] : 0 == t && (e = 0), i.push(e); const l = 1 / (s - 1), c = -l / 2, h = 1 + l / 2, u = [c, c, h, c, h, h, c, c, h, h, c, h], d = new Float32Array(108), p = new Float32Array(72), m = new Float32Array(36); for (let e = 0; e < 6; e++) { const r = e % 3 * 2 / 3 - 1, i = 2 < e ? 0 : -1, a = [r, i, 0, r + 2 / 3, i, 0, r + 2 / 3, 1 + i, 0, r, i, 0, r + 2 / 3, 1 + i, 0, r, 1 + i, 0]; d.set(a, 18 * e), p.set(u, 12 * e); var o = [e, e, e, e, e, e]; m.set(o, 6 * e) } const f = new T; f.setAttribute("position", new E(d, 3)), f.setAttribute("uv", new E(p, 2)), f.setAttribute("faceIndex", new E(m, 1)), n.push(f), 4 < a && a-- } return { _lodPlanes: n, _sizeLods: r, _sigmas: i } }(), Fr = new y; let Br = null; const Ur = (1 + Math.sqrt(5)) / 2, zr = 1 / Ur, Gr = [new Le(1, 1, 1), new Le(-1, 1, 1), new Le(1, 1, -1), new Le(-1, 1, -1), new Le(0, Ur, zr), new Le(0, Ur, -zr), new Le(zr, 0, Ur), new Le(-zr, 0, Ur), new Le(Ur, zr, 0), new Le(-Ur, zr, 0)]; function kr(e) { var t = Math.max(e.r, e.g, e.b), t = Math.min(Math.max(Math.ceil(Math.log2(t)), -128), 127); return e.multiplyScalar(Math.pow(2, -t)), (t + 128) / 255 } class Vr {
        constructor(e) {
            var t; this._renderer = e, this._pingPongRenderTarget = null, this._blurMaterial = (e = new Float32Array(20), t = new Le(0, 1, 0), new Sr({
                name: "SphericalGaussianBlur", defines: { n: 20 }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: e }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: t }, inputEncoding: { value: Cr[3e3] }, outputEncoding: { value: Cr[3e3] } }, vertexShader: Yr(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${Zr()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: 0, depthTest: !1, depthWrite: !1
            })), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
        } fromScene(e, t = 0, n = .1, r = 100) { Br = this._renderer.getRenderTarget(); var i = this._allocateTargets(); return this._sceneToCubeUV(e, n, r, i), 0 < t && this._blur(i, 0, 0, t), this._applyPMREM(i), this._cleanup(i), i } fromEquirectangular(e) { return this._fromTexture(e) } fromCubemap(e) { return this._fromTexture(e) } compileCubemapShader() { null === this._cubemapShader && (this._cubemapShader = Xr(), this._compileMaterial(this._cubemapShader)) } compileEquirectangularShader() { null === this._equirectShader && (this._equirectShader = qr(), this._compileMaterial(this._equirectShader)) } dispose() { this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose(); for (let e = 0; e < Nr.length; e++)Nr[e].dispose() } _cleanup(e) { this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(Br), e.scissorTest = !1, jr(e, 0, 0, e.width, e.height) } _fromTexture(e) { Br = this._renderer.getRenderTarget(); var t = this._allocateTargets(e); return this._textureToCubeUV(e, t), this._applyPMREM(t), this._cleanup(t), t } _allocateTargets(e) { const t = { magFilter: Ae, minFilter: Ae, generateMipmaps: !1, type: De, format: 1023, encoding: void 0 === (r = e) || r.type !== De || r.encoding !== Fe && r.encoding !== ge && r.encoding !== ve ? ye : e.encoding, depthBuffer: !1 }, n = Wr(t); var r; return n.depthBuffer = !e, this._pingPongRenderTarget = Wr(t), n } _compileMaterial(e) { e = new S(Nr[0], e); this._renderer.compile(e, Dr) } _sceneToCubeUV(t, e, n, r) { const i = new C(90, 1, e, n), a = [1, -1, 1, 1, 1, 1], s = [1, 1, 1, -1, -1, -1], o = this._renderer, l = o.autoClear, c = o.outputEncoding, h = o.toneMapping; o.getClearColor(Fr), o.toneMapping = 0, o.outputEncoding = Fe; let u = o.autoClear = !1; n = t.background; if (n) { if (n.isColor) { Pr.color.copy(n).convertSRGBToLinear(), t.background = null; const e = kr(Pr.color); Pr.opacity = e, u = !0 } } else { Pr.color.copy(Fr).convertSRGBToLinear(); const t = kr(Pr.color); Pr.opacity = t, u = !0 } for (let e = 0; e < 6; e++) { const n = e % 3; 0 == n ? (i.up.set(0, a[e], 0), i.lookAt(s[e], 0, 0)) : 1 == n ? (i.up.set(0, 0, a[e]), i.lookAt(0, s[e], 0)) : (i.up.set(0, a[e], 0), i.lookAt(0, 0, s[e])), jr(r, n * Ar, 2 < e ? Ar : 0, Ar, Ar), o.setRenderTarget(r), u && o.render(Ir, i), o.render(t, i) } o.toneMapping = h, o.outputEncoding = c, o.autoClear = l } _textureToCubeUV(e, t) { const n = this._renderer, r = (e.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Xr()) : null == this._equirectShader && (this._equirectShader = qr()), e.isCubeTexture ? this._cubemapShader : this._equirectShader), i = new S(Nr[0], r), a = r.uniforms; (a.envMap.value = e).isCubeTexture || a.texelSize.value.set(1 / e.image.width, 1 / e.image.height), a.inputEncoding.value = Cr[e.encoding], a.outputEncoding.value = Cr[t.texture.encoding], jr(t, 0, 0, 3 * Ar, 2 * Ar), n.setRenderTarget(t), n.render(i, Dr) } _applyPMREM(t) { const e = this._renderer, n = e.autoClear; e.autoClear = !1; for (let e = 1; e < Lr; e++) { const n = Math.sqrt(Or[e] * Or[e] - Or[e - 1] * Or[e - 1]), r = Gr[(e - 1) % Gr.length]; this._blur(t, e - 1, e, n, r) } e.autoClear = n } _blur(e, t, n, r, i) { var a = this._pingPongRenderTarget; this._halfBlur(e, a, t, n, r, "latitudinal", i), this._halfBlur(a, e, n, n, r, "longitudinal", i) } _halfBlur(e, t, n, r, i, a, s) { const o = this._renderer, l = this._blurMaterial, c = ("latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!"), new S(Nr[r], l)), h = l.uniforms, u = Hr[n] - 1, d = isFinite(i) ? Math.PI / (2 * u) : 2 * Math.PI / 39, p = i / d, m = isFinite(i) ? 1 + Math.floor(3 * p) : 20, f = (20 < m && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`), []); let g = 0; for (let e = 0; e < 20; ++e) { const t = e / p, n = Math.exp(-t * t / 2); f.push(n), 0 == e ? g += n : e < m && (g += 2 * n) } for (let e = 0; e < f.length; e++)f[e] = f[e] / g; h.envMap.value = e.texture, h.samples.value = m, h.weights.value = f, h.latitudinal.value = "latitudinal" === a, s && (h.poleAxis.value = s), h.dTheta.value = d, h.mipInt.value = 8 - n, h.inputEncoding.value = Cr[e.texture.encoding], h.outputEncoding.value = Cr[e.texture.encoding]; i = Hr[r]; jr(t, 3 * Math.max(0, Ar - 2 * i), (0 === r ? 0 : 2 * Ar) + 2 * i * (4 < r ? r - 8 + 4 : 0), 3 * i, 2 * i), o.setRenderTarget(t), o.render(c, Dr) }
    } function Wr(e) { const t = new Ze(3 * Ar, 3 * Ar, e); return t.texture.mapping = H, t.texture.name = "PMREM.cubeUv", t.scissorTest = !0, t } function jr(e, t, n, r, i) { e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i) } function qr() {
        var e = new k(1, 1); return new Sr({
            name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null }, texelSize: { value: e }, inputEncoding: { value: Cr[3e3] }, outputEncoding: { value: Cr[3e3] } }, vertexShader: Yr(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${Zr()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: 0, depthTest: !1, depthWrite: !1
        })
    } function Xr() {
        return new Sr({
            name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, inputEncoding: { value: Cr[3e3] }, outputEncoding: { value: Cr[3e3] } }, vertexShader: Yr(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${Zr()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: 0, depthTest: !1, depthWrite: !1
        })
    } function Yr() { return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t" } function Zr() { return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t" } function Jr(r) { let i = new WeakMap, a = null; function s(e) { const t = e.target, n = (t.removeEventListener("dispose", s), i.get(t)); void 0 !== n && (n.delete(t), n.dispose()) } return { get: function (e) { if (e && e.isTexture && !1 === e.isRenderTargetTexture) { var t = e.mapping, n = t === D || t === N, t = t === P || t === I; if (n || t) { if (i.has(e)) return i.get(e).texture; { const P = e.image; if (n && P && 0 < P.height || t && P && function (t) { let n = 0; for (let e = 0; e < 6; e++)void 0 !== t[e] && n++; return 6 === n }(P)) { const P = r.getRenderTarget(), I = (null === a && (a = new Vr(r)), n ? a.fromEquirectangular(e) : a.fromCubemap(e)); return i.set(e, I), r.setRenderTarget(P), e.addEventListener("dispose", s), I.texture } return null } } } return e }, dispose: function () { i = new WeakMap, null !== a && (a.dispose(), a = null) } } } function Kr(n) { const r = {}; function i(e) { if (void 0 !== r[e]) return r[e]; let t; switch (e) { case "WEBGL_depth_texture": t = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": t = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": t = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": t = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: t = n.getExtension(e) }return r[e] = t } return { has: function (e) { return null !== i(e) }, init: function (e) { e.isWebGL2 ? i("EXT_color_buffer_float") : (i("WEBGL_depth_texture"), i("OES_texture_float"), i("OES_texture_half_float"), i("OES_texture_half_float_linear"), i("OES_standard_derivatives"), i("OES_element_index_uint"), i("OES_vertex_array_object"), i("ANGLE_instanced_arrays")), i("OES_texture_float_linear"), i("EXT_color_buffer_half_float") }, get: function (e) { var t = i(e); return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t } } } function Qr(e, o, n, r) { const i = {}, l = new WeakMap; function a(e) { const t = e.target; null !== t.index && o.remove(t.index); for (const e in t.attributes) o.remove(t.attributes[e]); t.removeEventListener("dispose", a), delete i[t.id]; e = l.get(t); e && (o.remove(e), l.delete(t)), r.releaseStatesOfGeometry(t), !0 === t.isInstancedBufferGeometry && delete t._maxInstanceCount, n.memory.geometries-- } function s(n) { const r = [], i = n.index, a = n.attributes.position; let e = 0; if (null !== i) { const n = i.array; e = i.version; for (let e = 0, t = n.length; e < t; e += 3) { const i = n[e + 0], a = n[e + 1], l = n[e + 2]; r.push(i, a, a, l, l, i) } } else { const n = a.array; e = a.version; for (let e = 0, t = n.length / 3 - 1; e < t; e += 3) { const n = e + 0, i = e + 1, a = e + 2; r.push(n, i, i, a, a, n) } } const t = new (65535 < An(r) ? Tn : Mn)(r, 1); t.version = e; var s = l.get(n); s && o.remove(s), l.set(n, t) } return { get: function (e, t) { return !0 !== i[t.id] && (t.addEventListener("dispose", a), i[t.id] = !0, n.memory.geometries++), t }, update: function (e) { const n = e.attributes; for (const e in n) o.update(n[e], 34962); var t = e.morphAttributes; for (const e in t) { const n = t[e]; for (let e = 0, t = n.length; e < t; e++)o.update(n[e], 34962) } }, getWireframeAttribute: function (e) { var t, n = l.get(e); return (!n || null !== (t = e.index) && n.version < t.version) && s(e), l.get(e) } } } function $r(a, s, o, e) { const l = e.isWebGL2; let c, h, u; this.setMode = function (e) { c = e }, this.setIndex = function (e) { h = e.type, u = e.bytesPerElement }, this.render = function (e, t) { a.drawElements(c, t, h, e * u), o.update(t, c, 1) }, this.renderInstances = function (n, r, i) { if (0 !== i) { let e, t; if (l) e = a, t = "drawElementsInstanced"; else if (e = s.get("ANGLE_instanced_arrays"), t = "drawElementsInstancedANGLE", null === e) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); e[t](c, r, h, n * u, i), o.update(r, c, i) } } } function ei(e) { const r = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: r, programs: null, autoReset: !0, reset: function () { r.frame++, r.calls = 0, r.triangles = 0, r.points = 0, r.lines = 0 }, update: function (e, t, n) { switch (r.calls++, t) { case 4: r.triangles += n * (e / 3); break; case 1: r.lines += n * (e / 2); break; case 3: r.lines += n * (e - 1); break; case 2: r.lines += n * e; break; case 0: r.points += n * e; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", t) } } } } function ti(e, t) { return e[0] - t[0] } function ni(e, t) { return Math.abs(t[1]) - Math.abs(e[1]) } function ri(h) { const u = {}, d = new Float32Array(8), p = []; for (let e = 0; e < 8; e++)p[e] = [e, 0]; return { update: function (t, n, r, e) { var i = t.morphTargetInfluences, a = void 0 === i ? 0 : i.length; let s = u[n.id]; if (void 0 === s || s.length !== a) { s = []; for (let e = 0; e < a; e++)s[e] = [e, 0]; u[n.id] = s } for (let e = 0; e < a; e++) { const u = s[e]; u[0] = e, u[1] = i[e] } s.sort(ni); for (let e = 0; e < 8; e++)e < a && s[e][1] ? (p[e][0] = s[e][0], p[e][1] = s[e][1]) : (p[e][0] = Number.MAX_SAFE_INTEGER, p[e][1] = 0); p.sort(ti); var o = n.morphAttributes.position, l = n.morphAttributes.normal; let c = 0; for (let e = 0; e < 8; e++) { const u = p[e], t = u[0], r = u[1]; t !== Number.MAX_SAFE_INTEGER && r ? (o && n.getAttribute("morphTarget" + e) !== o[t] && n.setAttribute("morphTarget" + e, o[t]), l && n.getAttribute("morphNormal" + e) !== l[t] && n.setAttribute("morphNormal" + e, l[t]), d[e] = r, c += r) : (o && !0 === n.hasAttribute("morphTarget" + e) && n.deleteAttribute("morphTarget" + e), l && !0 === n.hasAttribute("morphNormal" + e) && n.deleteAttribute("morphNormal" + e), d[e] = 0) } t = n.morphTargetsRelative ? 1 : 1 - c; e.getUniforms().setValue(h, "morphTargetBaseInfluence", t), e.getUniforms().setValue(h, "morphTargetInfluences", d) } } } function ii(e, r, i, a) { let s = new WeakMap; function o(e) { const t = e.target; t.removeEventListener("dispose", o), i.remove(t.instanceMatrix), null !== t.instanceColor && i.remove(t.instanceColor) } return { update: function (e) { var t = a.render.frame, n = e.geometry, n = r.get(e, n); return s.get(n) !== t && (r.update(n), s.set(n, t)), e.isInstancedMesh && (!1 === e.hasEventListener("dispose", o) && e.addEventListener("dispose", o), i.update(e.instanceMatrix, 34962), null !== e.instanceColor && i.update(e.instanceColor, 34962)), n }, dispose: function () { s = new WeakMap } } } class ai extends h { constructor(e = null, t = 1, n = 1, r = 1) { super(null), this.image = { data: e, width: t, height: n, depth: r }, this.magFilter = Ae, this.minFilter = Ae, this.wrapR = Pe, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } } class si extends h { constructor(e = null, t = 1, n = 1, r = 1) { super(null), this.image = { data: e, width: t, height: n, depth: r }, this.magFilter = Ae, this.minFilter = Ae, this.wrapR = Pe, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } } si.prototype.isDataTexture3D = ai.prototype.isDataTexture2DArray = !0; const oi = new h, li = new ai, ci = new si, hi = new sr, ui = [], di = [], pi = new Float32Array(16), mi = new Float32Array(9), fi = new Float32Array(4); function gi(n, r, i) { const e = n[0]; if (e <= 0 || 0 < e) return n; var t = r * i; let a = ui[t]; if (void 0 === a && (a = new Float32Array(t), ui[t] = a), 0 !== r) { e.toArray(a, 0); for (let e = 1, t = 0; e !== r; ++e)t += i, n[e].toArray(a, t) } return a } function vi(n, r) { if (n.length === r.length) { for (let e = 0, t = n.length; e < t; e++)if (n[e] !== r[e]) return; return 1 } } function a(n, r) { for (let e = 0, t = r.length; e < t; e++)n[e] = r[e] } function yi(t, n) { let r = di[n]; void 0 === r && (r = new Int32Array(n), di[n] = r); for (let e = 0; e !== n; ++e)r[e] = t.allocateTextureUnit(); return r } function xi(e, t) { const n = this.cache; n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t) } function _i(e, t) { const n = this.cache; void 0 !== t.x ? n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y) : vi(n, t) || (e.uniform2fv(this.addr, t), a(n, t)) } function bi(e, t) { const n = this.cache; void 0 !== t.x ? n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z) : void 0 !== t.r ? n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b) : vi(n, t) || (e.uniform3fv(this.addr, t), a(n, t)) } function Mi(e, t) { const n = this.cache; void 0 !== t.x ? n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w) : vi(n, t) || (e.uniform4fv(this.addr, t), a(n, t)) } function wi(e, t) { var n = this.cache, r = t.elements; void 0 === r ? vi(n, t) || (e.uniformMatrix2fv(this.addr, !1, t), a(n, t)) : vi(n, r) || (fi.set(r), e.uniformMatrix2fv(this.addr, !1, fi), a(n, r)) } function Ti(e, t) { var n = this.cache, r = t.elements; void 0 === r ? vi(n, t) || (e.uniformMatrix3fv(this.addr, !1, t), a(n, t)) : vi(n, r) || (mi.set(r), e.uniformMatrix3fv(this.addr, !1, mi), a(n, r)) } function Ei(e, t) { var n = this.cache, r = t.elements; void 0 === r ? vi(n, t) || (e.uniformMatrix4fv(this.addr, !1, t), a(n, t)) : vi(n, r) || (pi.set(r), e.uniformMatrix4fv(this.addr, !1, pi), a(n, r)) } function Si(e, t) { const n = this.cache; n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t) } function Ai(e, t) { var n = this.cache; vi(n, t) || (e.uniform2iv(this.addr, t), a(n, t)) } function Ri(e, t) { var n = this.cache; vi(n, t) || (e.uniform3iv(this.addr, t), a(n, t)) } function Li(e, t) { var n = this.cache; vi(n, t) || (e.uniform4iv(this.addr, t), a(n, t)) } function Ci(e, t) { const n = this.cache; n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t) } function Pi(e, t) { var n = this.cache; vi(n, t) || (e.uniform2uiv(this.addr, t), a(n, t)) } function Ii(e, t) { var n = this.cache; vi(n, t) || (e.uniform3uiv(this.addr, t), a(n, t)) } function Di(e, t) { var n = this.cache; vi(n, t) || (e.uniform4uiv(this.addr, t), a(n, t)) } function Ni(e, t, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(t || oi, i) } function Hi(e, t, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || ci, i) } function Oi(e, t, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(t || hi, i) } function Fi(e, t, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(t || li, i) } function Bi(e, t) { e.uniform1fv(this.addr, t) } function Ui(e, t) { t = gi(t, this.size, 2); e.uniform2fv(this.addr, t) } function zi(e, t) { t = gi(t, this.size, 3); e.uniform3fv(this.addr, t) } function Gi(e, t) { t = gi(t, this.size, 4); e.uniform4fv(this.addr, t) } function ki(e, t) { t = gi(t, this.size, 4); e.uniformMatrix2fv(this.addr, !1, t) } function Vi(e, t) { t = gi(t, this.size, 9); e.uniformMatrix3fv(this.addr, !1, t) } function Wi(e, t) { t = gi(t, this.size, 16); e.uniformMatrix4fv(this.addr, !1, t) } function ji(e, t) { e.uniform1iv(this.addr, t) } function qi(e, t) { e.uniform2iv(this.addr, t) } function Xi(e, t) { e.uniform3iv(this.addr, t) } function Yi(e, t) { e.uniform4iv(this.addr, t) } function Zi(e, t) { e.uniform1uiv(this.addr, t) } function Ji(e, t) { e.uniform2uiv(this.addr, t) } function Ki(e, t) { e.uniform3uiv(this.addr, t) } function Qi(e, t) { e.uniform4uiv(this.addr, t) } function $i(e, t, n) { var r = t.length, i = yi(n, r); e.uniform1iv(this.addr, i); for (let e = 0; e !== r; ++e)n.safeSetTexture2D(t[e] || oi, i[e]) } function ea(e, t, n) { var r = t.length, i = yi(n, r); e.uniform1iv(this.addr, i); for (let e = 0; e !== r; ++e)n.safeSetTextureCube(t[e] || hi, i[e]) } function ta(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.setValue = function () { switch (t.type) { case 5126: return xi; case 35664: return _i; case 35665: return bi; case 35666: return Mi; case 35674: return wi; case 35675: return Ti; case 35676: return Ei; case 5124: case 35670: return Si; case 35667: case 35671: return Ai; case 35668: case 35672: return Ri; case 35669: case 35673: return Li; case 5125: return Ci; case 36294: return Pi; case 36295: return Ii; case 36296: return Di; case 35678: case 36198: case 36298: case 36306: case 35682: return Ni; case 35679: case 36299: case 36307: return Hi; case 35680: case 36300: case 36308: case 36293: return Oi; case 36289: case 36303: case 36311: case 36292: return Fi } }() } function na(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function () { switch (t.type) { case 5126: return Bi; case 35664: return Ui; case 35665: return zi; case 35666: return Gi; case 35674: return ki; case 35675: return Vi; case 35676: return Wi; case 5124: case 35670: return ji; case 35667: case 35671: return qi; case 35668: case 35672: return Xi; case 35669: case 35673: return Yi; case 5125: return Zi; case 36294: return Ji; case 36295: return Ki; case 36296: return Qi; case 35678: case 36198: case 36298: case 36306: case 35682: return $i; case 35680: case 36300: case 36308: case 36293: return ea } }() } function ra(e) { this.id = e, this.seq = [], this.map = {} } na.prototype.updateCache = function (e) { var t = this.cache; e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), a(t, e) }, ra.prototype.setValue = function (n, r, i) { var a = this.seq; for (let e = 0, t = a.length; e !== t; ++e) { const s = a[e]; s.setValue(n, r[s.id], i) } }; const ia = /(\w+)(\])?(\[|\.)?/g; function aa(e, t) { e.seq.push(t), e.map[t.id] = t } function sa(t, n) { this.seq = [], this.map = {}; const r = t.getProgramParameter(n, 35718); for (let e = 0; e < r; ++e) { const r = t.getActiveUniform(n, e); c = u = h = c = l = o = s = a = i = void 0; var i = r, a = t.getUniformLocation(n, r.name), s = this, o = i.name, l = o.length; for (ia.lastIndex = 0; ;) { var c = ia.exec(o), h = ia.lastIndex; let t = c[1]; var u = "]" === c[2], c = c[3]; if (u && (t |= 0), void 0 === c || "[" === c && h + 2 === l) { aa(s, new (void 0 === c ? ta : na)(t, i, a)); break } { let e = s.map[t]; void 0 === e && aa(s, e = new ra(t)), s = e } } } } function oa(e, t, n) { t = e.createShader(t); return e.shaderSource(t, n), e.compileShader(t), t } sa.prototype.setValue = function (e, t, n, r) { const i = this.map[t]; void 0 !== i && i.setValue(e, n, r) }, sa.prototype.setOptional = function (e, t, n) { t = t[n]; void 0 !== t && this.setValue(e, n, t) }, sa.upload = function (n, r, i, a) { for (let e = 0, t = r.length; e !== t; ++e) { const s = r[e], o = i[s.id]; !1 !== o.needsUpdate && s.setValue(n, o.value, a) } }, sa.seqWithValue = function (n, r) { const i = []; for (let e = 0, t = n.length; e !== t; ++e) { var a = n[e]; a.id in r && i.push(a) } return i }; let la = 0; function ca(e) { switch (e) { case Fe: return ["Linear", "( value )"]; case ge: return ["sRGB", "( value )"]; case ye: return ["RGBE", "( value )"]; case xe: return ["RGBM", "( value, 7.0 )"]; case 3005: return ["RGBM", "( value, 16.0 )"]; case 3006: return ["RGBD", "( value, 256.0 )"]; case ve: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; case 3003: return ["LogLuv", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"] } } function ha(e, n, t) { var r = e.getShaderParameter(n, 35713), i = e.getShaderInfoLog(n).trim(); return r && "" === i ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + t + "\n" + i + function () { const t = e.getShaderSource(n).split("\n"); for (let e = 0; e < t.length; e++)t[e] = e + 1 + ": " + t[e]; return t.join("\n") }() } function ua(e, t) { t = ca(t); return "vec4 " + e + "( vec4 value ) { return " + t[0] + "ToLinear" + t[1] + "; }" } function da(e) { return "" !== e } function pa(e, t) { return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows) } function ma(e, t) { return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection) } const fa = /^[ \t]*#include +<([\w\d./]+)>/gm; function ga(e) { return e.replace(fa, va) } function va(e, t) { var n = w[t]; if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">"); return ga(n) } const ya = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, xa = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function _a(e) { return e.replace(xa, Ma).replace(ya, ba) } function ba(e, t, n, r) { return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Ma(0, t, n, r) } function Ma(e, t, n, r) { let i = ""; for (let e = parseInt(t); e < parseInt(n); e++)i += r.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e); return i } function wa(e) { let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;"; return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t } function Ta(n, r, i, e) { const a = n.getContext(), t = i.defines; var s = i.vertexShader, o = i.fragmentShader; const l = function () { let e = "SHADOWMAP_TYPE_BASIC"; return 1 === i.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === i.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === i.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e }(), c = function () { let e = "ENVMAP_TYPE_CUBE"; if (i.envMap) switch (i.envMapMode) { case P: case I: e = "ENVMAP_TYPE_CUBE"; break; case H: case O: e = "ENVMAP_TYPE_CUBE_UV" }return e }(), h = function () { let e = "ENVMAP_MODE_REFLECTION"; if (i.envMap) switch (i.envMapMode) { case I: case O: e = "ENVMAP_MODE_REFRACTION" }return e }(), u = function () { let e = "ENVMAP_BLENDING_NONE"; if (i.envMap) switch (i.combine) { case 0: e = "ENVMAP_BLENDING_MULTIPLY"; break; case 1: e = "ENVMAP_BLENDING_MIX"; break; case 2: e = "ENVMAP_BLENDING_ADD" }return e }(), d = 0 < n.gammaFactor ? n.gammaFactor : 1, p = i.isWebGL2 ? "" : [i.extensionDerivatives || i.envMapCubeUV || i.bumpMap || i.tangentSpaceNormalMap || i.clearcoatNormalMap || i.flatShading || "physical" === i.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (i.extensionFragDepth || i.logarithmicDepthBuffer) && i.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", i.extensionDrawBuffers && i.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (i.extensionShaderTextureLOD || i.envMap || 0 < i.transmission) && i.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(da).join("\n"), m = function (e) { const t = []; for (const r in e) { var n = e[r]; !1 !== n && t.push("#define " + r + " " + n) } return t.join("\n") }(t), f = a.createProgram(); let g, v, y = i.glslVersion ? "#version " + i.glslVersion + "\n" : ""; i.isRawShaderMaterial ? (0 < (g = [m].filter(da).join("\n")).length && (g += "\n"), 0 < (v = [p, m].filter(da).join("\n")).length && (v += "\n")) : (g = [wa(i), "#define SHADER_NAME " + i.shaderName, m, i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + i.maxBones, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + h : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.useVertexTexture ? "#define BONE_TEXTURE" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && !1 === i.flatShading ? "#define USE_MORPHNORMALS" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + l : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(da).join("\n"), v = [p, wa(i), "#define SHADER_NAME " + i.shaderName, m, i.alphaTest ? "#define ALPHATEST " + i.alphaTest + (i.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + c : "", i.envMap ? "#define " + h : "", i.envMap ? "#define " + u : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.sheen ? "#define USE_SHEEN" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + l : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (i.extensionShaderTextureLOD || i.envMap) && i.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== i.toneMapping ? "#define TONE_MAPPING" : "", 0 !== i.toneMapping ? w.tonemapping_pars_fragment : "", 0 !== i.toneMapping ? function (e, t) { let n; switch (t) { case 1: n = "Linear"; break; case 2: n = "Reinhard"; break; case 3: n = "OptimizedCineon"; break; case 4: n = "ACESFilmic"; break; case 5: n = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear" }return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }" }("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", w.encodings_pars_fragment, i.map ? ua("mapTexelToLinear", i.mapEncoding) : "", i.matcap ? ua("matcapTexelToLinear", i.matcapEncoding) : "", i.envMap ? ua("envMapTexelToLinear", i.envMapEncoding) : "", i.emissiveMap ? ua("emissiveMapTexelToLinear", i.emissiveMapEncoding) : "", i.specularTintMap ? ua("specularTintMapTexelToLinear", i.specularTintMapEncoding) : "", i.lightMap ? ua("lightMapTexelToLinear", i.lightMapEncoding) : "", (x = "linearToOutputTexel", _ = ca(_ = i.outputEncoding), "vec4 " + x + "( vec4 value ) { return LinearTo" + _[0] + _[1] + "; }"), i.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(da).join("\n")), s = ma(pa(ga(s), i), i), o = ma(pa(ga(o), i), i), s = _a(s), o = _a(o), i.isWebGL2 && !0 !== i.isRawShaderMaterial && (y = "#version 300 es\n", g = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#define varying in", i.glslVersion === Me ? "" : "out highp vec4 pc_fragColor;", i.glslVersion === Me ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v); var x = y + v + o, _ = oa(a, 35633, y + g + s), o = oa(a, 35632, x); if (a.attachShader(f, _), a.attachShader(f, o), void 0 !== i.index0AttributeName ? a.bindAttribLocation(f, 0, i.index0AttributeName) : !0 === i.morphTargets && a.bindAttribLocation(f, 0, "position"), a.linkProgram(f), n.debug.checkShaderErrors) { const n = a.getProgramInfoLog(f).trim(), r = a.getShaderInfoLog(_).trim(), i = a.getShaderInfoLog(o).trim(); let e = !0, t = !0; if (!1 === a.getProgramParameter(f, 35714)) { e = !1; const r = ha(a, _, "vertex"), i = ha(a, o, "fragment"); console.error("THREE.WebGLProgram: shader error: ", a.getError(), "35715", a.getProgramParameter(f, 35715), "gl.getProgramInfoLog", n, r, i) } else "" !== n ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", n) : "" !== r && "" !== i || (t = !1); t && (this.diagnostics = { runnable: e, programLog: n, vertexShader: { log: r, prefix: g }, fragmentShader: { log: i, prefix: v } }) } let b, M; return a.deleteShader(_), a.deleteShader(o), this.getUniforms = function () { return b = void 0 === b ? new sa(a, f) : b }, this.getAttributes = function () { return M = void 0 === M ? function (t, n) { const r = {}, i = t.getProgramParameter(n, 35721); for (let e = 0; e < i; e++) { const i = t.getActiveAttrib(n, e).name; r[i] = t.getAttribLocation(n, i) } return r }(a, f) : M }, this.destroy = function () { e.releaseStatesOfProgram(this), a.deleteProgram(f), this.program = void 0 }, this.name = i.shaderName, this.id = la++, this.cacheKey = r, this.usedTimes = 1, this.program = f, this.vertexShader = _, this.fragmentShader = o, this } function Ea(u, d, p, m, f, e, g) { const a = [], v = f.isWebGL2, y = f.logarithmicDepthBuffer, x = f.floatVertexTextures, _ = f.maxVertexUniforms, b = f.vertexTextures; let M = f.precision; const w = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, r = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "specularIntensityMap", "specularTintMap", "specularTintMapEncoding", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmission", "transmissionMap", "thicknessMap"]; function T(e) { let t; return t = e && e.isTexture ? e.encoding : e && e.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e.texture.encoding) : Fe } return { getParameters: function (e, t, n, r, i) { var a = r.fog, r = e.isMeshStandardMaterial ? r.environment : null, r = (e.isMeshStandardMaterial ? p : d).get(e.envMap || r), s = w[e.type], o = i.isSkinnedMesh ? function (e) { var t = e.skeleton.bones; if (x) return 1024; { const e = _, n = Math.floor((e - 20) / 4), r = Math.min(n, t.length); return r < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + r + "."), 0) : r } }(i) : 0; let l, c; if (null !== e.precision && ((M = f.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", M, "instead.")), s) { const u = yr[s]; l = u.vertexShader, c = u.fragmentShader } else l = e.vertexShader, c = e.fragmentShader; var h = u.getRenderTarget(); return { isWebGL2: v, shaderID: s, shaderName: e.type, vertexShader: l, fragmentShader: c, defines: e.defines, isRawShaderMaterial: !0 === e.isRawShaderMaterial, glslVersion: e.glslVersion, precision: M, instancing: !0 === i.isInstancedMesh, instancingColor: !0 === i.isInstancedMesh && null !== i.instanceColor, supportsVertexTextures: b, outputEncoding: null !== h ? T(h.texture) : u.outputEncoding, map: !!e.map, mapEncoding: T(e.map), matcap: !!e.matcap, matcapEncoding: T(e.matcap), envMap: !!r, envMapMode: r && r.mapping, envMapEncoding: T(r), envMapCubeUV: !!r && (r.mapping === H || r.mapping === O), lightMap: !!e.lightMap, lightMapEncoding: T(e.lightMap), aoMap: !!e.aoMap, emissiveMap: !!e.emissiveMap, emissiveMapEncoding: T(e.emissiveMap), bumpMap: !!e.bumpMap, normalMap: !!e.normalMap, objectSpaceNormalMap: 1 === e.normalMapType, tangentSpaceNormalMap: 0 === e.normalMapType, clearcoatMap: !!e.clearcoatMap, clearcoatRoughnessMap: !!e.clearcoatRoughnessMap, clearcoatNormalMap: !!e.clearcoatNormalMap, displacementMap: !!e.displacementMap, roughnessMap: !!e.roughnessMap, metalnessMap: !!e.metalnessMap, specularMap: !!e.specularMap, specularIntensityMap: !!e.specularIntensityMap, specularTintMap: !!e.specularTintMap, specularTintMapEncoding: T(e.specularTintMap), alphaMap: !!e.alphaMap, gradientMap: !!e.gradientMap, sheen: !!e.sheen, transmission: !!e.transmission, transmissionMap: !!e.transmissionMap, thicknessMap: !!e.thicknessMap, combine: e.combine, vertexTangents: !!e.normalMap && !!i.geometry && !!i.geometry.attributes.tangent, vertexColors: e.vertexColors, vertexAlphas: !0 === e.vertexColors && !!i.geometry && !!i.geometry.attributes.color && 4 === i.geometry.attributes.color.itemSize, vertexUvs: !!(e.map || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e.emissiveMap || e.roughnessMap || e.metalnessMap || e.clearcoatMap || e.clearcoatRoughnessMap || e.clearcoatNormalMap || e.displacementMap || e.transmissionMap || e.thicknessMap || e.specularIntensityMap || e.specularTintMap), uvsVertexOnly: !(e.map || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e.emissiveMap || e.roughnessMap || e.metalnessMap || e.clearcoatNormalMap || e.transmission || e.transmissionMap || e.thicknessMap || e.specularIntensityMap || e.specularTintMap || !e.displacementMap), fog: !!a, useFog: e.fog, fogExp2: a && a.isFogExp2, flatShading: !!e.flatShading, sizeAttenuation: e.sizeAttenuation, logarithmicDepthBuffer: y, skinning: !0 === i.isSkinnedMesh && 0 < o, maxBones: o, useVertexTexture: x, morphTargets: !!i.geometry && !!i.geometry.morphAttributes.position, morphNormals: !!i.geometry && !!i.geometry.morphAttributes.normal, numDirLights: t.directional.length, numPointLights: t.point.length, numSpotLights: t.spot.length, numRectAreaLights: t.rectArea.length, numHemiLights: t.hemi.length, numDirLightShadows: t.directionalShadowMap.length, numPointLightShadows: t.pointShadowMap.length, numSpotLightShadows: t.spotShadowMap.length, numClippingPlanes: g.numPlanes, numClipIntersection: g.numIntersection, dithering: e.dithering, shadowMapEnabled: u.shadowMap.enabled && 0 < n.length, shadowMapType: u.shadowMap.type, toneMapping: e.toneMapped ? u.toneMapping : 0, physicallyCorrectLights: u.physicallyCorrectLights, premultipliedAlpha: e.premultipliedAlpha, alphaTest: e.alphaTest, doubleSided: 2 === e.side, flipSided: 1 === e.side, depthPacking: void 0 !== e.depthPacking && e.depthPacking, index0AttributeName: e.index0AttributeName, extensionDerivatives: e.extensions && e.extensions.derivatives, extensionFragDepth: e.extensions && e.extensions.fragDepth, extensionDrawBuffers: e.extensions && e.extensions.drawBuffers, extensionShaderTextureLOD: e.extensions && e.extensions.shaderTextureLOD, rendererExtensionFragDepth: v || m.has("EXT_frag_depth"), rendererExtensionDrawBuffers: v || m.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: v || m.has("EXT_shader_texture_lod"), customProgramCacheKey: e.customProgramCacheKey() } }, getProgramCacheKey: function (t) { const n = []; if (t.shaderID ? n.push(t.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines) for (const u in t.defines) n.push(u), n.push(t.defines[u]); if (!1 === t.isRawShaderMaterial) { for (let e = 0; e < r.length; e++)n.push(t[r[e]]); n.push(u.outputEncoding), n.push(u.gammaFactor) } return n.push(t.customProgramCacheKey), n.join() }, getUniforms: function (e) { var t = w[e.type]; let n; if (t) { const e = yr[t]; n = nr.clone(e.uniforms) } else n = e.uniforms; return n }, acquireProgram: function (n, r) { let i; for (let e = 0, t = a.length; e < t; e++) { const n = a[e]; if (n.cacheKey === r) { ++(i = n).usedTimes; break } } return void 0 === i && (i = new Ta(u, r, n, e), a.push(i)), i }, releaseProgram: function (e) { var t; 0 == --e.usedTimes && (t = a.indexOf(e), a[t] = a[a.length - 1], a.pop(), e.destroy()) }, programs: a } } function Sa() { let r = new WeakMap; return { get: function (e) { let t = r.get(e); return void 0 === t && (t = {}, r.set(e, t)), t }, remove: function (e) { r.delete(e) }, update: function (e, t, n) { r.get(e)[t] = n }, dispose: function () { r = new WeakMap } } } function Aa(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id } function Ra(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id } function La(l) { const c = []; let h = 0; const s = [], o = [], u = [], d = { id: -1 }; function p(e, t, n, r, i, a) { let s = c[h]; var o = l.get(n); return void 0 === s ? (s = { id: e.id, object: e, geometry: t, material: n, program: o.program || d, groupOrder: r, renderOrder: e.renderOrder, z: i, group: a }, c[h] = s) : (s.id = e.id, s.object = e, s.geometry = t, s.material = n, s.program = o.program || d, s.groupOrder = r, s.renderOrder = e.renderOrder, s.z = i, s.group = a), h++, s } return { opaque: s, transmissive: o, transparent: u, init: function () { h = 0, s.length = 0, o.length = 0, u.length = 0 }, push: function (e, t, n, r, i, a) { e = p(e, t, n, r, i, a); (0 < n.transmission ? o : !0 === n.transparent ? u : s).push(e) }, unshift: function (e, t, n, r, i, a) { e = p(e, t, n, r, i, a); (0 < n.transmission ? o : !0 === n.transparent ? u : s).unshift(e) }, finish: function () { for (let e = h, t = c.length; e < t; e++) { const h = c[e]; if (null === h.id) break; h.id = null, h.object = null, h.geometry = null, h.material = null, h.program = null, h.group = null } }, sort: function (e, t) { 1 < s.length && s.sort(e || Aa), 1 < o.length && o.sort(t || Ra), 1 < u.length && u.sort(t || Ra) } } } function Ca(r) { let i = new WeakMap; return { get: function (e, t) { let n; return !1 === i.has(e) ? (n = new La(r), i.set(e, [n])) : t >= i.get(e).length ? (n = new La(r), i.get(e).push(n)) : n = i.get(e)[t], n }, dispose: function () { i = new WeakMap } } } function Pa() { const n = {}; return { get: function (e) { if (void 0 !== n[e.id]) return n[e.id]; let t; switch (e.type) { case "DirectionalLight": t = { direction: new Le, color: new y }; break; case "SpotLight": t = { position: new Le, direction: new Le, color: new y, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": t = { position: new Le, color: new y, distance: 0, decay: 0 }; break; case "HemisphereLight": t = { direction: new Le, skyColor: new y, groundColor: new y }; break; case "RectAreaLight": t = { color: new y, position: new Le, halfWidth: new Le, halfHeight: new Le } }return n[e.id] = t } } } let Ia = 0; function Da(e, t) { return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0) } function Na(y, x) { const _ = new Pa, b = function () { const n = {}; return { get: function (e) { if (void 0 !== n[e.id]) return n[e.id]; let t; switch (e.type) { case "DirectionalLight": case "SpotLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new k }; break; case "PointLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new k, shadowCameraNear: 1, shadowCameraFar: 1e3 } }return n[e.id] = t } } }(), M = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }; for (let e = 0; e < 9; e++)M.probe.push(new Le); const h = new Le, u = new Ce, d = new Ce; return { setup: function (n) { let r = 0, i = 0, a = 0; for (let e = 0; e < 9; e++)M.probe[e].set(0, 0, 0); let s = 0, o = 0, l = 0, c = 0, h = 0, u = 0, d = 0, p = 0; n.sort(Da); for (let e = 0, t = n.length; e < t; e++) { const x = n[e], m = x.color, f = x.intensity, g = x.distance, v = x.shadow && x.shadow.map ? x.shadow.map.texture : null; if (x.isAmbientLight) r += m.r * f, i += m.g * f, a += m.b * f; else if (x.isLightProbe) for (let e = 0; e < 9; e++)M.probe[e].addScaledVector(x.sh.coefficients[e], f); else if (x.isDirectionalLight) { const y = _.get(x); if (y.color.copy(x.color).multiplyScalar(x.intensity), x.castShadow) { const y = x.shadow, _ = b.get(x); _.shadowBias = y.bias, _.shadowNormalBias = y.normalBias, _.shadowRadius = y.radius, _.shadowMapSize = y.mapSize, M.directionalShadow[s] = _, M.directionalShadowMap[s] = v, M.directionalShadowMatrix[s] = x.shadow.matrix, u++ } M.directional[s] = y, s++ } else if (x.isSpotLight) { const y = _.get(x); if (y.position.setFromMatrixPosition(x.matrixWorld), y.color.copy(m).multiplyScalar(f), y.distance = g, y.coneCos = Math.cos(x.angle), y.penumbraCos = Math.cos(x.angle * (1 - x.penumbra)), y.decay = x.decay, x.castShadow) { const y = x.shadow, _ = b.get(x); _.shadowBias = y.bias, _.shadowNormalBias = y.normalBias, _.shadowRadius = y.radius, _.shadowMapSize = y.mapSize, M.spotShadow[l] = _, M.spotShadowMap[l] = v, M.spotShadowMatrix[l] = x.shadow.matrix, p++ } M.spot[l] = y, l++ } else if (x.isRectAreaLight) { const y = _.get(x); y.color.copy(m).multiplyScalar(f), y.halfWidth.set(.5 * x.width, 0, 0), y.halfHeight.set(0, .5 * x.height, 0), M.rectArea[c] = y, c++ } else if (x.isPointLight) { const y = _.get(x); if (y.color.copy(x.color).multiplyScalar(x.intensity), y.distance = x.distance, y.decay = x.decay, x.castShadow) { const y = x.shadow, _ = b.get(x); _.shadowBias = y.bias, _.shadowNormalBias = y.normalBias, _.shadowRadius = y.radius, _.shadowMapSize = y.mapSize, _.shadowCameraNear = y.camera.near, _.shadowCameraFar = y.camera.far, M.pointShadow[o] = _, M.pointShadowMap[o] = v, M.pointShadowMatrix[o] = x.shadow.matrix, d++ } M.point[o] = y, o++ } else if (x.isHemisphereLight) { const y = _.get(x); y.skyColor.copy(x.color).multiplyScalar(f), y.groundColor.copy(x.groundColor).multiplyScalar(f), M.hemi[h] = y, h++ } } 0 < c && (x.isWebGL2 || !0 === y.has("OES_texture_float_linear") ? (M.rectAreaLTC1 = A.LTC_FLOAT_1, M.rectAreaLTC2 = A.LTC_FLOAT_2) : !0 === y.has("OES_texture_half_float_linear") ? (M.rectAreaLTC1 = A.LTC_HALF_1, M.rectAreaLTC2 = A.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), M.ambient[0] = r, M.ambient[1] = i, M.ambient[2] = a; const m = M.hash; m.directionalLength === s && m.pointLength === o && m.spotLength === l && m.rectAreaLength === c && m.hemiLength === h && m.numDirectionalShadows === u && m.numPointShadows === d && m.numSpotShadows === p || (M.directional.length = s, M.spot.length = l, M.rectArea.length = c, M.point.length = o, M.hemi.length = h, M.directionalShadow.length = u, M.directionalShadowMap.length = u, M.pointShadow.length = d, M.pointShadowMap.length = d, M.spotShadow.length = p, M.spotShadowMap.length = p, M.directionalShadowMatrix.length = u, M.pointShadowMatrix.length = d, M.spotShadowMatrix.length = p, m.directionalLength = s, m.pointLength = o, m.spotLength = l, m.rectAreaLength = c, m.hemiLength = h, m.numDirectionalShadows = u, m.numPointShadows = d, m.numSpotShadows = p, M.version = Ia++) }, setupView: function (n, e) { let r = 0, i = 0, a = 0, s = 0, o = 0; var l = e.matrixWorldInverse; for (let e = 0, t = n.length; e < t; e++) { var c = n[e]; if (c.isDirectionalLight) { const n = M.directional[r]; n.direction.setFromMatrixPosition(c.matrixWorld), h.setFromMatrixPosition(c.target.matrixWorld), n.direction.sub(h), n.direction.transformDirection(l), r++ } else if (c.isSpotLight) { const n = M.spot[a]; n.position.setFromMatrixPosition(c.matrixWorld), n.position.applyMatrix4(l), n.direction.setFromMatrixPosition(c.matrixWorld), h.setFromMatrixPosition(c.target.matrixWorld), n.direction.sub(h), n.direction.transformDirection(l), a++ } else if (c.isRectAreaLight) { const n = M.rectArea[s]; n.position.setFromMatrixPosition(c.matrixWorld), n.position.applyMatrix4(l), d.identity(), u.copy(c.matrixWorld), u.premultiply(l), d.extractRotation(u), n.halfWidth.set(.5 * c.width, 0, 0), n.halfHeight.set(0, .5 * c.height, 0), n.halfWidth.applyMatrix4(d), n.halfHeight.applyMatrix4(d), s++ } else if (c.isPointLight) { const n = M.point[i]; n.position.setFromMatrixPosition(c.matrixWorld), n.position.applyMatrix4(l), i++ } else if (c.isHemisphereLight) { const n = M.hemi[o]; n.direction.setFromMatrixPosition(c.matrixWorld), n.direction.transformDirection(l), n.direction.normalize(), o++ } } }, state: M } } function Ha(e, t) { const n = new Na(e, t), r = [], i = []; return { init: function () { r.length = 0, i.length = 0 }, state: { lightsArray: r, shadowsArray: i, lights: n }, setupLights: function () { n.setup(r) }, setupLightsView: function (e) { n.setupView(r, e) }, pushLight: function (e) { r.push(e) }, pushShadow: function (e) { i.push(e) } } } function Oa(r, i) { let a = new WeakMap; return { get: function (e, t = 0) { let n; return !1 === a.has(e) ? (n = new Ha(r, i), a.set(e, [n])) : t >= a.get(e).length ? (n = new Ha(r, i), a.get(e).push(n)) : n = a.get(e)[t], n }, dispose: function () { a = new WeakMap } } } class Fa extends t { constructor(e) { super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e) } copy(e) { return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this } } Fa.prototype.isMeshDepthMaterial = !0; class Ba extends t { constructor(e) { super(), this.type = "MeshDistanceMaterial", this.referencePosition = new Le, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e) } copy(e) { return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this } } function Ua(d, p, e) { let m = new mr; const f = new k, g = new k, v = new Re, l = new Fa({ depthPacking: 3201 }), c = new Ba, h = {}, y = e.maxTextureSize, u = { 0: 1, 1: 0, 2: 2 }, x = new rr({ defines: { SAMPLE_RATE: .25, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new k }, radius: { value: 4 } }, vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), _ = x.clone(), t = (_.defines.HORIZONTAL_PASS = 1, new T), b = (t.setAttribute("position", new E(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)), new S(t, x)), M = this; function w(n, e, r, t, i, a, s) { let o = null; n = !0 === t.isPointLight ? n.customDistanceMaterial : n.customDepthMaterial; if (o = void 0 !== n ? n : !0 === t.isPointLight ? c : l, d.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length) { const d = o.uuid, n = r.uuid; let e = h[d], t = (void 0 === e && (e = {}, h[d] = e), e[n]); void 0 === t && (t = o.clone(), e[n] = t), o = t } return o.visible = r.visible, o.wireframe = r.wireframe, o.side = 3 === s ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : u[r.side], o.clipShadows = r.clipShadows, o.clippingPlanes = r.clippingPlanes, o.clipIntersection = r.clipIntersection, o.wireframeLinewidth = r.wireframeLinewidth, o.linewidth = r.linewidth, !0 === t.isPointLight && !0 === o.isMeshDistanceMaterial && (o.referencePosition.setFromMatrixPosition(t.matrixWorld), o.nearDistance = i, o.farDistance = a), o } this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (n, r, i) { if (!1 !== M.enabled && (!1 !== M.autoUpdate || !1 !== M.needsUpdate) && 0 !== n.length) { const e = d.getRenderTarget(), c = d.getActiveCubeFace(), h = d.getActiveMipmapLevel(), u = d.state; u.setBlending(0), u.buffers.color.setClear(1, 1, 1, 1), u.buffers.depth.setTest(!0), u.setScissorTest(!1); for (let e = 0, t = n.length; e < t; e++) { const c = n[e], h = c.shadow; if (void 0 === h) console.warn("THREE.WebGLShadowMap:", c, "has no shadow."); else if (!1 !== h.autoUpdate || !1 !== h.needsUpdate) { f.copy(h.mapSize); var a = h.getFrameExtents(); if (f.multiply(a), g.copy(h.mapSize), (f.x > y || f.y > y) && (f.x > y && (g.x = Math.floor(y / a.x), f.x = g.x * a.x, h.mapSize.x = g.x), f.y > y && (g.y = Math.floor(y / a.y), f.y = g.y * a.y, h.mapSize.y = g.y)), null === h.map && !h.isPointLightShadow && 3 === this.type) { const d = { minFilter: B, magFilter: B, format: Oe }; h.map = new Ze(f.x, f.y, d), h.map.texture.name = c.name + ".shadowMap", h.mapPass = new Ze(f.x, f.y, d), h.camera.updateProjectionMatrix() } if (null === h.map) { const d = { minFilter: Ae, magFilter: Ae, format: Oe }; h.map = new Ze(f.x, f.y, d), h.map.texture.name = c.name + ".shadowMap", h.camera.updateProjectionMatrix() } d.setRenderTarget(h.map), d.clear(); var s = h.getViewportCount(); for (let e = 0; e < s; e++) { const n = h.getViewport(e); v.set(g.x * n.x, g.y * n.y, g.x * n.z, g.y * n.w), u.viewport(v), h.updateMatrices(c, e), m = h.getFrustum(), function n(r, i, a, s, o) { if (!1 !== r.visible) { if (r.layers.test(i.layers) && (r.isMesh || r.isLine || r.isPoints) && (r.castShadow || r.receiveShadow && 3 === o) && (!r.frustumCulled || m.intersectsObject(r))) { r.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, r.matrixWorld); const m = p.update(r), i = r.material; if (Array.isArray(i)) { const p = m.groups; for (let e = 0, t = p.length; e < t; e++) { var l = p[e], c = i[l.materialIndex]; if (c && c.visible) { const p = w(r, 0, c, s, a.near, a.far, o); d.renderBufferDirect(a, null, m, p, r, l) } } } else if (i.visible) { const p = w(r, 0, i, s, a.near, a.far, o); d.renderBufferDirect(a, null, m, p, r, null) } } var h = r.children; for (let e = 0, t = h.length; e < t; e++)n(h[e], i, a, s, o) } }(r, i, h.camera, c, this.type) } h.isPointLightShadow || 3 !== this.type || (a = h, o = i, l = void 0, l = p.update(b), x.uniforms.shadow_pass.value = a.map.texture, x.uniforms.resolution.value = a.mapSize, x.uniforms.radius.value = a.radius, d.setRenderTarget(a.mapPass), d.clear(), d.renderBufferDirect(o, null, l, x, b, null), _.uniforms.shadow_pass.value = a.mapPass.texture, _.uniforms.resolution.value = a.mapSize, _.uniforms.radius.value = a.radius, d.setRenderTarget(a.map), d.clear(), d.renderBufferDirect(o, null, l, _, b, null)), h.needsUpdate = !1 } } var o, l; M.needsUpdate = !1, d.setRenderTarget(e, c, h) } } } function za(h, O, F) { const n = F.isWebGL2, r = new function () { let t = !1; const a = new Re; let n = null; const s = new Re(0, 0, 0, 0); return { setMask: function (e) { n === e || t || (h.colorMask(e, e, e, e), n = e) }, setLocked: function (e) { t = e }, setClear: function (e, t, n, r, i) { !0 === i && (e *= r, t *= r, n *= r), a.set(e, t, n, r), !1 === s.equals(a) && (h.clearColor(e, t, n, r), s.copy(a)) }, reset: function () { t = !1, n = null, s.set(-1, 0, 0, 0) } } }, i = new function () { let t = !1, n = null, r = null, i = null; return { setTest: function (e) { (e ? P : I)(2929) }, setMask: function (e) { n === e || t || (h.depthMask(e), n = e) }, setFunc: function (e) { if (r !== e) { if (e) switch (e) { case 0: h.depthFunc(512); break; case 1: h.depthFunc(519); break; case 2: h.depthFunc(513); break; case 3: h.depthFunc(515); break; case 4: h.depthFunc(514); break; case 5: h.depthFunc(518); break; case 6: h.depthFunc(516); break; case 7: h.depthFunc(517); break; default: h.depthFunc(515) } else h.depthFunc(515); r = e } }, setLocked: function (e) { t = e }, setClear: function (e) { i !== e && (h.clearDepth(e), i = e) }, reset: function () { t = !1, n = null, r = null, i = null } } }, a = new function () { let t = !1, n = null, r = null, i = null, a = null, s = null, o = null, l = null, c = null; return { setTest: function (e) { t || (e ? P : I)(2960) }, setMask: function (e) { n === e || t || (h.stencilMask(e), n = e) }, setFunc: function (e, t, n) { r === e && i === t && a === n || (h.stencilFunc(e, t, n), r = e, i = t, a = n) }, setOp: function (e, t, n) { s === e && o === t && l === n || (h.stencilOp(e, t, n), s = e, o = t, l = n) }, setLocked: function (e) { t = e }, setClear: function (e) { c !== e && (h.clearStencil(e), c = e) }, reset: function () { t = !1, n = null, r = null, i = null, a = null, s = null, o = null, l = null, c = null } } }; let t = {}, s = null, o = {}, l = null, c = !1, u = null, d = null, p = null, m = null, f = null, g = null, v = null, y = !1, x = null, _ = null, b = null, M = null, w = null; const B = h.getParameter(35661); let T = !1, e = 0; const E = h.getParameter(7938); -1 !== E.indexOf("WebGL") ? (e = parseFloat(/^WebGL (\d)/.exec(E)[1]), T = 1 <= e) : -1 !== E.indexOf("OpenGL ES") && (e = parseFloat(/^OpenGL ES (\d)/.exec(E)[1]), T = 2 <= e); let S = null, A = {}; const U = h.getParameter(3088), z = h.getParameter(2978), R = (new Re).fromArray(U), L = (new Re).fromArray(z); function G(e, t, n) { var r = new Uint8Array(4), i = h.createTexture(); h.bindTexture(e, i), h.texParameteri(e, 10241, 9728), h.texParameteri(e, 10240, 9728); for (let e = 0; e < n; e++)h.texImage2D(t + e, 0, 6408, 1, 1, 0, 6408, 5121, r); return i } const C = {}; function P(e) { !0 !== t[e] && (h.enable(e), t[e] = !0) } function I(e) { !1 !== t[e] && (h.disable(e), t[e] = !1) } C[3553] = G(3553, 3553, 1), C[34067] = G(34067, 34069, 6), r.setClear(0, 0, 0, 1), i.setClear(1), a.setClear(0), P(2929), i.setFunc(3), k(!1), V(1), P(2884), H(0); const D = { [q]: 32774, 101: 32778, 102: 32779 }; if (n) D[103] = 32775, D[104] = 32776; else { const h = O.get("EXT_blend_minmax"); null !== h && (D[103] = h.MIN_EXT, D[104] = h.MAX_EXT) } const N = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 }; function H(e, t, n, r, i, a, s, o) { if (0 !== e) { if (!1 === c && (P(3042), c = !0), 5 === e) i = i || t, a = a || n, s = s || r, t === d && i === f || (h.blendEquationSeparate(D[t], D[i]), d = t, f = i), n === p && r === m && a === g && s === v || (h.blendFuncSeparate(N[n], N[r], N[a], N[s]), p = n, m = r, g = a, v = s), u = e, y = null; else if (e !== u || o !== y) { if (d === q && f === q || (h.blendEquation(32774), d = q, f = q), o) switch (e) { case 1: h.blendFuncSeparate(1, 771, 1, 771); break; case 2: h.blendFunc(1, 1); break; case 3: h.blendFuncSeparate(0, 0, 769, 771); break; case 4: h.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) } else switch (e) { case 1: h.blendFuncSeparate(770, 771, 1, 771); break; case 2: h.blendFunc(770, 1); break; case 3: h.blendFunc(0, 769); break; case 4: h.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) }p = null, m = null, g = null, v = null, u = e, y = o } } else !0 === c && (I(3042), c = !1) } function k(e) { x !== e && (e ? h.frontFace(2304) : h.frontFace(2305), x = e) } function V(e) { 0 !== e ? (P(2884), e !== _ && (1 === e ? h.cullFace(1029) : 2 === e ? h.cullFace(1028) : h.cullFace(1032))) : I(2884), _ = e } function W(e, t, n) { e ? (P(32823), M === t && w === n || (h.polygonOffset(t, n), M = t, w = n)) : I(32823) } function j(e) { void 0 === e && (e = 33984 + B - 1), S !== e && (h.activeTexture(e), S = e) } return { buffers: { color: r, depth: i, stencil: a }, enable: P, disable: I, bindFramebuffer: function (e, t) { return null === t && null !== s && (t = s), o[e] !== t && (h.bindFramebuffer(e, t), o[e] = t, n && (36009 === e && (o[36160] = t), 36160 === e && (o[36009] = t)), !0) }, bindXRFramebuffer: function (e) { e !== s && (h.bindFramebuffer(36160, e), s = e) }, useProgram: function (e) { return l !== e && (h.useProgram(e), l = e, !0) }, setBlending: H, setMaterial: function (e, t) { (2 === e.side ? I : P)(2884); let n = 1 === e.side; k(n = t ? !n : n), 1 === e.blending && !1 === e.transparent ? H(0) : H(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), i.setFunc(e.depthFunc), i.setTest(e.depthTest), i.setMask(e.depthWrite), r.setMask(e.colorWrite); t = e.stencilWrite; a.setTest(t), t && (a.setMask(e.stencilWriteMask), a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), W(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), (!0 === e.alphaToCoverage ? P : I)(32926) }, setFlipSided: k, setCullFace: V, setLineWidth: function (e) { e !== b && (T && h.lineWidth(e), b = e) }, setPolygonOffset: W, setScissorTest: function (e) { (e ? P : I)(3089) }, activeTexture: j, bindTexture: function (e, t) { null === S && j(); let n = A[S]; void 0 === n && (n = { type: void 0, texture: void 0 }, A[S] = n), n.type === e && n.texture === t || (h.bindTexture(e, t || C[e]), n.type = e, n.texture = t) }, unbindTexture: function () { const e = A[S]; void 0 !== e && void 0 !== e.type && (h.bindTexture(e.type, null), e.type = void 0, e.texture = void 0) }, compressedTexImage2D: function () { try { h.compressedTexImage2D.apply(h, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage2D: function () { try { h.texImage2D.apply(h, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage3D: function () { try { h.texImage3D.apply(h, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, scissor: function (e) { !1 === R.equals(e) && (h.scissor(e.x, e.y, e.z, e.w), R.copy(e)) }, viewport: function (e) { !1 === L.equals(e) && (h.viewport(e.x, e.y, e.z, e.w), L.copy(e)) }, reset: function () { h.disable(3042), h.disable(2884), h.disable(2929), h.disable(32823), h.disable(3089), h.disable(2960), h.disable(32926), h.blendEquation(32774), h.blendFunc(1, 0), h.blendFuncSeparate(1, 0, 1, 0), h.colorMask(!0, !0, !0, !0), h.clearColor(0, 0, 0, 0), h.depthMask(!0), h.depthFunc(513), h.clearDepth(1), h.stencilMask(4294967295), h.stencilFunc(519, 0, 4294967295), h.stencilOp(7680, 7680, 7680), h.clearStencil(0), h.cullFace(1029), h.frontFace(2305), h.polygonOffset(0, 0), h.activeTexture(33984), h.bindFramebuffer(36160, null), !0 === n && (h.bindFramebuffer(36009, null), h.bindFramebuffer(36008, null)), h.useProgram(null), h.lineWidth(1), h.scissor(0, 0, h.canvas.width, h.canvas.height), h.viewport(0, 0, h.canvas.width, h.canvas.height), t = {}, S = null, A = {}, s = null, o = {}, l = null, c = !1, u = null, d = null, p = null, m = null, f = null, g = null, v = null, y = !1, x = null, _ = null, b = null, M = null, w = null, R.set(0, 0, h.canvas.width, h.canvas.height), L.set(0, 0, h.canvas.width, h.canvas.height), r.reset(), i.reset(), a.reset() } } } function Ga(d, i, p, m, f, g, v) { const y = f.isWebGL2, t = f.maxTextures, x = f.maxCubemapSize, h = f.maxTextureSize, F = f.maxSamples, a = new WeakMap; let l, n = !1; try { n = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (d) { } function c(e, t) { return n ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") } function _(e, t, n, r) { let i = 1; if ((i = e.width > r || e.height > r ? r / Math.max(e.width, e.height) : i) < 1 || !0 === t) { if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) { const r = t ? Ve : Math.floor, a = r(i * e.width), s = r(i * e.height), o = (void 0 === l && (l = c(a, s)), n ? c(a, s) : l); return o.width = a, o.height = s, o.getContext("2d").drawImage(e, 0, 0, a, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + a + "x" + s + ")."), o } return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e } return e } function b(e) { return Ge(e.width) && Ge(e.height) } function M(e, t) { return e.generateMipmaps && t && e.minFilter !== Ae && e.minFilter !== B } function w(e, t, n, r, i = 1) { d.generateMipmap(e), m.get(t).__maxMipLevel = Math.log2(Math.max(n, r, i)) } function T(e, t, n) { if (!1 === y) return t; if (null !== e) { if (void 0 !== d[e]) return d[e]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + e + "'") } let r = t; return 6403 === t && (5126 === n && (r = 33326), 5131 === n && (r = 33325), 5121 === n && (r = 33321)), 6407 === t && (5126 === n && (r = 34837), 5131 === n && (r = 34843), 5121 === n && (r = 32849)), 6408 === t && (5126 === n && (r = 34836), 5131 === n && (r = 34842), 5121 === n && (r = 32856)), 33325 !== r && 33326 !== r && 34842 !== r && 34836 !== r || i.get("EXT_color_buffer_float"), r } function r(e) { return e === Ae || e === G || e === W ? 9728 : 9729 } function s(e) { const t = e.target; var n; t.removeEventListener("dispose", s), e = t, void 0 !== (n = m.get(e)).__webglInit && (d.deleteTexture(n.__webglTexture), m.remove(e)), t.isVideoTexture && a.delete(t), v.memory.textures-- } function E(e) { const t = e.target; t.removeEventListener("dispose", E); { const n = (e = t).texture, r = m.get(e), i = m.get(n); if (e) { if (void 0 !== i.__webglTexture && (d.deleteTexture(i.__webglTexture), v.memory.textures--), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget) for (let e = 0; e < 6; e++)d.deleteFramebuffer(r.__webglFramebuffer[e]), r.__webglDepthbuffer && d.deleteRenderbuffer(r.__webglDepthbuffer[e]); else d.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && d.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && d.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && d.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && d.deleteRenderbuffer(r.__webglDepthRenderbuffer); if (e.isWebGLMultipleRenderTargets) for (let e = 0, t = n.length; e < t; e++) { const r = m.get(n[e]); r.__webglTexture && (d.deleteTexture(r.__webglTexture), v.memory.textures--), m.remove(n[e]) } m.remove(n), m.remove(e) } return } } let o = 0; function S(e, t) { var n, r, i = m.get(e); if (e.isVideoTexture && (n = e, r = v.render.frame, a.get(n) !== r && (a.set(n, r), n.update())), 0 < e.version && i.__version !== e.version) { const p = e.image; if (void 0 === p) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else { if (!1 !== p.complete) return void P(i, e, t); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } p.activeTexture(33984 + t), p.bindTexture(3553, i.__webglTexture) } function u(e, t) { var n = m.get(e); if (0 < e.version && n.__version !== e.version) { var r = n, i = e, a = t; if (6 === i.image.length) { C(r, i), p.activeTexture(33984 + a), p.bindTexture(34067, r.__webglTexture), d.pixelStorei(37440, i.flipY), d.pixelStorei(37441, i.premultiplyAlpha), d.pixelStorei(3317, i.unpackAlignment), d.pixelStorei(37443, 0); const c = i && (i.isCompressedTexture || i.image[0].isCompressedTexture), h = i.image[0] && i.image[0].isDataTexture, u = []; for (let e = 0; e < 6; e++)u[e] = c || h ? h ? i.image[e].image : i.image[e] : _(i.image[e], !1, !0, x); var a = u[0], e = b(a) || y, s = g.convert(i.format), o = g.convert(i.type), l = T(i.internalFormat, s, o); let n; if (L(34067, i, e), c) { for (let t = 0; t < 6; t++) { n = u[t].mipmaps; for (let e = 0; e < n.length; e++) { const a = n[e]; i.format !== Oe && i.format !== J ? null !== s ? p.compressedTexImage2D(34069 + t, e, l, a.width, a.height, 0, a.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : p.texImage2D(34069 + t, e, l, a.width, a.height, 0, s, o, a.data) } } r.__maxMipLevel = n.length - 1 } else { n = i.mipmaps; for (let t = 0; t < 6; t++)if (h) { p.texImage2D(34069 + t, 0, l, u[t].width, u[t].height, 0, s, o, u[t].data); for (let e = 0; e < n.length; e++) { const i = n[e].image[t].image; p.texImage2D(34069 + t, e + 1, l, i.width, i.height, 0, s, o, i.data) } } else { p.texImage2D(34069 + t, 0, l, s, o, u[t]); for (let e = 0; e < n.length; e++) { const i = n[e]; p.texImage2D(34069 + t, e + 1, l, s, o, i.image[t]) } } r.__maxMipLevel = n.length } M(i, e) && w(34067, i, a.width, a.height), r.__version = i.version, i.onUpdate && i.onUpdate(i) } } else p.activeTexture(33984 + t), void p.bindTexture(34067, n.__webglTexture) } const A = { [U]: 10497, [Pe]: 33071, [z]: 33648 }, R = { [Ae]: 9728, [G]: 9984, [W]: 9986, [B]: 9729, [j]: 9985, [Ie]: 9987 }; function L(e, t, n) { if (n ? (d.texParameteri(e, 10242, A[t.wrapS]), d.texParameteri(e, 10243, A[t.wrapT]), 32879 !== e && 35866 !== e || d.texParameteri(e, 32882, A[t.wrapR]), d.texParameteri(e, 10240, R[t.magFilter]), d.texParameteri(e, 10241, R[t.minFilter])) : (d.texParameteri(e, 10242, 33071), d.texParameteri(e, 10243, 33071), 32879 !== e && 35866 !== e || d.texParameteri(e, 32882, 33071), t.wrapS === Pe && t.wrapT === Pe || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), d.texParameteri(e, 10240, r(t.magFilter)), d.texParameteri(e, 10241, r(t.minFilter)), t.minFilter !== Ae && t.minFilter !== B && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === i.has("EXT_texture_filter_anisotropic")) { const n = i.get("EXT_texture_filter_anisotropic"); t.type === Ne && !1 === i.has("OES_texture_float_linear") || !1 === y && t.type === He && !1 === i.has("OES_texture_half_float_linear") || (1 < t.anisotropy || m.get(t).__currentAnisotropy) && (d.texParameterf(e, n.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, f.getMaxAnisotropy())), m.get(t).__currentAnisotropy = t.anisotropy) } } function C(e, t) { void 0 === e.__webglInit && (e.__webglInit = !0, t.addEventListener("dispose", s), e.__webglTexture = d.createTexture(), v.memory.textures++) } function P(e, n, t) { let r = 3553; n.isDataTexture2DArray && (r = 35866), n.isDataTexture3D && (r = 32879), C(e, n), p.activeTexture(33984 + t), p.bindTexture(r, e.__webglTexture), d.pixelStorei(37440, n.flipY), d.pixelStorei(37441, n.premultiplyAlpha), d.pixelStorei(3317, n.unpackAlignment), d.pixelStorei(37443, 0); t = n; var t = !y && (t.wrapS !== Pe || t.wrapT !== Pe || t.minFilter !== Ae && t.minFilter !== B) && !1 === b(n.image), t = _(n.image, t, !1, h), i = b(t) || y, a = g.convert(n.format); let s, o = g.convert(n.type), l = T(n.internalFormat, a, o); L(r, n, i); var c = n.mipmaps; if (n.isDepthTexture) l = 6402, y ? l = n.type === Ne ? 36012 : n.type === Y ? 33190 : n.type === Z ? 35056 : 33189 : n.type === Ne && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), n.format === K && 6402 === l && n.type !== X && n.type !== Y && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = X, o = g.convert(n.type)), n.format === Q && 6402 === l && (l = 34041, n.type !== Z && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = Z, o = g.convert(n.type))), p.texImage2D(3553, 0, l, t.width, t.height, 0, a, o, null); else if (n.isDataTexture) if (0 < c.length && i) { for (let e = 0, t = c.length; e < t; e++)s = c[e], p.texImage2D(3553, e, l, s.width, s.height, 0, a, o, s.data); n.generateMipmaps = !1, e.__maxMipLevel = c.length - 1 } else p.texImage2D(3553, 0, l, t.width, t.height, 0, a, o, t.data), e.__maxMipLevel = 0; else if (n.isCompressedTexture) { for (let e = 0, t = c.length; e < t; e++)s = c[e], n.format !== Oe && n.format !== J ? null !== a ? p.compressedTexImage2D(3553, e, l, s.width, s.height, 0, s.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : p.texImage2D(3553, e, l, s.width, s.height, 0, a, o, s.data); e.__maxMipLevel = c.length - 1 } else if (n.isDataTexture2DArray) p.texImage3D(35866, 0, l, t.width, t.height, t.depth, 0, a, o, t.data), e.__maxMipLevel = 0; else if (n.isDataTexture3D) p.texImage3D(32879, 0, l, t.width, t.height, t.depth, 0, a, o, t.data), e.__maxMipLevel = 0; else if (0 < c.length && i) { for (let e = 0, t = c.length; e < t; e++)s = c[e], p.texImage2D(3553, e, l, a, o, s); n.generateMipmaps = !1, e.__maxMipLevel = c.length - 1 } else p.texImage2D(3553, 0, l, a, o, t), e.__maxMipLevel = 0; M(n, i) && w(r, n, t.width, t.height), e.__version = n.version, n.onUpdate && n.onUpdate(n) } function I(e, t, n, r, i) { var a = g.convert(n.format), s = g.convert(n.type), o = T(n.internalFormat, a, s); 32879 === i || 35866 === i ? p.texImage3D(i, 0, o, t.width, t.height, t.depth, 0, a, s, null) : p.texImage2D(i, 0, o, t.width, t.height, 0, a, s, null), p.bindFramebuffer(36160, e), d.framebufferTexture2D(36160, r, i, m.get(n).__webglTexture, 0), p.bindFramebuffer(36160, null) } function D(t, n, r) { if (d.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) { let e = 33189; if (r) { const t = n.depthTexture, r = (t && t.isDepthTexture && (t.type === Ne ? e = 36012 : t.type === Y && (e = 33190)), N(n)); d.renderbufferStorageMultisample(36161, r, e, n.width, n.height) } else d.renderbufferStorage(36161, e, n.width, n.height); d.framebufferRenderbuffer(36160, 36096, 36161, t) } else if (n.depthBuffer && n.stencilBuffer) { if (r) { const t = N(n); d.renderbufferStorageMultisample(36161, t, 35056, n.width, n.height) } else d.renderbufferStorage(36161, 34041, n.width, n.height); d.framebufferRenderbuffer(36160, 33306, 36161, t) } else { const t = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture, e = g.convert(t.format), i = g.convert(t.type), a = T(t.internalFormat, e, i); if (r) { const t = N(n); d.renderbufferStorageMultisample(36161, t, a, n.width, n.height) } else d.renderbufferStorage(36161, a, n.width, n.height) } d.bindRenderbuffer(36161, null) } function N(e) { return y && e.isWebGLMultisampleRenderTarget ? Math.min(F, e.samples) : 0 } let H = !1, O = !1; this.allocateTextureUnit = function () { var e = o; return e >= t && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + t), o += 1, e }, this.resetTextureUnits = function () { o = 0 }, this.setTexture2D = S, this.setTexture2DArray = function (e, t) { var n = m.get(e); 0 < e.version && n.__version !== e.version ? P(n, e, t) : (p.activeTexture(33984 + t), p.bindTexture(35866, n.__webglTexture)) }, this.setTexture3D = function (e, t) { var n = m.get(e); 0 < e.version && n.__version !== e.version ? P(n, e, t) : (p.activeTexture(33984 + t), p.bindTexture(32879, n.__webglTexture)) }, this.setTextureCube = u, this.setupRenderTarget = function (n) { const t = n.texture, r = m.get(n), i = m.get(t); n.addEventListener("dispose", E), !0 !== n.isWebGLMultipleRenderTargets && (i.__webglTexture = d.createTexture(), i.__version = t.version, v.memory.textures++); var e = !0 === n.isWebGLCubeRenderTarget, a = !0 === n.isWebGLMultipleRenderTargets, s = !0 === n.isWebGLMultisampleRenderTarget, o = t.isDataTexture3D || t.isDataTexture2DArray, l = b(n) || y; if (!y || t.format !== J || t.type !== Ne && t.type !== He || (t.format = Oe, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), e) { r.__webglFramebuffer = []; for (let e = 0; e < 6; e++)r.__webglFramebuffer[e] = d.createFramebuffer() } else if (r.__webglFramebuffer = d.createFramebuffer(), a) if (f.drawBuffers) { const p = n.texture; for (let e = 0, t = p.length; e < t; e++) { const f = m.get(p[e]); void 0 === f.__webglTexture && (f.__webglTexture = d.createTexture(), v.memory.textures++) } } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); else if (s) if (y) { r.__webglMultisampledFramebuffer = d.createFramebuffer(), r.__webglColorRenderbuffer = d.createRenderbuffer(), d.bindRenderbuffer(36161, r.__webglColorRenderbuffer); const m = g.convert(t.format), f = g.convert(t.type), v = T(t.internalFormat, m, f), y = N(n); d.renderbufferStorageMultisample(36161, y, v, n.width, n.height), p.bindFramebuffer(36160, r.__webglMultisampledFramebuffer), d.framebufferRenderbuffer(36160, 36064, 36161, r.__webglColorRenderbuffer), d.bindRenderbuffer(36161, null), n.depthBuffer && (r.__webglDepthRenderbuffer = d.createRenderbuffer(), D(r.__webglDepthRenderbuffer, n, !0)), p.bindFramebuffer(36160, null) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."); if (e) { p.bindTexture(34067, i.__webglTexture), L(34067, t, l); for (let e = 0; e < 6; e++)I(r.__webglFramebuffer[e], n, t, 36064, 34069 + e); M(t, l) && w(34067, t, n.width, n.height), p.bindTexture(34067, null) } else if (a) { const d = n.texture; for (let e = 0, t = d.length; e < t; e++) { const g = d[e], v = m.get(g); p.bindTexture(3553, v.__webglTexture), L(3553, g, l), I(r.__webglFramebuffer, n, g, 36064 + e, 3553), M(g, l) && w(3553, g, n.width, n.height) } p.bindTexture(3553, null) } else { let e = 3553; o && (y ? e = t.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), p.bindTexture(e, i.__webglTexture), L(e, t, l), I(r.__webglFramebuffer, n, t, 36064, e), M(t, l) && w(e, t, n.width, n.height, n.depth), p.bindTexture(e, null) } if (n.depthBuffer) { var c = n; const h = m.get(c), u = !0 === c.isWebGLCubeRenderTarget; if (c.depthTexture) { if (u) throw new Error("target.depthTexture not supported in Cube render targets"); s = h.__webglFramebuffer, e = c; if (e && e.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (p.bindFramebuffer(36160, s), !e.depthTexture || !e.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); if (m.get(e.depthTexture).__webglTexture && e.depthTexture.image.width === e.width && e.depthTexture.image.height === e.height || (e.depthTexture.image.width = e.width, e.depthTexture.image.height = e.height, e.depthTexture.needsUpdate = !0), S(e.depthTexture, 0), s = m.get(e.depthTexture).__webglTexture, e.depthTexture.format === K) d.framebufferTexture2D(36160, 36096, 3553, s, 0); else { if (e.depthTexture.format !== Q) throw new Error("Unknown depthTexture format"); d.framebufferTexture2D(36160, 33306, 3553, s, 0) } } else if (u) { h.__webglDepthbuffer = []; for (let e = 0; e < 6; e++)p.bindFramebuffer(36160, h.__webglFramebuffer[e]), h.__webglDepthbuffer[e] = d.createRenderbuffer(), D(h.__webglDepthbuffer[e], c, !1) } else p.bindFramebuffer(36160, h.__webglFramebuffer), h.__webglDepthbuffer = d.createRenderbuffer(), D(h.__webglDepthbuffer, c, !1); p.bindFramebuffer(36160, null) } }, this.updateRenderTargetMipmap = function (n) { const r = b(n) || y, i = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture]; for (let e = 0, t = i.length; e < t; e++) { var a = i[e]; if (M(a, r)) { const r = n.isWebGLCubeRenderTarget ? 34067 : 3553, i = m.get(a).__webglTexture; p.bindTexture(r, i), w(r, a, n.width, n.height), p.bindTexture(r, null) } } }, this.updateMultisampleRenderTarget = function (t) { if (t.isWebGLMultisampleRenderTarget) if (y) { var n = t.width, r = t.height; let e = 16384; t.depthBuffer && (e |= 256), t.stencilBuffer && (e |= 1024); const y = m.get(t); p.bindFramebuffer(36008, y.__webglMultisampledFramebuffer), p.bindFramebuffer(36009, y.__webglFramebuffer), d.blitFramebuffer(0, 0, n, r, 0, 0, n, r, e, 9728), p.bindFramebuffer(36008, null), p.bindFramebuffer(36009, y.__webglMultisampledFramebuffer) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.") }, this.safeSetTexture2D = function (e, t) { e && e.isWebGLRenderTarget && (!1 === H && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), H = !0), e = e.texture), S(e, t) }, this.safeSetTextureCube = function (e, t) { e && e.isWebGLCubeRenderTarget && (!1 === O && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), O = !0), e = e.texture), u(e, t) } } function ka(e, n, t) { const r = t.isWebGL2; return { convert: function (e) { let t; if (e === De) return 5121; if (1017 === e) return 32819; if (1018 === e) return 32820; if (1019 === e) return 33635; if (1010 === e) return 5120; if (1011 === e) return 5122; if (e === X) return 5123; if (1013 === e) return 5124; if (e === Y) return 5125; if (e === Ne) return 5126; if (e === He) return r ? 5131 : null !== (t = n.get("OES_texture_half_float")) ? t.HALF_FLOAT_OES : null; if (1021 === e) return 6406; if (e === J) return 6407; if (e === Oe) return 6408; if (1024 === e) return 6409; if (1025 === e) return 6410; if (e === K) return 6402; if (e === Q) return 34041; if (1028 === e) return 6403; if (1029 === e) return 36244; if (1030 === e) return 33319; if (1031 === e) return 33320; if (1032 === e) return 36248; if (1033 === e) return 36249; if (e === F || e === $ || e === ee || e === te) { if (null === (t = n.get("WEBGL_compressed_texture_s3tc"))) return null; if (e === F) return t.COMPRESSED_RGB_S3TC_DXT1_EXT; if (e === $) return t.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (e === ee) return t.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (e === te) return t.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (e === ne || e === re || e === ie || e === ae) { if (null === (t = n.get("WEBGL_compressed_texture_pvrtc"))) return null; if (e === ne) return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (e === re) return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (e === ie) return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (e === ae) return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (36196 === e) return null !== (t = n.get("WEBGL_compressed_texture_etc1")) ? t.COMPRESSED_RGB_ETC1_WEBGL : null; if ((e === se || e === oe) && null !== (t = n.get("WEBGL_compressed_texture_etc"))) { if (e === se) return t.COMPRESSED_RGB8_ETC2; if (e === oe) return t.COMPRESSED_RGBA8_ETC2_EAC } return 37808 === e || 37809 === e || 37810 === e || 37811 === e || 37812 === e || 37813 === e || 37814 === e || 37815 === e || 37816 === e || 37817 === e || 37818 === e || 37819 === e || 37820 === e || 37821 === e || 37840 === e || 37841 === e || 37842 === e || 37843 === e || 37844 === e || 37845 === e || 37846 === e || 37847 === e || 37848 === e || 37849 === e || 37850 === e || 37851 === e || 37852 === e || 37853 === e ? null !== (t = n.get("WEBGL_compressed_texture_astc")) ? e : null : 36492 === e ? null !== (t = n.get("EXT_texture_compression_bptc")) ? e : null : e === Z ? r ? 34042 : null !== (t = n.get("WEBGL_depth_texture")) ? t.UNSIGNED_INT_24_8_WEBGL : null : void 0 } } } Ba.prototype.isMeshDistanceMaterial = !0; class Va extends C { constructor(e = []) { super(), this.cameras = e } } Va.prototype.isArrayCamera = !0; class Wa extends u { constructor() { super(), this.type = "Group" } } Wa.prototype.isGroup = !0; const ja = { type: "move" }; class qa { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return null === this._hand && (this._hand = new Wa, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return null === this._targetRay && (this._targetRay = new Wa, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Le, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Le), this._targetRay } getGripSpace() { return null === this._grip && (this._grip = new Wa, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Le, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Le), this._grip } dispatchEvent(e) { return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this } disconnect(e) { return this.dispatchEvent({ type: "disconnected", data: e }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this } update(e, t, n) { let r = null, i = null, a = null; const s = this._targetRay, o = this._grip, l = this._hand; if (e && "visible-blurred" !== t.session.visibilityState) if (null !== s && (null !== (r = t.getPose(e.targetRaySpace, n)) && (s.matrix.fromArray(r.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), r.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(r.linearVelocity)) : s.hasLinearVelocity = !1, r.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(r.angularVelocity)) : s.hasAngularVelocity = !1, this.dispatchEvent(ja))), l && e.hand) { a = !0; for (const r of e.hand.values()) { const e = t.getJointPose(r, n); if (void 0 === l.joints[r.jointName]) { const e = new Wa; e.matrixAutoUpdate = !1, e.visible = !1, l.joints[r.jointName] = e, l.add(e) } const i = l.joints[r.jointName]; null !== e && (i.matrix.fromArray(e.transform.matrix), i.matrix.decompose(i.position, i.rotation, i.scale), i.jointRadius = e.radius), i.visible = null !== e } const r = l.joints["index-finger-tip"], i = l.joints["thumb-tip"], s = r.position.distanceTo(i.position), o = .02; l.inputState.pinching && .025 < s ? (l.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !l.inputState.pinching && s <= .015 && (l.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this })) } else null !== o && e.gripSpace && (null !== (i = t.getPose(e.gripSpace, n)) && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1)); return null !== s && (s.visible = null !== r), null !== o && (o.visible = null !== i), null !== l && (l.visible = null !== a), this } } class Xa extends we { constructor(e, s) { super(); const r = this, o = e.state; let m = null, i = 1, l = null, a = "local-floor", c, h = null, u = null, d = null, p = null; const f = [], g = new Map, v = new C, y = (v.layers.enable(1), v.viewport = new Re, new C), x = (y.layers.enable(2), y.viewport = new Re, [v, y]), _ = new Va; _.layers.enable(1), _.layers.enable(2); let b = null, M = null; function w(e) { const t = g.get(e.inputSource); t && t.dispatchEvent({ type: e.type, data: e.inputSource }) } function T() { g.forEach(function (e, t) { e.disconnect(t) }), g.clear(), b = null, M = null, o.bindXRFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), L.stop(), r.isPresenting = !1, r.dispatchEvent({ type: "sessionend" }) } function E(t) { var n = m.inputSources; for (let e = 0; e < f.length; e++)g.set(n[e], f[e]); for (let e = 0; e < t.removed.length; e++) { const r = t.removed[e], i = g.get(r); i && (i.dispatchEvent({ type: "disconnected", data: r }), g.delete(r)) } for (let e = 0; e < t.added.length; e++) { const a = t.added[e], s = g.get(a); s && s.dispatchEvent({ type: "connected", data: a }) } } this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (e) { let t = f[e]; return void 0 === t && (t = new qa, f[e] = t), t.getTargetRaySpace() }, this.getControllerGrip = function (e) { let t = f[e]; return void 0 === t && (t = new qa, f[e] = t), t.getGripSpace() }, this.getHand = function (e) { let t = f[e]; return void 0 === t && (t = new qa, f[e] = t), t.getHandSpace() }, this.setFramebufferScaleFactor = function (e) { i = e, !0 === r.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (e) { a = e, !0 === r.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return l }, this.getSession = function () { return m }, this.setSession = async function (t) { if (null !== (m = t)) { m.addEventListener("select", w), m.addEventListener("selectstart", w), m.addEventListener("selectend", w), m.addEventListener("squeeze", w), m.addEventListener("squeezestart", w), m.addEventListener("squeezeend", w), m.addEventListener("end", T), m.addEventListener("inputsourceschange", E); const t = s.getContextAttributes(); if (!0 !== t.xrCompatible && await s.makeXRCompatible(), void 0 === m.renderState.layers) { const r = { antialias: t.antialias, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: i }; p = new XRWebGLLayer(m, s, r), m.updateRenderState({ baseLayer: p }) } else { let e = 0; if (t.antialias) { const r = { antialias: !0, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: i }; p = new XRWebGLLayer(m, s, r), m.updateRenderState({ layers: [p] }) } else { t.depth && (e = t.stencil ? 34041 : 6402); var n = { colorFormat: t.alpha ? 6408 : 6407, depthFormat: e, scaleFactor: i }; h = new XRWebGLBinding(m, s), d = h.createProjectionLayer(n), u = s.createFramebuffer(), m.updateRenderState({ layers: [d] }) } } l = await m.requestReferenceSpace(a), L.setContext(m), L.start(), r.isPresenting = !0, r.dispatchEvent({ type: "sessionstart" }) } }; const S = new Le, A = new Le; function R(e, t) { null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert() } this.updateCamera = function (e) { if (null !== m) { _.near = y.near = v.near = e.near, _.far = y.far = v.far = e.far, b === _.near && M === _.far || (m.updateRenderState({ depthNear: _.near, depthFar: _.far }), b = _.near, M = _.far); var t, n, r, i, a, s, o, l, c, h, u = e.parent, d = _.cameras; R(_, u); for (let e = 0; e < d.length; e++)R(d[e], u); _.matrixWorld.decompose(_.position, _.quaternion, _.scale), e.position.copy(_.position), e.quaternion.copy(_.quaternion), e.scale.copy(_.scale), e.matrix.copy(_.matrix), e.matrixWorld.copy(_.matrixWorld); const p = e.children; for (let e = 0, t = p.length; e < t; e++)p[e].updateMatrixWorld(!0); 2 === d.length ? (e = _, t = v, n = y, S.setFromMatrixPosition(t.matrixWorld), A.setFromMatrixPosition(n.matrixWorld), r = S.distanceTo(A), i = t.projectionMatrix.elements, n = n.projectionMatrix.elements, a = i[14] / (i[10] - 1), s = i[14] / (i[10] + 1), o = (i[9] + 1) / i[5], l = (i[9] - 1) / i[5], i = (i[8] - 1) / i[0], n = (n[8] + 1) / n[0], c = a * i, h = a * n, i = (n = r / (n - i)) * -i, t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(i), e.translateZ(n), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert(), t = a + n, a = s + n, e.projectionMatrix.makePerspective(c - i, r - i + h, o * s / a * t, l * s / a * t, t, a)) : _.projectionMatrix.copy(v.projectionMatrix) } }, this.getCamera = function () { return _ }, this.getFoveation = function () { return null !== d ? d.fixedFoveation : null !== p ? p.fixedFoveation : void 0 }, this.setFoveation = function (e) { null !== d && (d.fixedFoveation = e), null !== p && void 0 !== p.fixedFoveation && (p.fixedFoveation = e) }; let n = null; const L = new fr; L.setAnimationLoop(function (r, t) { if (null !== (c = t.getViewerPose(l))) { const r = c.views; null !== p && o.bindXRFramebuffer(p.framebuffer); let n = !1; r.length !== _.cameras.length && (_.cameras.length = 0, n = !0); for (let t = 0; t < r.length; t++) { const i = r[t]; let e = null; if (null !== p) e = p.getViewport(i); else { const r = h.getViewSubImage(d, i); o.bindXRFramebuffer(u), void 0 !== r.depthStencilTexture && s.framebufferTexture2D(36160, 36096, 3553, r.depthStencilTexture, 0), s.framebufferTexture2D(36160, 36064, 3553, r.colorTexture, 0), e = r.viewport } const a = x[t]; a.matrix.fromArray(i.transform.matrix), a.projectionMatrix.fromArray(i.projectionMatrix), a.viewport.set(e.x, e.y, e.width, e.height), 0 === t && _.matrix.copy(a.matrix), !0 === n && _.cameras.push(a) } } const i = m.inputSources; for (let e = 0; e < f.length; e++) { const s = f[e], o = i[e]; s.update(o, t, l) } n && n(r, t) }), this.setAnimationLoop = function (e) { n = e }, this.dispose = function () { } } } function Ya(a) { function d(e, t) { e.opacity.value = t.opacity, t.color && e.diffuse.value.copy(t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap); var n = a.get(t).envMap; if (n) { e.envMap.value = n, e.flipEnvMap.value = n.isCubeTexture && !1 === n.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio; const r = a.get(n).__maxMipLevel; void 0 !== r && (e.maxMipLevel.value = r) } let r, i; t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity), t.map ? r = t.map : t.specularMap ? r = t.specularMap : t.displacementMap ? r = t.displacementMap : t.normalMap ? r = t.normalMap : t.bumpMap ? r = t.bumpMap : t.roughnessMap ? r = t.roughnessMap : t.metalnessMap ? r = t.metalnessMap : t.alphaMap ? r = t.alphaMap : t.emissiveMap ? r = t.emissiveMap : t.clearcoatMap ? r = t.clearcoatMap : t.clearcoatNormalMap ? r = t.clearcoatNormalMap : t.clearcoatRoughnessMap ? r = t.clearcoatRoughnessMap : t.specularIntensityMap ? r = t.specularIntensityMap : t.specularTintMap && (r = t.specularTintMap), void 0 !== r && (!0 === (r = r.isWebGLRenderTarget ? r.texture : r).matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), t.aoMap ? i = t.aoMap : t.lightMap && (i = t.lightMap), void 0 !== i && (!0 === (i = i.isWebGLRenderTarget ? i.texture : i).matrixAutoUpdate && i.updateMatrix(), e.uv2Transform.value.copy(i.matrix)) } function p(e, t) { e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), a.get(t).envMap && (e.envMapIntensity.value = t.envMapIntensity) } return { refreshFogUniforms: function (e, t) { e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density) }, refreshMaterialUniforms: function (t, n, r, i, a) { if (n.isMeshBasicMaterial) d(t, n); else if (n.isMeshLambertMaterial) d(t, n), u = t, n.emissiveMap && (u.emissiveMap.value = n.emissiveMap); else if (n.isMeshToonMaterial) d(t, n), u = t, (h = n).gradientMap && (u.gradientMap.value = h.gradientMap), h.emissiveMap && (u.emissiveMap.value = h.emissiveMap), h.bumpMap && (u.bumpMap.value = h.bumpMap, u.bumpScale.value = h.bumpScale, 1 === h.side && (u.bumpScale.value *= -1)), h.normalMap && (u.normalMap.value = h.normalMap, u.normalScale.value.copy(h.normalScale), 1 === h.side && u.normalScale.value.negate()), h.displacementMap && (u.displacementMap.value = h.displacementMap, u.displacementScale.value = h.displacementScale, u.displacementBias.value = h.displacementBias); else if (n.isMeshPhongMaterial) d(t, n), h = n, (c = t).specular.value.copy(h.specular), c.shininess.value = Math.max(h.shininess, 1e-4), h.emissiveMap && (c.emissiveMap.value = h.emissiveMap), h.bumpMap && (c.bumpMap.value = h.bumpMap, c.bumpScale.value = h.bumpScale, 1 === h.side && (c.bumpScale.value *= -1)), h.normalMap && (c.normalMap.value = h.normalMap, c.normalScale.value.copy(h.normalScale), 1 === h.side && c.normalScale.value.negate()), h.displacementMap && (c.displacementMap.value = h.displacementMap, c.displacementScale.value = h.displacementScale, c.displacementBias.value = h.displacementBias); else if (n.isMeshStandardMaterial) d(t, n), n.isMeshPhysicalMaterial ? (c = a, p(a = t, l = n), a.reflectivity.value = l.reflectivity, a.clearcoat.value = l.clearcoat, a.clearcoatRoughness.value = l.clearcoatRoughness, l.sheen && a.sheen.value.copy(l.sheen), l.clearcoatMap && (a.clearcoatMap.value = l.clearcoatMap), l.clearcoatRoughnessMap && (a.clearcoatRoughnessMap.value = l.clearcoatRoughnessMap), l.clearcoatNormalMap && (a.clearcoatNormalScale.value.copy(l.clearcoatNormalScale), a.clearcoatNormalMap.value = l.clearcoatNormalMap, 1 === l.side && a.clearcoatNormalScale.value.negate()), a.transmission.value = l.transmission, l.transmissionMap && (a.transmissionMap.value = l.transmissionMap), 0 < l.transmission && (a.transmissionSamplerMap.value = c.texture, a.transmissionSamplerSize.value.set(c.width, c.height)), a.thickness.value = l.thickness, l.thicknessMap && (a.thicknessMap.value = l.thicknessMap), a.attenuationDistance.value = l.attenuationDistance, a.attenuationTint.value.copy(l.attenuationTint), a.specularIntensity.value = l.specularIntensity, a.specularTint.value.copy(l.specularTint), l.specularIntensityMap && (a.specularIntensityMap.value = l.specularIntensityMap), l.specularTintMap && (a.specularTintMap.value = l.specularTintMap)) : p(t, n); else if (n.isMeshMatcapMaterial) d(t, n), a = t, (l = n).matcap && (a.matcap.value = l.matcap), l.bumpMap && (a.bumpMap.value = l.bumpMap, a.bumpScale.value = l.bumpScale, 1 === l.side && (a.bumpScale.value *= -1)), l.normalMap && (a.normalMap.value = l.normalMap, a.normalScale.value.copy(l.normalScale), 1 === l.side && a.normalScale.value.negate()), l.displacementMap && (a.displacementMap.value = l.displacementMap, a.displacementScale.value = l.displacementScale, a.displacementBias.value = l.displacementBias); else if (n.isMeshDepthMaterial) d(t, n), a = t, (o = n).displacementMap && (a.displacementMap.value = o.displacementMap, a.displacementScale.value = o.displacementScale, a.displacementBias.value = o.displacementBias); else if (n.isMeshDistanceMaterial) d(t, n), a = t, (o = n).displacementMap && (a.displacementMap.value = o.displacementMap, a.displacementScale.value = o.displacementScale, a.displacementBias.value = o.displacementBias), a.referencePosition.value.copy(o.referencePosition), a.nearDistance.value = o.nearDistance, a.farDistance.value = o.farDistance; else if (n.isMeshNormalMaterial) d(t, n), a = t, (e = n).bumpMap && (a.bumpMap.value = e.bumpMap, a.bumpScale.value = e.bumpScale, 1 === e.side && (a.bumpScale.value *= -1)), e.normalMap && (a.normalMap.value = e.normalMap, a.normalScale.value.copy(e.normalScale), 1 === e.side && a.normalScale.value.negate()), e.displacementMap && (a.displacementMap.value = e.displacementMap, a.displacementScale.value = e.displacementScale, a.displacementBias.value = e.displacementBias); else if (n.isLineBasicMaterial) a = n, (e = t).diffuse.value.copy(a.color), e.opacity.value = a.opacity, n.isLineDashedMaterial && (a = n, (s = t).dashSize.value = a.dashSize, s.totalSize.value = a.dashSize + a.gapSize, s.scale.value = a.scale); else if (n.isPointsMaterial) { (s = t).diffuse.value.copy((a = n).color), s.opacity.value = a.opacity, s.size.value = a.size * r, s.scale.value = .5 * i, a.map && (s.map.value = a.map), a.alphaMap && (s.alphaMap.value = a.alphaMap); let e; a.map ? e = a.map : a.alphaMap && (e = a.alphaMap), void 0 !== e && (!0 === e.matrixAutoUpdate && e.updateMatrix(), s.uvTransform.value.copy(e.matrix)) } else if (n.isSpriteMaterial) { (r = t).diffuse.value.copy((i = n).color), r.opacity.value = i.opacity, r.rotation.value = i.rotation, i.map && (r.map.value = i.map), i.alphaMap && (r.alphaMap.value = i.alphaMap); let e; i.map ? e = i.map : i.alphaMap && (e = i.alphaMap), void 0 !== e && (!0 === e.matrixAutoUpdate && e.updateMatrix(), r.uvTransform.value.copy(e.matrix)) } else n.isShadowMaterial ? (t.color.value.copy(n.color), t.opacity.value = n.opacity) : n.isShaderMaterial && (n.uniformsNeedUpdate = !1); var s, e, o, l, c, h, u } } } function s(e = {}) { const i = void 0 !== e.canvas ? e.canvas : function () { const e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); return e.style.display = "block", e }(), n = void 0 !== e.context ? e.context : null, a = void 0 !== e.alpha && e.alpha, s = void 0 === e.depth || e.depth, U = void 0 === e.stencil || e.stencil, z = void 0 !== e.antialias && e.antialias, G = void 0 === e.premultipliedAlpha || e.premultipliedAlpha, k = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer, V = void 0 !== e.powerPreference ? e.powerPreference : "default", W = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat; let h = null, b = null; const c = [], u = [], M = (this.domElement = i, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = Fe, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1, this); let j = !1, q = 0, X = 0, w = null, Y = -1, T = null; const m = new Re, Z = new Re; let J = null, r = i.width, E = i.height, S = 1, K = null, Q = null; const o = new Re(0, 0, r, E), l = new Re(0, 0, r, E); let $ = !1; const d = [], ee = new mr; let te = !1, ne = !1, A = null; const p = new Ce, R = new Le, re = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function ie() { return null === w ? S : 1 } let f, L, C, g, P, I, D, ae, se, oe, v, y, le, ce, he, N, x, _, ue, de, pe, H, O, F = n; function me(t, n) { for (let e = 0; e < t.length; e++) { var r = t[e], r = i.getContext(r, n); if (null !== r) return r } return null } try { const e = { alpha: a, depth: s, stencil: U, antialias: z, premultipliedAlpha: G, preserveDrawingBuffer: k, powerPreference: V, failIfMajorPerformanceCaveat: W }; if (i.addEventListener("webglcontextlost", ge, !1), i.addEventListener("webglcontextrestored", ve, !1), null === F) { const i = ["webgl2", "webgl", "experimental-webgl"]; if (!0 === M.isWebGL1Renderer && i.shift(), null === (F = me(i, e))) throw me(i) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } void 0 === F.getShaderPrecisionFormat && (F.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (e) { throw console.error("THREE.WebGLRenderer: " + e.message), e } function fe() { f = new Kr(F), L = new Mr(F, f, e), f.init(L), H = new ka(F, f, L), C = new za(F, f, L), d[0] = 1029, g = new ei(F), P = new Sa, I = new Ga(F, f, C, P, L, H, g), D = new Tr(M), ae = new Jr(M), se = new gr(F, L), O = new _r(F, f, se, L), oe = new Qr(F, se, g, O), v = new ii(F, oe, se, g), ue = new ri(F), N = new wr(P), y = new Ea(M, D, ae, f, L, O, N), le = new Ya(P), ce = new Ca(P), he = new Oa(f, L), _ = new xr(M, D, C, v, G), x = new Ua(M, v, L), de = new br(F, f, g, L), pe = new $r(F, f, g, L), g.programs = y.programs, M.capabilities = L, M.extensions = f, M.properties = P, M.renderLists = ce, M.shadowMap = x, M.state = C, M.info = g } fe(); const B = new Xa(M, F); function ge(e) { e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), j = !0 } function ve() { console.log("THREE.WebGLRenderer: Context Restored."), j = !1; var e = g.autoReset, t = x.enabled, n = x.autoUpdate, r = x.needsUpdate, i = x.type; fe(), g.autoReset = e, x.enabled = t, x.autoUpdate = n, x.needsUpdate = r, x.type = i } function ye(e) { const t = e.target; t.removeEventListener("dispose", ye); e = t; { var n = e; const r = P.get(n).programs; void 0 !== r && r.forEach(function (e) { y.releaseProgram(e) }) } P.remove(e) } this.xr = B, this.getContext = function () { return F }, this.getContextAttributes = function () { return F.getContextAttributes() }, this.forceContextLoss = function () { const e = f.get("WEBGL_lose_context"); e && e.loseContext() }, this.forceContextRestore = function () { const e = f.get("WEBGL_lose_context"); e && e.restoreContext() }, this.getPixelRatio = function () { return S }, this.setPixelRatio = function (e) { void 0 !== e && (S = e, this.setSize(r, E, !1)) }, this.getSize = function (e) { return e.set(r, E) }, this.setSize = function (e, t, n) { B.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (r = e, E = t, i.width = Math.floor(e * S), i.height = Math.floor(t * S), !1 !== n && (i.style.width = e + "px", i.style.height = t + "px"), this.setViewport(0, 0, e, t)) }, this.getDrawingBufferSize = function (e) { return e.set(r * S, E * S).floor() }, this.setDrawingBufferSize = function (e, t, n) { r = e, E = t, S = n, i.width = Math.floor(e * n), i.height = Math.floor(t * n), this.setViewport(0, 0, e, t) }, this.getCurrentViewport = function (e) { return e.copy(m) }, this.getViewport = function (e) { return e.copy(o) }, this.setViewport = function (e, t, n, r) { e.isVector4 ? o.set(e.x, e.y, e.z, e.w) : o.set(e, t, n, r), C.viewport(m.copy(o).multiplyScalar(S).floor()) }, this.getScissor = function (e) { return e.copy(l) }, this.setScissor = function (e, t, n, r) { e.isVector4 ? l.set(e.x, e.y, e.z, e.w) : l.set(e, t, n, r), C.scissor(Z.copy(l).multiplyScalar(S).floor()) }, this.getScissorTest = function () { return $ }, this.setScissorTest = function (e) { C.setScissorTest($ = e) }, this.setOpaqueSort = function (e) { K = e }, this.setTransparentSort = function (e) { Q = e }, this.getClearColor = function (e) { return e.copy(_.getClearColor()) }, this.setClearColor = function () { _.setClearColor.apply(_, arguments) }, this.getClearAlpha = function () { return _.getClearAlpha() }, this.setClearAlpha = function () { _.setClearAlpha.apply(_, arguments) }, this.clear = function (e, t, n) { let r = 0; void 0 !== e && !e || (r |= 16384), void 0 !== t && !t || (r |= 256), void 0 !== n && !n || (r |= 1024), F.clear(r) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { i.removeEventListener("webglcontextlost", ge, !1), i.removeEventListener("webglcontextrestored", ve, !1), ce.dispose(), he.dispose(), P.dispose(), D.dispose(), ae.dispose(), v.dispose(), O.dispose(), B.dispose(), B.removeEventListener("sessionstart", _e), B.removeEventListener("sessionend", be), A && (A.dispose(), A = null), t.stop() }, this.renderBufferImmediate = function (e, t) { O.initAttributes(); const n = P.get(e); e.hasPositions && !n.position && (n.position = F.createBuffer()), e.hasNormals && !n.normal && (n.normal = F.createBuffer()), e.hasUvs && !n.uv && (n.uv = F.createBuffer()), e.hasColors && !n.color && (n.color = F.createBuffer()); t = t.getAttributes(); e.hasPositions && (F.bindBuffer(34962, n.position), F.bufferData(34962, e.positionArray, 35048), O.enableAttribute(t.position), F.vertexAttribPointer(t.position, 3, 5126, !1, 0, 0)), e.hasNormals && (F.bindBuffer(34962, n.normal), F.bufferData(34962, e.normalArray, 35048), O.enableAttribute(t.normal), F.vertexAttribPointer(t.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (F.bindBuffer(34962, n.uv), F.bufferData(34962, e.uvArray, 35048), O.enableAttribute(t.uv), F.vertexAttribPointer(t.uv, 2, 5126, !1, 0, 0)), e.hasColors && (F.bindBuffer(34962, n.color), F.bufferData(34962, e.colorArray, 35048), O.enableAttribute(t.color), F.vertexAttribPointer(t.color, 3, 5126, !1, 0, 0)), O.disableUnusedAttributes(), F.drawArrays(4, 0, e.count), e.count = 0 }, this.renderBufferDirect = function (e, t, n, r, i, a) { null === t && (t = re); var s = i.isMesh && i.matrixWorld.determinant() < 0, e = Se(e, t, r, i); C.setMaterial(r, s); let o = n.index; t = n.attributes.position; if (null === o) { if (void 0 === t || 0 === t.count) return } else if (0 === o.count) return; let l, c = 1, h = (!0 === r.wireframe && (o = oe.getWireframeAttribute(n), c = 2), void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || ue.update(i, n, r, e), O.setup(i, r, e, n, o), de); null !== o && (l = se.get(o), (h = pe).setIndex(l)); var s = (null !== o ? o : t).count, e = n.drawRange.start * c, t = n.drawRange.count * c, u = null !== a ? a.start * c : 0, a = null !== a ? a.count * c : 1 / 0, d = Math.max(e, u), s = Math.min(s, e + t, u + a) - 1, t = Math.max(0, s - d + 1); if (0 !== t) { if (i.isMesh) !0 === r.wireframe ? (C.setLineWidth(r.wireframeLinewidth * ie()), h.setMode(1)) : h.setMode(4); else if (i.isLine) { let e = r.linewidth; void 0 === e && (e = 1), C.setLineWidth(e * ie()), i.isLineSegments ? h.setMode(1) : i.isLineLoop ? h.setMode(2) : h.setMode(3) } else i.isPoints ? h.setMode(0) : i.isSprite && h.setMode(4); if (i.isInstancedMesh) h.renderInstances(d, t, i.count); else if (n.isInstancedBufferGeometry) { const e = Math.min(n.instanceCount, n._maxInstanceCount); h.renderInstances(d, t, e) } else h.render(d, t) } }, this.compile = function (r, t) { (b = he.get(r)).init(), u.push(b), r.traverseVisible(function (e) { e.isLight && e.layers.test(t.layers) && (b.pushLight(e), e.castShadow && b.pushShadow(e)) }), b.setupLights(), r.traverse(function (t) { var n = t.material; if (n) if (Array.isArray(n)) for (let e = 0; e < n.length; e++)Te(n[e], r, t); else Te(n, r, t) }), u.pop(), b = null }; let xe = null; function _e() { t.stop() } function be() { t.start() } const t = new fr; function Me(n, r, i) { var a = !0 === r.isScene ? r.overrideMaterial : null; if (i.isArrayCamera) { var s = i.cameras; for (let e = 0, t = s.length; e < t; e++) { var o = s[e]; C.viewport(m.copy(o.viewport)), b.setupLightsView(o); for (let e = 0, t = n.length; e < t; e++) { const c = n[e], h = c.object, u = c.geometry, d = null === a ? c.material : a, p = c.group; h.layers.test(o.layers) && we(h, r, o, u, d, p) } } } else for (let e = 0, t = n.length; e < t; e++) { var l = n[e]; we(l.object, r, i, l.geometry, null === a ? l.material : a, l.group) } } function we(e, t, n, r, i, a) { if (e.onBeforeRender(M, t, n, r, i, a), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) { const r = Se(n, t, i, e); C.setMaterial(i), O.reset(), s = r, e.render(function (e) { M.renderBufferImmediate(e, s) }) } else !0 === i.transparent && 2 === i.side ? (i.side = 1, i.needsUpdate = !0, M.renderBufferDirect(n, t, r, i, e, a), i.side = 0, i.needsUpdate = !0, M.renderBufferDirect(n, t, r, i, e, a), i.side = 2) : M.renderBufferDirect(n, t, r, i, e, a); var s; e.onAfterRender(M, t, n, r, i, a) } function Te(e, t, n) { !0 !== t.isScene && (t = re); const r = P.get(e), i = b.state.lights, a = b.state.shadowsArray, s = i.state.version, o = y.getParameters(e, i.state, a, t, n), l = y.getProgramCacheKey(o); let c = r.programs, h = (r.environment = e.isMeshStandardMaterial ? t.environment : null, r.fog = t.fog, r.envMap = (e.isMeshStandardMaterial ? ae : D).get(e.envMap || r.environment), void 0 === c && (e.addEventListener("dispose", ye), c = new Map, r.programs = c), c.get(l)); if (void 0 !== h) { if (r.currentProgram === h && r.lightsStateVersion === s) return Ee(e, o), h } else o.uniforms = y.getUniforms(e), e.onBuild(o, M), e.onBeforeCompile(o, M), h = y.acquireProgram(o, l), c.set(l, h), r.uniforms = o.uniforms; const u = r.uniforms; (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (u.clippingPlanes = N.uniform), Ee(e, o), r.needsLights = e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights, r.lightsStateVersion = s, r.needsLights && (u.ambientLightColor.value = i.state.ambient, u.lightProbe.value = i.state.probe, u.directionalLights.value = i.state.directional, u.directionalLightShadows.value = i.state.directionalShadow, u.spotLights.value = i.state.spot, u.spotLightShadows.value = i.state.spotShadow, u.rectAreaLights.value = i.state.rectArea, u.ltc_1.value = i.state.rectAreaLTC1, u.ltc_2.value = i.state.rectAreaLTC2, u.pointLights.value = i.state.point, u.pointLightShadows.value = i.state.pointShadow, u.hemisphereLights.value = i.state.hemi, u.directionalShadowMap.value = i.state.directionalShadowMap, u.directionalShadowMatrix.value = i.state.directionalShadowMatrix, u.spotShadowMap.value = i.state.spotShadowMap, u.spotShadowMatrix.value = i.state.spotShadowMatrix, u.pointShadowMap.value = i.state.pointShadowMap, u.pointShadowMatrix.value = i.state.pointShadowMatrix); n = h.getUniforms(), t = sa.seqWithValue(n.seq, u); return r.currentProgram = h, r.uniformsList = t, h } function Ee(e, t) { const n = P.get(e); n.outputEncoding = t.outputEncoding, n.instancing = t.instancing, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents } function Se(e, t, n, r) { !0 !== t.isScene && (t = re), I.resetTextureUnits(); const i = t.fog, a = n.isMeshStandardMaterial ? t.environment : null, s = null === w ? M.outputEncoding : w.texture.encoding, o = (n.isMeshStandardMaterial ? ae : D).get(n.envMap || a), l = !0 === n.vertexColors && !!r.geometry && !!r.geometry.attributes.color && 4 === r.geometry.attributes.color.itemSize, c = !!r.geometry && !!r.geometry.attributes.tangent, h = !!r.geometry && !!r.geometry.morphAttributes.position, u = !!r.geometry && !!r.geometry.morphAttributes.normal, d = P.get(n), p = b.state.lights; if (!0 === te && (!0 === ne || e !== T)) { const t = e === T && n.id === Y; N.setState(n, e, t) } let m = !1, f = (n.version === d.__version ? (d.needsLights && d.lightsStateVersion !== p.state.version || d.outputEncoding !== s || r.isInstancedMesh && !1 === d.instancing || !r.isInstancedMesh && !0 === d.instancing || r.isSkinnedMesh && !1 === d.skinning || !r.isSkinnedMesh && !0 === d.skinning || d.envMap !== o || n.fog && d.fog !== i || void 0 !== d.numClippingPlanes && (d.numClippingPlanes !== N.numPlanes || d.numIntersection !== N.numIntersection) || d.vertexAlphas !== l || d.vertexTangents !== c || d.morphTargets !== h || d.morphNormals !== u) && (m = !0) : (m = !0, d.__version = n.version), d.currentProgram), g = !1, v = !1, y = !1; const x = (f = !0 === m ? Te(n, t, r) : f).getUniforms(), _ = d.uniforms; if (C.useProgram(f.program) && (g = !0, v = !0, y = !0), n.id !== Y && (Y = n.id, v = !0), g || T !== e) { if (x.setValue(F, "projectionMatrix", e.projectionMatrix), L.logarithmicDepthBuffer && x.setValue(F, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), T !== e && (T = e, v = !0, y = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) { const t = x.map.cameraPosition; void 0 !== t && t.setValue(F, R.setFromMatrixPosition(e.matrixWorld)) } (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && x.setValue(F, "isOrthographic", !0 === e.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || r.isSkinnedMesh) && x.setValue(F, "viewMatrix", e.matrixWorldInverse) } if (r.isSkinnedMesh) { x.setOptional(F, r, "bindMatrix"), x.setOptional(F, r, "bindMatrixInverse"); const e = r.skeleton; e && (L.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(), x.setValue(F, "boneTexture", e.boneTexture, I), x.setValue(F, "boneTextureSize", e.boneTextureSize)) : x.setOptional(F, e, "boneMatrices")) } return !v && d.receiveShadow === r.receiveShadow || (d.receiveShadow = r.receiveShadow, x.setValue(F, "receiveShadow", r.receiveShadow)), v && (x.setValue(F, "toneMappingExposure", M.toneMappingExposure), d.needsLights && (t = y, (e = _).ambientLightColor.needsUpdate = t, e.lightProbe.needsUpdate = t, e.directionalLights.needsUpdate = t, e.directionalLightShadows.needsUpdate = t, e.pointLights.needsUpdate = t, e.pointLightShadows.needsUpdate = t, e.spotLights.needsUpdate = t, e.spotLightShadows.needsUpdate = t, e.rectAreaLights.needsUpdate = t, e.hemisphereLights.needsUpdate = t), i && n.fog && le.refreshFogUniforms(_, i), le.refreshMaterialUniforms(_, n, S, E, A), sa.upload(F, d.uniformsList, _, I)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (sa.upload(F, d.uniformsList, _, I), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && x.setValue(F, "center", r.center), x.setValue(F, "modelViewMatrix", r.modelViewMatrix), x.setValue(F, "normalMatrix", r.normalMatrix), x.setValue(F, "modelMatrix", r.matrixWorld), f } t.setAnimationLoop(function (e) { xe && xe(e) }), "undefined" != typeof window && t.setContext(window), this.setAnimationLoop = function (e) { xe = e, B.setAnimationLoop(e), null === e ? t.stop() : t.start() }, B.addEventListener("sessionstart", _e), B.addEventListener("sessionend", be), this.render = function (e, t) { if (void 0 !== t && !0 !== t.isCamera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); else if (!0 !== j) { !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), !0 === B.enabled && !0 === B.isPresenting && (!0 === B.cameraAutoUpdate && B.updateCamera(t), t = B.getCamera()), !0 === e.isScene && e.onBeforeRender(M, e, t, w), (b = he.get(e, u.length)).init(), u.push(b), p.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), ee.setFromProjectionMatrix(p), ne = this.localClippingEnabled, te = N.init(this.clippingPlanes, ne, t), (h = ce.get(e, c.length)).init(), c.push(h), function n(r, i, a, s) { if (!1 !== r.visible) { if (r.layers.test(i.layers)) if (r.isGroup) a = r.renderOrder; else if (r.isLOD) !0 === r.autoUpdate && r.update(i); else if (r.isLight) b.pushLight(r), r.castShadow && b.pushShadow(r); else if (r.isSprite) { if (!r.frustumCulled || ee.intersectsSprite(r)) { s && R.setFromMatrixPosition(r.matrixWorld).applyMatrix4(p); const i = v.update(r), c = r.material; c.visible && h.push(r, i, c, a, R.z, null) } } else if (r.isImmediateRenderObject) s && R.setFromMatrixPosition(r.matrixWorld).applyMatrix4(p), h.push(r, null, r.material, a, R.z, null); else if ((r.isMesh || r.isLine || r.isPoints) && (r.isSkinnedMesh && r.skeleton.frame !== g.render.frame && (r.skeleton.update(), r.skeleton.frame = g.render.frame), !r.frustumCulled || ee.intersectsObject(r))) { s && R.setFromMatrixPosition(r.matrixWorld).applyMatrix4(p); const i = v.update(r), c = r.material; if (Array.isArray(c)) { const s = i.groups; for (let e = 0, t = s.length; e < t; e++) { var o = s[e], l = c[o.materialIndex]; l && l.visible && h.push(r, i, l, a, R.z, o) } } else c.visible && h.push(r, i, c, a, R.z, null) } const c = r.children; for (let e = 0, t = c.length; e < t; e++)n(c[e], i, a, s) } }(e, t, 0, M.sortObjects), h.finish(), !0 === M.sortObjects && h.sort(K, Q), !0 === te && N.beginShadows(); var n = b.state.shadowsArray, n = (x.render(n, e, t), b.setupLights(), b.setupLightsView(t), !0 === te && N.endShadows(), !0 === this.info.autoReset && this.info.reset(), _.render(h, e), h.opaque), r = h.transmissive, i = h.transparent; if (0 < n.length && Me(n, e, t), 0 < r.length) { var a = n; n = r; r = e; var s = t; if (null === A) { const a = !0 === z && !0 === L.isWebGL2; A = new (a ? Ke : Ze)(1024, 1024, { generateMipmaps: !0, type: null !== H.convert(He) ? He : De, minFilter: Ie, magFilter: Ae, wrapS: Pe, wrapT: Pe }) } var o = M.getRenderTarget(), l = (M.setRenderTarget(A), M.clear(), M.toneMapping); M.toneMapping = 0, Me(a, r, s), M.toneMapping = l, I.updateMultisampleRenderTarget(A), I.updateRenderTargetMipmap(A), M.setRenderTarget(o), Me(n, r, s) } 0 < i.length && Me(i, e, t), null !== w && (I.updateMultisampleRenderTarget(w), I.updateRenderTargetMipmap(w)), !0 === e.isScene && e.onAfterRender(M, e, t), C.buffers.depth.setTest(!0), C.buffers.depth.setMask(!0), C.buffers.color.setMask(!0), C.setPolygonOffset(!1), O.resetDefaultState(), Y = -1, T = null, u.pop(), b = 0 < u.length ? u[u.length - 1] : null, c.pop(), h = 0 < c.length ? c[c.length - 1] : null } }, this.getActiveCubeFace = function () { return q }, this.getActiveMipmapLevel = function () { return X }, this.getRenderTarget = function () { return w }, this.setRenderTarget = function (t, e = 0, n = 0) { w = t, q = e, X = n, t && void 0 === P.get(t).__webglFramebuffer && I.setupRenderTarget(t); let r = null, i = !1, a = !1; if (t) { const n = t.texture; (n.isDataTexture3D || n.isDataTexture2DArray) && (a = !0); var s = P.get(t).__webglFramebuffer; t.isWebGLCubeRenderTarget ? (r = s[e], i = !0) : r = t.isWebGLMultisampleRenderTarget ? P.get(t).__webglMultisampledFramebuffer : s, m.copy(t.viewport), Z.copy(t.scissor), J = t.scissorTest } else m.copy(o).multiplyScalar(S).floor(), Z.copy(l).multiplyScalar(S).floor(), J = $; if (C.bindFramebuffer(36160, r) && L.drawBuffers) { let e = !1; if (t) if (t.isWebGLMultipleRenderTargets) { const n = t.texture; if (d.length !== n.length || 36064 !== d[0]) { for (let e = 0, t = n.length; e < t; e++)d[e] = 36064 + e; d.length = n.length, e = !0 } } else 1 === d.length && 36064 === d[0] || (d[0] = 36064, d.length = 1, e = !0); else 1 === d.length && 1029 === d[0] || (d[0] = 1029, d.length = 1, e = !0); e && (L.isWebGL2 ? F.drawBuffers(d) : f.get("WEBGL_draw_buffers").drawBuffersWEBGL(d)) } if (C.viewport(m), C.scissor(Z), C.setScissorTest(J), i) { const r = P.get(t.texture); F.framebufferTexture2D(36160, 36064, 34069 + e, r.__webglTexture, n) } else if (a) { const r = P.get(t.texture), i = e || 0; F.framebufferTextureLayer(36160, 36064, r.__webglTexture, n || 0, i) } }, this.readRenderTargetPixels = function (t, n, r, i, a, s, o) { if (t && t.isWebGLRenderTarget) { let e = P.get(t).__webglFramebuffer; if (e = t.isWebGLCubeRenderTarget && void 0 !== o ? e[o] : e) { C.bindFramebuffer(36160, e); try { const o = t.texture, e = o.format, c = o.type; if (e !== Oe && H.convert(e) !== F.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); var l = c === He && (f.has("EXT_color_buffer_half_float") || L.isWebGL2 && f.has("EXT_color_buffer_float")); if (!(c === De || H.convert(c) === F.getParameter(35738) || c === Ne && (L.isWebGL2 || f.has("OES_texture_float") || f.has("WEBGL_color_buffer_float")) || l)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); 36053 === F.checkFramebufferStatus(36160) ? 0 <= n && n <= t.width - i && 0 <= r && r <= t.height - a && F.readPixels(n, r, i, a, H.convert(e), H.convert(c), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") } finally { const t = null !== w ? P.get(w).__webglFramebuffer : null; C.bindFramebuffer(36160, t) } } } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.") }, this.copyFramebufferToTexture = function (e, t, n = 0) { var r = Math.pow(2, -n), i = Math.floor(t.image.width * r), r = Math.floor(t.image.height * r); let a = H.convert(t.format); L.isWebGL2 && 6408 === (a = 6407 === a ? 32849 : a) && (a = 32856), I.setTexture2D(t, 0), F.copyTexImage2D(3553, n, a, e.x, e.y, i, r, 0), C.unbindTexture() }, this.copyTextureToTexture = function (e, t, n, r = 0) { var i = t.image.width, a = t.image.height, s = H.convert(n.format), o = H.convert(n.type); I.setTexture2D(n, 0), F.pixelStorei(37440, n.flipY), F.pixelStorei(37441, n.premultiplyAlpha), F.pixelStorei(3317, n.unpackAlignment), t.isDataTexture ? F.texSubImage2D(3553, r, e.x, e.y, i, a, s, o, t.image.data) : t.isCompressedTexture ? F.compressedTexSubImage2D(3553, r, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, s, t.mipmaps[0].data) : F.texSubImage2D(3553, r, e.x, e.y, s, o, t.image), 0 === r && n.generateMipmaps && F.generateMipmap(3553), C.unbindTexture() }, this.copyTextureToTexture3D = function (t, n, r, i, a = 0) { if (M.isWebGL1Renderer) console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."); else { var s = t.max.x - t.min.x + 1, o = t.max.y - t.min.y + 1, l = t.max.z - t.min.z + 1, c = H.convert(i.format), h = H.convert(i.type); let e; if (i.isDataTexture3D) I.setTexture3D(i, 0), e = 32879; else { if (!i.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."); I.setTexture2DArray(i, 0), e = 35866 } F.pixelStorei(37440, i.flipY), F.pixelStorei(37441, i.premultiplyAlpha), F.pixelStorei(3317, i.unpackAlignment); var u = F.getParameter(3314), d = F.getParameter(32878), p = F.getParameter(3316), m = F.getParameter(3315), f = F.getParameter(32877), g = r.isCompressedTexture ? r.mipmaps[0] : r.image; F.pixelStorei(3314, g.width), F.pixelStorei(32878, g.height), F.pixelStorei(3316, t.min.x), F.pixelStorei(3315, t.min.y), F.pixelStorei(32877, t.min.z), r.isDataTexture || r.isDataTexture3D ? F.texSubImage3D(e, a, n.x, n.y, n.z, s, o, l, c, h, g.data) : r.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), F.compressedTexSubImage3D(e, a, n.x, n.y, n.z, s, o, l, c, g.data)) : F.texSubImage3D(e, a, n.x, n.y, n.z, s, o, l, c, h, g), F.pixelStorei(3314, u), F.pixelStorei(32878, d), F.pixelStorei(3316, p), F.pixelStorei(3315, m), F.pixelStorei(32877, f), 0 === a && i.generateMipmaps && F.generateMipmap(e), C.unbindTexture() } }, this.initTexture = function (e) { I.setTexture2D(e, 0), C.unbindTexture() }, this.resetState = function () { q = 0, X = 0, w = null, C.reset(), O.reset() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } class Za extends s { } class Ja { constructor(e, t = 25e-5) { this.name = "", this.color = new y(e), this.density = t } clone() { return new Ja(this.color, this.density) } toJSON() { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } } Ja.prototype.isFogExp2 = Za.prototype.isWebGL1Renderer = !0; class Ka { constructor(e, t = 1, n = 1e3) { this.name = "", this.color = new y(e), this.near = t, this.far = n } clone() { return new Ka(this.color, this.near, this.far) } toJSON() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } } Ka.prototype.isFog = !0; class Qa extends u { constructor() { super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(e, t) { return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this } toJSON(e) { const t = super.toJSON(e); return null !== this.fog && (t.object.fog = this.fog.toJSON()), t } } Qa.prototype.isScene = !0; class $a { constructor(e, t) { this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = _e, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = Be() } onUploadCallback() { } set needsUpdate(e) { !0 === e && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this } copyAt(n, r, i) { n *= this.stride, i *= r.stride; for (let e = 0, t = this.stride; e < t; e++)this.array[n + e] = r.array[i + e]; return this } set(e, t = 0) { return this.array.set(e, t), this } clone(e) { void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Be()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride); return n.setUsage(this.usage), n } onUpload(e) { return this.onUploadCallback = e, this } toJSON(e) { return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Be()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } $a.prototype.isInterleavedBuffer = !0; const o = new Le; class es { constructor(e, t, n, r = !1) { this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === r } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(e) { this.data.needsUpdate = e } applyMatrix4(n) { for (let e = 0, t = this.data.count; e < t; e++)o.x = this.getX(e), o.y = this.getY(e), o.z = this.getZ(e), o.applyMatrix4(n), this.setXYZ(e, o.x, o.y, o.z); return this } applyNormalMatrix(n) { for (let e = 0, t = this.count; e < t; e++)o.x = this.getX(e), o.y = this.getY(e), o.z = this.getZ(e), o.applyNormalMatrix(n), this.setXYZ(e, o.x, o.y, o.z); return this } transformDirection(n) { for (let e = 0, t = this.count; e < t; e++)o.x = this.getX(e), o.y = this.getY(e), o.z = this.getZ(e), o.transformDirection(n), this.setXYZ(e, o.x, o.y, o.z); return this } setX(e, t) { return this.data.array[e * this.data.stride + this.offset] = t, this } setY(e, t) { return this.data.array[e * this.data.stride + this.offset + 1] = t, this } setZ(e, t) { return this.data.array[e * this.data.stride + this.offset + 2] = t, this } setW(e, t) { return this.data.array[e * this.data.stride + this.offset + 3] = t, this } getX(e) { return this.data.array[e * this.data.stride + this.offset] } getY(e) { return this.data.array[e * this.data.stride + this.offset + 1] } getZ(e) { return this.data.array[e * this.data.stride + this.offset + 2] } getW(e) { return this.data.array[e * this.data.stride + this.offset + 3] } setXY(e, t, n) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this } setXYZ(e, t, n, r) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this } setXYZW(e, t, n, r, i) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this } clone(t) { if (void 0 !== t) return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new es(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized); { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { var n = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++)t.push(this.data.array[n + e]) } return new E(new this.array.constructor(t), this.itemSize, this.normalized) } } toJSON(t) { if (void 0 !== t) return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized }; { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { var n = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++)t.push(this.data.array[n + e]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized } } } } es.prototype.isInterleavedBufferAttribute = !0; class ts extends t { constructor(e) { super(), this.type = "SpriteMaterial", this.color = new y(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this } } let ns; ts.prototype.isSpriteMaterial = !0; const rs = new Le, is = new Le, as = new Le, ss = new k, os = new k, ls = new Ce, cs = new Le, hs = new Le, us = new Le, ds = new k, ps = new k, ms = new k; class fs extends u { constructor(e) { if (super(), this.type = "Sprite", void 0 === ns) { ns = new T; const e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), t = new $a(e, 5); ns.setIndex([0, 1, 2, 0, 2, 3]), ns.setAttribute("position", new es(t, 3, 0, !1)), ns.setAttribute("uv", new es(t, 2, 3, !1)) } this.geometry = ns, this.material = void 0 !== e ? e : new ts, this.center = new k(.5, .5) } raycast(e, t) { null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), is.setFromMatrixScale(this.matrixWorld), ls.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), as.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && is.multiplyScalar(-as.z); var n = this.material.rotation; let r, i; 0 !== n && (i = Math.cos(n), r = Math.sin(n)); var n = this.center, a = (gs(cs.set(-.5, -.5, 0), as, n, is, r, i), gs(hs.set(.5, -.5, 0), as, n, is, r, i), gs(us.set(.5, .5, 0), as, n, is, r, i), ds.set(0, 0), ps.set(1, 0), ms.set(1, 1), e.ray.intersectTriangle(cs, hs, us, !1, rs)); null === a && (gs(hs.set(-.5, .5, 0), as, n, is, r, i), ps.set(0, 1), null === (a = e.ray.intersectTriangle(cs, us, hs, !1, rs))) || ((n = e.ray.origin.distanceTo(rs)) < e.near || n > e.far || t.push({ distance: n, point: rs.clone(), uv: g.getUV(rs, cs, hs, us, ds, ps, ms, new k), face: null, object: this })) } copy(e) { return super.copy(e), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this } } function gs(e, t, n, r, i, a) { ss.subVectors(e, n).addScalar(.5).multiply(r), void 0 !== i ? (os.x = a * ss.x - i * ss.y, os.y = i * ss.x + a * ss.y) : os.copy(ss), e.copy(t), e.x += os.x, e.y += os.y, e.applyMatrix4(ls) } fs.prototype.isSprite = !0; const vs = new Le, ys = new Le; class xs extends u { constructor() { super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }), this.autoUpdate = !0 } copy(e) { super.copy(e, !1); var n = e.levels; for (let e = 0, t = n.length; e < t; e++) { const r = n[e]; this.addLevel(r.object.clone(), r.distance) } return this.autoUpdate = e.autoUpdate, this } addLevel(e, t = 0) { t = Math.abs(t); const n = this.levels; let r; for (r = 0; r < n.length && !(t < n[r].distance); r++); return n.splice(r, 0, { distance: t, object: e }), this.add(e), this } getCurrentLevel() { return this._currentLevel } getObjectForDistance(n) { var r = this.levels; if (0 < r.length) { let e, t; for (e = 1, t = r.length; e < t && !(n < r[e].distance); e++); return r[e - 1].object } return null } raycast(e, t) { var n; 0 < this.levels.length && (vs.setFromMatrixPosition(this.matrixWorld), n = e.ray.origin.distanceTo(vs), this.getObjectForDistance(n).raycast(e, t)) } update(n) { const r = this.levels; if (1 < r.length) { vs.setFromMatrixPosition(n.matrixWorld), ys.setFromMatrixPosition(this.matrixWorld); var i = vs.distanceTo(ys) / n.zoom; let e, t; for (r[0].object.visible = !0, e = 1, t = r.length; e < t && i >= r[e].distance; e++)r[e - 1].object.visible = !1, r[e].object.visible = !0; for (this._currentLevel = e - 1; e < t; e++)r[e].object.visible = !1 } } toJSON(e) { const n = super.toJSON(e); !1 === this.autoUpdate && (n.object.autoUpdate = !1), n.object.levels = []; var r = this.levels; for (let e = 0, t = r.length; e < t; e++) { var i = r[e]; n.object.levels.push({ object: i.object.uuid, distance: i.distance }) } return n } } const _s = new Le, bs = new Re, Ms = new Re, ws = new Le, Ts = new Ce; class Es extends S { constructor(e, t) { super(e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Ce, this.bindMatrixInverse = new Ce } copy(e) { return super.copy(e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this } bind(e, t) { this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { const n = new Re, r = this.geometry.attributes.skinWeight; for (let e = 0, t = r.count; e < t; e++) { n.x = r.getX(e), n.y = r.getY(e), n.z = r.getZ(e), n.w = r.getW(e); var i = 1 / n.manhattanLength(); i != 1 / 0 ? n.multiplyScalar(i) : n.set(1, 0, 0, 0), r.setXYZW(e, n.x, n.y, n.z, n.w) } } updateMatrixWorld(e) { super.updateMatrixWorld(e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) } boneTransform(e, t) { const n = this.skeleton, r = this.geometry; bs.fromBufferAttribute(r.attributes.skinIndex, e), Ms.fromBufferAttribute(r.attributes.skinWeight, e), _s.fromBufferAttribute(r.attributes.position, e).applyMatrix4(this.bindMatrix), t.set(0, 0, 0); for (let e = 0; e < 4; e++) { const r = Ms.getComponent(e); var i; 0 !== r && (i = bs.getComponent(e), Ts.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]), t.addScaledVector(ws.copy(_s).applyMatrix4(Ts), r)) } return t.applyMatrix4(this.bindMatrixInverse) } } Es.prototype.isSkinnedMesh = !0; class Ss extends u { constructor() { super(), this.type = "Bone" } } Ss.prototype.isBone = !0; class As extends h { constructor(e = null, t = 1, n = 1, r, i, a, s, o, l = 1003, c = 1003, h, u) { super(null, a, s, o, l, c, r, i, h, u), this.image = { data: e, width: t, height: n }, this.magFilter = l, this.minFilter = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } } As.prototype.isDataTexture = !0; const Rs = new Ce, Ls = new Ce; class Cs { constructor(e = [], t = []) { this.uuid = Be(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init() } init() { var e = this.bones, t = this.boneInverses; if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses(); else if (e.length !== t.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let e = 0, t = this.bones.length; e < t; e++)this.boneInverses.push(new Ce) } } calculateInverses() { for (let e = this.boneInverses.length = 0, t = this.bones.length; e < t; e++) { const n = new Ce; this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n) } } pose() { for (let e = 0, t = this.bones.length; e < t; e++) { const n = this.bones[e]; n && n.matrixWorld.copy(this.boneInverses[e]).invert() } for (let e = 0, t = this.bones.length; e < t; e++) { const r = this.bones[e]; r && (r.parent && r.parent.isBone ? (r.matrix.copy(r.parent.matrixWorld).invert(), r.matrix.multiply(r.matrixWorld)) : r.matrix.copy(r.matrixWorld), r.matrix.decompose(r.position, r.quaternion, r.scale)) } } update() { const n = this.bones, r = this.boneInverses, i = this.boneMatrices, e = this.boneTexture; for (let e = 0, t = n.length; e < t; e++) { var a = n[e] ? n[e].matrixWorld : Ls; Rs.multiplyMatrices(a, r[e]), Rs.toArray(i, 16 * e) } null !== e && (e.needsUpdate = !0) } clone() { return new Cs(this.bones, this.boneInverses) } computeBoneTexture() { var e = ke(Math.sqrt(4 * this.bones.length)); e = Math.max(e, 4); const t = new Float32Array(e * e * 4); t.set(this.boneMatrices); var n = new As(t, e, e, Oe, Ne); return this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this } getBoneByName(n) { for (let e = 0, t = this.bones.length; e < t; e++) { var r = this.bones[e]; if (r.name === n) return r } } dispose() { null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(n, r) { this.uuid = n.uuid; for (let t = 0, e = n.bones.length; t < e; t++) { var i = n.bones[t]; let e = r[i]; void 0 === e && (console.warn("THREE.Skeleton: No bone found with UUID:", i), e = new Ss), this.bones.push(e), this.boneInverses.push((new Ce).fromArray(n.boneInverses[t])) } return this.init(), this } toJSON() { const n = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; n.uuid = this.uuid; var r = this.bones, i = this.boneInverses; for (let e = 0, t = r.length; e < t; e++) { var a = r[e]; n.bones.push(a.uuid); const s = i[e]; n.boneInverses.push(s.toArray()) } return n } } const Ps = new Ce, Is = new Ce, Ds = [], Ns = new S; class Hs extends S { constructor(e, t, n) { super(e, t), this.instanceMatrix = new E(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1 } copy(e) { return super.copy(e), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this } getColorAt(e, t) { t.fromArray(this.instanceColor.array, 3 * e) } getMatrixAt(e, t) { t.fromArray(this.instanceMatrix.array, 16 * e) } raycast(e, r) { const i = this.matrixWorld, t = this.count; if (Ns.geometry = this.geometry, Ns.material = this.material, void 0 !== Ns.material) for (let n = 0; n < t; n++) { this.getMatrixAt(n, Ps), Is.multiplyMatrices(i, Ps), Ns.matrixWorld = Is, Ns.raycast(e, Ds); for (let e = 0, t = Ds.length; e < t; e++) { const i = Ds[e]; i.instanceId = n, i.object = this, r.push(i) } Ds.length = 0 } } setColorAt(e, t) { null === this.instanceColor && (this.instanceColor = new E(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e) } setMatrixAt(e, t) { t.toArray(this.instanceMatrix.array, 16 * e) } updateMorphTargets() { } dispose() { this.dispatchEvent({ type: "dispose" }) } } Hs.prototype.isInstancedMesh = !0; class x extends t { constructor(e) { super(), this.type = "LineBasicMaterial", this.color = new y(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this } } x.prototype.isLineBasicMaterial = !0; const Os = new Le, Fs = new Le, Bs = new Ce, Us = new At, zs = new xt; class Gs extends u { constructor(e = new T, t = new x) { super(), this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e) { return super.copy(e), this.material = e.material, this.geometry = e.geometry, this } computeLineDistances() { const e = this.geometry; if (e.isBufferGeometry) if (null === e.index) { const n = e.attributes.position, r = [0]; for (let e = 1, t = n.count; e < t; e++)Os.fromBufferAttribute(n, e - 1), Fs.fromBufferAttribute(n, e), r[e] = r[e - 1], r[e] += Os.distanceTo(Fs); e.setAttribute("lineDistance", new V(r, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else e.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); return this } raycast(n, r) { const e = this.geometry, i = this.matrixWorld, a = n.params.Line.threshold, s = e.drawRange; if (null === e.boundingSphere && e.computeBoundingSphere(), zs.copy(e.boundingSphere), zs.applyMatrix4(i), zs.radius += a, !1 !== n.ray.intersectsSphere(zs)) { Bs.copy(i).invert(), Us.copy(n.ray).applyMatrix4(Bs); const o = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, c = new Le, h = new Le, u = new Le, d = new Le, p = this.isLineSegments ? 2 : 1; if (e.isBufferGeometry) { const i = e.index, a = e.attributes.position; if (null !== i) for (let e = Math.max(0, s.start), t = Math.min(i.count, s.start + s.count) - 1; e < t; e += p) { const s = i.getX(e), o = i.getX(e + 1); if (c.fromBufferAttribute(a, s), h.fromBufferAttribute(a, o), !(Us.distanceSqToSegment(c, h, d, u) > l)) { d.applyMatrix4(this.matrixWorld); const p = n.ray.origin.distanceTo(d); p < n.near || p > n.far || r.push({ distance: p, point: u.clone().applyMatrix4(this.matrixWorld), index: e, face: null, faceIndex: null, object: this }) } } else for (let e = Math.max(0, s.start), t = Math.min(a.count, s.start + s.count) - 1; e < t; e += p)if (c.fromBufferAttribute(a, e), h.fromBufferAttribute(a, e + 1), !(Us.distanceSqToSegment(c, h, d, u) > l)) { d.applyMatrix4(this.matrixWorld); const i = n.ray.origin.distanceTo(d); i < n.near || i > n.far || r.push({ distance: i, point: u.clone().applyMatrix4(this.matrixWorld), index: e, face: null, faceIndex: null, object: this }) } } else e.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } } updateMorphTargets() { const n = this.geometry; if (n.isBufferGeometry) { var e = n.morphAttributes, t = Object.keys(e); if (0 < t.length) { const n = e[t[0]]; if (void 0 !== n) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, t = n.length; e < t; e++) { var r = n[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[r] = e } } } } else { e = n.morphTargets; void 0 !== e && 0 < e.length && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } } Gs.prototype.isLine = !0; const ks = new Le, Vs = new Le; class Ws extends Gs { constructor(e, t) { super(e, t), this.type = "LineSegments" } computeLineDistances() { const e = this.geometry; if (e.isBufferGeometry) if (null === e.index) { const n = e.attributes.position, r = []; for (let e = 0, t = n.count; e < t; e += 2)ks.fromBufferAttribute(n, e), Vs.fromBufferAttribute(n, e + 1), r[e] = 0 === e ? 0 : r[e - 1], r[e + 1] = r[e] + ks.distanceTo(Vs); e.setAttribute("lineDistance", new V(r, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else e.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); return this } } Ws.prototype.isLineSegments = !0; class js extends Gs { constructor(e, t) { super(e, t), this.type = "LineLoop" } } js.prototype.isLineLoop = !0; class qs extends t { constructor(e) { super(), this.type = "PointsMaterial", this.color = new y(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this } } qs.prototype.isPointsMaterial = !0; const Xs = new Ce, Ys = new At, Zs = new xt, Js = new Le; class Ks extends u { constructor(e = new T, t = new qs) { super(), this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e) { return super.copy(e), this.material = e.material, this.geometry = e.geometry, this } raycast(n, r) { const e = this.geometry, i = this.matrixWorld, a = n.params.Points.threshold, s = e.drawRange; if (null === e.boundingSphere && e.computeBoundingSphere(), Zs.copy(e.boundingSphere), Zs.applyMatrix4(i), Zs.radius += a, !1 !== n.ray.intersectsSphere(Zs)) { Xs.copy(i).invert(), Ys.copy(n.ray).applyMatrix4(Xs); const o = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o; if (e.isBufferGeometry) { const a = e.index, o = e.attributes.position; if (null !== a) for (let e = Math.max(0, s.start), t = Math.min(a.count, s.start + s.count); e < t; e++) { const s = a.getX(e); Js.fromBufferAttribute(o, s), Qs(Js, s, l, i, n, r, this) } else for (let e = Math.max(0, s.start), t = Math.min(o.count, s.start + s.count); e < t; e++)Js.fromBufferAttribute(o, e), Qs(Js, e, l, i, n, r, this) } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } } updateMorphTargets() { const n = this.geometry; if (n.isBufferGeometry) { var e = n.morphAttributes, t = Object.keys(e); if (0 < t.length) { const n = e[t[0]]; if (void 0 !== n) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, t = n.length; e < t; e++) { var r = n[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[r] = e } } } } else { e = n.morphTargets; void 0 !== e && 0 < e.length && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } } function Qs(e, t, n, r, i, a, s) { var o = Ys.distanceSqToPoint(e); if (o < n) { const n = new Le; Ys.closestPointToPoint(e, n), n.applyMatrix4(r); e = i.ray.origin.distanceTo(n); e < i.near || e > i.far || a.push({ distance: e, distanceToRay: Math.sqrt(o), point: n, index: t, face: null, object: s }) } } Ks.prototype.isPoints = !0; class $s extends h { constructor(t, e, n, r, i, a, s, o, l) { super(t, e, n, r, i, a, s, o, l), this.format = void 0 !== s ? s : J, this.minFilter = void 0 !== a ? a : B, this.magFilter = void 0 !== i ? i : B, this.generateMipmaps = !1; const c = this; "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(function e() { c.needsUpdate = !0, t.requestVideoFrameCallback(e) }) } clone() { return new this.constructor(this.image).copy(this) } update() { var e = this.image; !1 == "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } } class eo extends h { constructor(e, t, n, r, i, a, s, o, l, c, h, u) { super(null, a, s, o, l, c, r, i, h, u), this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 } } eo.prototype.isCompressedTexture = $s.prototype.isVideoTexture = !0; class to extends h { constructor(e, t, n, r, i, a, s, o, l) { super(e, t, n, r, i, a, s, o, l), this.needsUpdate = !0 } } class no extends h { constructor(e, t, n, r, i, a, s, o, l, c) { if ((c = void 0 !== c ? c : K) !== K && c !== Q) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); super(null, r, i, a, s, o, c, n = void 0 === (n = void 0 === n && c === K ? X : n) && c === Q ? Z : n, l), this.image = { width: e, height: t }, this.magFilter = void 0 !== s ? s : Ae, this.minFilter = void 0 !== o ? o : Ae, this.flipY = !1, this.generateMipmaps = !1 } } no.prototype.isDepthTexture = to.prototype.isCanvasTexture = !0; class ro extends T { constructor(n = 1, r = 8, i = 0, a = 2 * Math.PI) { super(), this.type = "CircleGeometry", this.parameters = { radius: n, segments: r, thetaStart: i, thetaLength: a }, r = Math.max(3, r); const t = [], s = [], o = [], l = [], c = new Le, h = new k; s.push(0, 0, 0), o.push(0, 0, 1), l.push(.5, .5); for (let e = 0, t = 3; e <= r; e++, t += 3) { var u = i + e / r * a; c.x = n * Math.cos(u), c.y = n * Math.sin(u), s.push(c.x, c.y, c.z), o.push(0, 0, 1), h.x = (s[t] / n + 1) / 2, h.y = (s[t + 1] / n + 1) / 2, l.push(h.x, h.y) } for (let e = 1; e <= r; e++)t.push(e, e + 1, 0); this.setIndex(t), this.setAttribute("position", new V(s, 3)), this.setAttribute("normal", new V(o, 3)), this.setAttribute("uv", new V(l, 2)) } static fromJSON(e) { return new ro(e.radius, e.segments, e.thetaStart, e.thetaLength) } } class io extends T { constructor(c = 1, h = 1, r = 1, u = 8, i = 1, e = !1, d = 0, p = 2 * Math.PI) { super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: c, radiusBottom: h, height: r, radialSegments: u, heightSegments: i, openEnded: e, thetaStart: d, thetaLength: p }; const m = this, f = (u = Math.floor(u), i = Math.floor(i), []), g = [], v = [], y = []; let x = 0; const a = [], _ = r / 2; let b = 0; function t(t) { const n = x, r = new k, i = new Le; let a = 0; var s = !0 === t ? c : h, o = !0 === t ? 1 : -1; for (let e = 1; e <= u; e++)g.push(0, _ * o, 0), v.push(0, o, 0), y.push(.5, .5), x++; var l = x; for (let e = 0; e <= u; e++) { const h = e / u * p + d, t = Math.cos(h), n = Math.sin(h); i.x = s * n, i.y = _ * o, i.z = s * t, g.push(i.x, i.y, i.z), v.push(0, o, 0), r.x = .5 * t + .5, r.y = .5 * n * o + .5, y.push(r.x, r.y), x++ } for (let e = 0; e < u; e++) { const h = n + e, u = l + e; !0 === t ? f.push(u, u + 1, h) : f.push(u + 1, u, h), a += 3 } m.addGroup(b, a, !0 === t ? 1 : 2), b += a } { const o = new Le, l = new Le; let n = 0; var s = (h - c) / r; for (let e = 0; e <= i; e++) { const f = [], b = e / i, t = b * (h - c) + c; for (let e = 0; e <= u; e++) { const h = e / u, i = h * p + d, m = Math.sin(i), a = Math.cos(i); l.x = t * m, l.y = -b * r + _, l.z = t * a, g.push(l.x, l.y, l.z), o.set(m, s, a).normalize(), v.push(o.x, o.y, o.z), y.push(h, 1 - b), f.push(x++) } a.push(f) } for (let t = 0; t < u; t++)for (let e = 0; e < i; e++) { const r = a[e][t], u = a[e + 1][t], i = a[e + 1][t + 1], o = a[e][t + 1]; f.push(r, u, o), f.push(u, i, o), n += 6 } m.addGroup(b, n, 0), b += n } !1 === e && (0 < c && t(!0), 0 < h && t(!1)), this.setIndex(f), this.setAttribute("position", new V(g, 3)), this.setAttribute("normal", new V(v, 3)), this.setAttribute("uv", new V(y, 2)) } static fromJSON(e) { return new io(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class ao extends io { constructor(e = 1, t = 1, n = 8, r = 1, i = !1, a = 0, s = 2 * Math.PI) { super(0, e, t, n, r, i, a, s), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: n, heightSegments: r, openEnded: i, thetaStart: a, thetaLength: s } } static fromJSON(e) { return new ao(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class so extends T { constructor(n, t, e = 1, r = 0) { super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: n, indices: t, radius: e, detail: r }; const i = [], a = []; function s(e) { i.push(e.x, e.y, e.z) } function o(e, t) { e *= 3; t.x = n[0 + e], t.y = n[1 + e], t.z = n[2 + e] } function l(e, t, n, r) { r < 0 && 1 === e.x && (a[t] = e.x - 1), 0 === n.x && 0 === n.z && (a[t] = r / 2 / Math.PI + .5) } function c(e) { return Math.atan2(e.z, -e.x) } var h = r, u = new Le, d = new Le, p = new Le; for (let e = 0; e < t.length; e += 3) { o(t[e + 0], u), o(t[e + 1], d), o(t[e + 2], p); { m = void 0; f = void 0; g = void 0; v = void 0; var m = u; var f = d; var g = p; var v = h; const w = v + 1, T = []; for (let t = 0; t <= w; t++) { T[t] = []; const E = m.clone().lerp(g, t / w), s = f.clone().lerp(g, t / w), S = w - t; for (let e = 0; e <= S; e++)T[t][e] = 0 === e && t === w ? E : E.clone().lerp(s, e / S) } for (let t = 0; t < w; t++)for (let e = 0; e < 2 * (w - t) - 1; e++) { const g = Math.floor(e / 2); e % 2 == 0 ? (s(T[t][g + 1]), s(T[t + 1][g]), s(T[t][g])) : (s(T[t][g + 1]), s(T[t + 1][g + 1]), s(T[t + 1][g])) } } } { var O = e; const A = new Le; for (let e = 0; e < i.length; e += 3)A.x = i[e + 0], A.y = i[e + 1], A.z = i[e + 2], A.normalize().multiplyScalar(O), i[e + 0] = A.x, i[e + 1] = A.y, i[e + 2] = A.z } { const R = new Le; for (let e = 0; e < i.length; e += 3) { R.x = i[e + 0], R.y = i[e + 1], R.z = i[e + 2]; var F = c(R) / 2 / Math.PI + .5, y = (y = R, Math.atan2(-y.y, Math.sqrt(y.x * y.x + y.z * y.z)) / Math.PI + .5); a.push(F, 1 - y) } { const L = new Le, C = new Le, P = new Le, I = new Le, D = new k, N = new k, H = new k; for (let e = 0, t = 0; e < i.length; e += 9, t += 6) { L.set(i[e + 0], i[e + 1], i[e + 2]), C.set(i[e + 3], i[e + 4], i[e + 5]), P.set(i[e + 6], i[e + 7], i[e + 8]), D.set(a[t + 0], a[t + 1]), N.set(a[t + 2], a[t + 3]), H.set(a[t + 4], a[t + 5]), I.copy(L).add(C).add(P).divideScalar(3); var x = c(I); l(D, t + 0, L, x), l(N, t + 2, C, x), l(H, t + 4, P, x) } } for (let e = 0; e < a.length; e += 6) { var _ = a[e + 0], b = a[e + 2], M = a[e + 4], B = Math.max(_, b, M), U = Math.min(_, b, M); .9 < B && U < .1 && (_ < .2 && (a[e + 0] += 1), b < .2 && (a[e + 2] += 1), M < .2 && (a[e + 4] += 1)) } } this.setAttribute("position", new V(i, 3)), this.setAttribute("normal", new V(i.slice(), 3)), this.setAttribute("uv", new V(a, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals() } static fromJSON(e) { return new so(e.vertices, e.indices, e.radius, e.details) } } class oo extends so { constructor(e = 1, t = 0) { var n = (1 + Math.sqrt(5)) / 2, r = 1 / n; super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new oo(e.radius, e.detail) } } const lo = new Le, co = new Le, ho = new Le, uo = new g; class po extends T { constructor(e, t) { if (super(), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: t }, t = void 0 !== t ? t : 1, !0 === e.isGeometry) console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); else { const n = Math.cos(Ee * t), r = e.getIndex(), i = e.getAttribute("position"), a = (r || i).count, s = [0, 0, 0], o = ["a", "b", "c"], l = new Array(3), c = {}, h = []; for (let e = 0; e < a; e += 3) { r ? (s[0] = r.getX(e), s[1] = r.getX(e + 1), s[2] = r.getX(e + 2)) : (s[0] = e, s[1] = e + 1, s[2] = e + 2); const { a: t, b: a, c: u } = uo; if (t.fromBufferAttribute(i, s[0]), a.fromBufferAttribute(i, s[1]), u.fromBufferAttribute(i, s[2]), uo.getNormal(ho), l[0] = `${t.x},${t.y},` + t.z, l[1] = `${a.x},${a.y},` + a.z, l[2] = `${u.x},${u.y},` + u.z, l[0] !== l[1] && l[1] !== l[2] && l[2] !== l[0]) for (let e = 0; e < 3; e++) { const t = (e + 1) % 3, r = l[e], i = l[t], a = uo[o[e]], d = uo[o[t]], p = r + "_" + i, m = i + "_" + r; m in c && c[m] ? (ho.dot(c[m].normal) <= n && (h.push(a.x, a.y, a.z), h.push(d.x, d.y, d.z)), c[m] = null) : p in c || (c[p] = { index0: s[e], index1: s[t], normal: ho.clone() }) } } for (const e in c) if (c[e]) { const { index0: t, index1: n } = c[e]; lo.fromBufferAttribute(i, t), co.fromBufferAttribute(i, n), h.push(lo.x, lo.y, lo.z), h.push(co.x, co.y, co.z) } this.setAttribute("position", new V(h, 3)) } } } class mo { constructor() { this.type = "Curve", this.arcLengthDivisions = 200 } getPoint() { return console.warn("THREE.Curve: .getPoint() not implemented."), null } getPointAt(e, t) { e = this.getUtoTmapping(e); return this.getPoint(e, t) } getPoints(t = 5) { const n = []; for (let e = 0; e <= t; e++)n.push(this.getPoint(e / t)); return n } getSpacedPoints(t = 5) { const n = []; for (let e = 0; e <= t; e++)n.push(this.getPointAt(e / t)); return n } getLength() { var e = this.getLengths(); return e[e.length - 1] } getLengths(t = this.arcLengthDivisions) { if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const n = []; let r, i = this.getPoint(0), a = 0; n.push(0); for (let e = 1; e <= t; e++)r = this.getPoint(e / t), a += r.distanceTo(i), n.push(a), i = r; return this.cacheArcLengths = n } updateArcLengths() { this.needsUpdate = !0, this.getLengths() } getUtoTmapping(e, t) { var n = this.getLengths(); let r = 0; var i = n.length, a = t || e * n[i - 1]; let s, o = 0, l = i - 1; for (; o <= l;)if ((s = n[r = Math.floor(o + (l - o) / 2)] - a) < 0) o = r + 1; else { if (!(0 < s)) { l = r; break } l = r - 1 } if (n[r = l] === a) return r / (i - 1); t = n[r]; return (r + (a - t) / (n[r + 1] - t)) / (i - 1) } getTangent(e, t) { let n = e - 1e-4, r = e + 1e-4; n < 0 && (n = 0), 1 < r && (r = 1); const i = this.getPoint(n), a = this.getPoint(r), s = t || new (i.isVector2 ? k : Le); return s.copy(a).sub(i).normalize(), s } getTangentAt(e, t) { e = this.getUtoTmapping(e); return this.getTangent(e, t) } computeFrenetFrames(n, e) { const t = new Le, r = [], i = [], a = [], s = new Le, o = new Ce; for (let e = 0; e <= n; e++) { const t = e / n; r[e] = this.getTangentAt(t, new Le), r[e].normalize() } i[0] = new Le, a[0] = new Le; let l = Number.MAX_VALUE; var c = Math.abs(r[0].x), h = Math.abs(r[0].y), u = Math.abs(r[0].z); c <= l && (l = c, t.set(1, 0, 0)), h <= l && (l = h, t.set(0, 1, 0)), u <= l && t.set(0, 0, 1), s.crossVectors(r[0], t).normalize(), i[0].crossVectors(r[0], s), a[0].crossVectors(r[0], i[0]); for (let e = 1; e <= n; e++) { if (i[e] = i[e - 1].clone(), a[e] = a[e - 1].clone(), s.crossVectors(r[e - 1], r[e]), s.length() > Number.EPSILON) { s.normalize(); const n = Math.acos(m(r[e - 1].dot(r[e]), -1, 1)); i[e].applyMatrix4(o.makeRotationAxis(s, n)) } a[e].crossVectors(r[e], i[e]) } if (!0 === e) { let t = Math.acos(m(i[0].dot(i[n]), -1, 1)); t /= n, 0 < r[0].dot(s.crossVectors(i[0], i[n])) && (t = -t); for (let e = 1; e <= n; e++)i[e].applyMatrix4(o.makeRotationAxis(r[e], t * e)), a[e].crossVectors(r[e], i[e]) } return { tangents: r, normals: i, binormals: a } } clone() { return (new this.constructor).copy(this) } copy(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } toJSON() { const e = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e } fromJSON(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } } class fo extends mo { constructor(e = 0, t = 0, n = 1, r = 1, i = 0, a = 2 * Math.PI, s = !1, o = 0) { super(), this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = a, this.aClockwise = s, this.aRotation = o } getPoint(e, t) { const n = t || new k, r = 2 * Math.PI; let i = this.aEndAngle - this.aStartAngle; for (t = Math.abs(i) < Number.EPSILON; i < 0;)i += r; for (; i > r;)i -= r; i < Number.EPSILON && (i = t ? 0 : r), !0 !== this.aClockwise || t || (i === r ? i = -r : i -= r); t = this.aStartAngle + e * i; let a = this.aX + this.xRadius * Math.cos(t), s = this.aY + this.yRadius * Math.sin(t); if (0 !== this.aRotation) { const e = Math.cos(this.aRotation), t = Math.sin(this.aRotation), n = a - this.aX, r = s - this.aY; a = n * e - r * t + this.aX, s = n * t + r * e + this.aY } return n.set(a, s) } copy(e) { return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } toJSON() { const e = super.toJSON(); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e } fromJSON(e) { return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } } fo.prototype.isEllipseCurve = !0; class go extends fo { constructor(e, t, n, r, i, a) { super(e, t, n, n, r, i, a), this.type = "ArcCurve" } } function vo() { let i = 0, a = 0, s = 0, o = 0; function l(e, t, n, r) { i = e, a = n, s = -3 * e + 3 * t - 2 * n - r, o = 2 * e - 2 * t + n + r } return { initCatmullRom: function (e, t, n, r, i) { l(t, n, i * (n - e), i * (r - t)) }, initNonuniformCatmullRom: function (e, t, n, r, i, a, s) { e = (t - e) / i - (n - e) / (i + a) + (n - t) / a, i = (n - t) / a - (r - t) / (a + s) + (r - n) / s; l(t, n, e *= a, i *= a) }, calc: function (e) { var t = e * e; return i + a * e + s * t + o * (t * e) } } } go.prototype.isArcCurve = !0; const yo = new Le, xo = new vo, _o = new vo, bo = new vo; class Mo extends mo { constructor(e = [], t = !1, n = "centripetal", r = .5) { super(), this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = r } getPoint(r, e = new Le) { const t = e, n = this.points, i = n.length, a = (i - (this.closed ? 0 : 1)) * r; let s, o, l = Math.floor(a), c = a - l; this.closed ? l += 0 < l ? 0 : (Math.floor(Math.abs(l) / i) + 1) * i : 0 === c && l === i - 1 && (l = i - 2, c = 1), s = this.closed || 0 < l ? n[(l - 1) % i] : (yo.subVectors(n[0], n[1]).add(n[0]), yo); const h = n[l % i], u = n[(l + 1) % i]; if (o = this.closed || l + 2 < i ? n[(l + 2) % i] : (yo.subVectors(n[i - 1], n[i - 2]).add(n[i - 1]), yo), "centripetal" === this.curveType || "chordal" === this.curveType) { const r = "chordal" === this.curveType ? .5 : .25; let e = Math.pow(s.distanceToSquared(h), r), t = Math.pow(h.distanceToSquared(u), r), n = Math.pow(u.distanceToSquared(o), r); t < 1e-4 && (t = 1), e < 1e-4 && (e = t), n < 1e-4 && (n = t), xo.initNonuniformCatmullRom(s.x, h.x, u.x, o.x, e, t, n), _o.initNonuniformCatmullRom(s.y, h.y, u.y, o.y, e, t, n), bo.initNonuniformCatmullRom(s.z, h.z, u.z, o.z, e, t, n) } else "catmullrom" === this.curveType && (xo.initCatmullRom(s.x, h.x, u.x, o.x, this.tension), _o.initCatmullRom(s.y, h.y, u.y, o.y, this.tension), bo.initCatmullRom(s.z, h.z, u.z, o.z, this.tension)); return t.set(xo.calc(c), _o.calc(c), bo.calc(c)), t } copy(n) { super.copy(n), this.points = []; for (let e = 0, t = n.points.length; e < t; e++) { const r = n.points[e]; this.points.push(r.clone()) } return this.closed = n.closed, this.curveType = n.curveType, this.tension = n.tension, this } toJSON() { const n = super.toJSON(); n.points = []; for (let e = 0, t = this.points.length; e < t; e++) { const r = this.points[e]; n.points.push(r.toArray()) } return n.closed = this.closed, n.curveType = this.curveType, n.tension = this.tension, n } fromJSON(n) { super.fromJSON(n), this.points = []; for (let e = 0, t = n.points.length; e < t; e++) { var r = n.points[e]; this.points.push((new Le).fromArray(r)) } return this.closed = n.closed, this.curveType = n.curveType, this.tension = n.tension, this } } function wo(e, t, n, r, i) { var t = .5 * (r - t), i = .5 * (i - n), a = e * e; return e * a * (2 * n - 2 * r + t + i) + (-3 * n + 3 * r - 2 * t - i) * a + t * e + n } function To(e, t, n, r) { return (i = 1 - e) * i * t + 2 * (1 - e) * e * n + e * e * r; var i } function Eo(e, t, n, r, i) { return (a = 1 - e) * a * a * t + 3 * (a = 1 - e) * a * e * n + 3 * (1 - e) * e * e * r + e * e * e * i; var a } class So extends mo { constructor(e = new k, t = new k, n = new k, r = new k) { super(), this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r } getPoint(e, t = new k) { const n = t, r = this.v0, i = this.v1, a = this.v2, s = this.v3; return n.set(Eo(e, r.x, i.x, a.x, s.x), Eo(e, r.y, i.y, a.y, s.y)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } So.prototype.isCubicBezierCurve = Mo.prototype.isCatmullRomCurve3 = !0; class Ao extends mo { constructor(e = new Le, t = new Le, n = new Le, r = new Le) { super(), this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r } getPoint(e, t = new Le) { const n = t, r = this.v0, i = this.v1, a = this.v2, s = this.v3; return n.set(Eo(e, r.x, i.x, a.x, s.x), Eo(e, r.y, i.y, a.y, s.y), Eo(e, r.z, i.z, a.z, s.z)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class Ro extends mo { constructor(e = new k, t = new k) { super(), this.type = "LineCurve", this.v1 = e, this.v2 = t } getPoint(e, t = new k) { const n = t; return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t) { const n = t || new k; return n.copy(this.v2).sub(this.v1).normalize(), n } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } Ro.prototype.isLineCurve = Ao.prototype.isCubicBezierCurve3 = !0; class Lo extends mo { constructor(e = new Le, t = new Le) { super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = e, this.v2 = t } getPoint(e, t = new Le) { const n = t; return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n } getPointAt(e, t) { return this.getPoint(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class Co extends mo { constructor(e = new k, t = new k, n = new k) { super(), this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n } getPoint(e, t = new k) { const n = t, r = this.v0, i = this.v1, a = this.v2; return n.set(To(e, r.x, i.x, a.x), To(e, r.y, i.y, a.y)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } Co.prototype.isQuadraticBezierCurve = !0; class Po extends mo { constructor(e = new Le, t = new Le, n = new Le) { super(), this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n } getPoint(e, t = new Le) { const n = t, r = this.v0, i = this.v1, a = this.v2; return n.set(To(e, r.x, i.x, a.x), To(e, r.y, i.y, a.y), To(e, r.z, i.z, a.z)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class Io extends mo { constructor(e = []) { super(), this.type = "SplineCurve", this.points = e } getPoint(e, t = new k) { const n = t, r = this.points, i = (r.length - 1) * e, a = Math.floor(i), s = i - a, o = r[0 === a ? a : a - 1], l = r[a], c = r[a > r.length - 2 ? r.length - 1 : a + 1], h = r[a > r.length - 3 ? r.length - 1 : a + 2]; return n.set(wo(s, o.x, l.x, c.x, h.x), wo(s, o.y, l.y, c.y, h.y)), n } copy(n) { super.copy(n), this.points = []; for (let e = 0, t = n.points.length; e < t; e++) { const r = n.points[e]; this.points.push(r.clone()) } return this } toJSON() { const n = super.toJSON(); n.points = []; for (let e = 0, t = this.points.length; e < t; e++) { const r = this.points[e]; n.points.push(r.toArray()) } return n } fromJSON(n) { super.fromJSON(n), this.points = []; for (let e = 0, t = n.points.length; e < t; e++) { var r = n.points[e]; this.points.push((new k).fromArray(r)) } return this } } Io.prototype.isSplineCurve = Po.prototype.isQuadraticBezierCurve3 = !0; var Do = Object.freeze({ __proto__: null, ArcCurve: go, CatmullRomCurve3: Mo, CubicBezierCurve: So, CubicBezierCurve3: Ao, EllipseCurve: fo, LineCurve: Ro, LineCurve3: Lo, QuadraticBezierCurve: Co, QuadraticBezierCurve3: Po, SplineCurve: Io }); function No(t, e, n = 2) { var r = e && e.length, i = r ? e[0] * n : t.length; let a = Ho(t, 0, i, n, !0); var s = []; if (!a || a.next === a.prev) return s; let o, l, c, h, u, d, p; if (r && (a = function (e, t, n, r) { const i = []; let a, s, o, l, c; for (a = 0, s = t.length; a < s; a++)o = t[a] * r, l = a < s - 1 ? t[a + 1] * r : e.length, (c = Ho(e, o, l, r, !1)) === c.next && (c.steiner = !0), i.push(function (e) { let t = e, n = e; for (; (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next, t !== e;); return n }(c)); for (i.sort(Bo), a = 0; a < i.length; a++)h = i[a], (u = function (e, t) { let n = t; var r = e.x, i = e.y; let a, s = -1 / 0; do { if (i <= n.y && i >= n.next.y && n.next.y !== n.y) { const e = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (e <= r && e > s) { if ((s = e) === r) { if (i === n.y) return n; if (i === n.next.y) return n.next } a = n.x < n.next.x ? n : n.next } } } while ((n = n.next) !== t); if (!a) return null; if (r === s) return a; var o, l, c = a, h = a.x, u = a.y; let d, p = 1 / 0; for (n = a; r >= n.x && n.x >= h && r !== n.x && zo(i < u ? r : s, i, h, u, i < u ? s : r, i, n.x, n.y) && (d = Math.abs(i - n.y) / (r - n.x), jo(n, e) && (d < p || d === p && (n.x > a.x || n.x === a.x && (o = a, l = n, _(o.prev, o, l.prev) < 0 && _(l.next, o, o.next) < 0))) && (a = n, p = d)), (n = n.next) !== c;); return a }(h, u = n)) && (h = qo(u, h), Oo(u, u.next), Oo(h, h.next)), n = Oo(n, n.next); var h, u; return n }(t, e, a, n)), t.length > 80 * n) { o = c = t[0], l = h = t[1]; for (let e = n; e < i; e += n)u = t[e], d = t[e + 1], u < o && (o = u), d < l && (l = d), u > c && (c = u), d > h && (h = d); p = 0 !== (p = Math.max(c - o, h - l)) ? 1 / p : 0 } return Fo(a, s, n, o, l, p), s } function Ho(e, s, t, n, r) { let i, a; if (r === 0 < function (n, r, i) { let a = 0; for (let e = s, t = r - i; e < r; e += i)a += (n[t] - n[e]) * (n[e + 1] + n[t + 1]), t = e; return a }(e, t, n)) for (i = s; i < t; i += n)a = Xo(i, e[i], e[i + 1], a); else for (i = t - n; i >= s; i -= n)a = Xo(i, e[i], e[i + 1], a); return a && Go(a, a.next) && (Yo(a), a = a.next), a } function Oo(e, t) { if (!e) return e; t = t || e; let n, r = e; do { if (n = !1, r.steiner || !Go(r, r.next) && 0 !== _(r.prev, r, r.next)) r = r.next; else { if (Yo(r), (r = t = r.prev) === r.next) break; n = !0 } } while (n || r !== t); return t } function Fo(r, i, a, s, o, l, c) { if (r) { if (!c && l) { var h = r; var u = s; var d = o; var p = l; let c = h; for (; null === c.z && (c.z = Uo(c.x, c.y, u, d, p)), c.prevZ = c.prev, c.nextZ = c.next, (c = c.next) !== h;); c.prevZ.nextZ = null, c.prevZ = null; { var m = c; let e, t, n, r, i, a, s, o, l = 1; do { for (t = m, m = null, i = null, a = 0; t;) { for (a++, n = t, s = 0, e = 0; e < l && (s++, n = n.nextZ); e++); for (o = l; 0 < s || 0 < o && n;)0 !== s && (0 === o || !n || t.z <= n.z) ? (t = (r = t).nextZ, s--) : (n = (r = n).nextZ, o--), i ? i.nextZ = r : m = r, r.prevZ = i, i = r; t = n } } while (i.nextZ = null, l *= 2, 1 < a) } } let e, t, n = r; for (; r.prev !== r.next;)if (e = r.prev, t = r.next, l ? function (e, t, n, r) { var i = e.prev, a = e, s = e.next; if (0 <= _(i, a, s)) return; var o = (i.x < a.x ? i.x < s.x ? i : s : a.x < s.x ? a : s).x, l = (i.y < a.y ? i.y < s.y ? i : s : a.y < s.y ? a : s).y, c = (i.x > a.x ? i.x > s.x ? i : s : a.x > s.x ? a : s).x, h = (i.y > a.y ? i.y > s.y ? i : s : a.y > s.y ? a : s).y, u = Uo(o, l, t, n, r), d = Uo(c, h, t, n, r); let p = e.prevZ, m = e.nextZ; for (; p && p.z >= u && m && m.z <= d;) { if (p !== e.prev && p !== e.next && zo(i.x, i.y, a.x, a.y, s.x, s.y, p.x, p.y) && 0 <= _(p.prev, p, p.next)) return; if (p = p.prevZ, m !== e.prev && m !== e.next && zo(i.x, i.y, a.x, a.y, s.x, s.y, m.x, m.y) && 0 <= _(m.prev, m, m.next)) return; m = m.nextZ } for (; p && p.z >= u;) { if (p !== e.prev && p !== e.next && zo(i.x, i.y, a.x, a.y, s.x, s.y, p.x, p.y) && 0 <= _(p.prev, p, p.next)) return; p = p.prevZ } for (; m && m.z <= d;) { if (m !== e.prev && m !== e.next && zo(i.x, i.y, a.x, a.y, s.x, s.y, m.x, m.y) && 0 <= _(m.prev, m, m.next)) return; m = m.nextZ } return 1 }(r, s, o, l) : function (e) { var t = e.prev, n = e, r = e.next; if (0 <= _(t, n, r)) return; let i = e.next.next; for (; i !== e.prev;) { if (zo(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) && 0 <= _(i.prev, i, i.next)) return; i = i.next } return 1 }(r)) i.push(e.i / a), i.push(r.i / a), i.push(t.i / a), Yo(r), r = t.next, n = t.next; else if ((r = t) === n) { c ? 1 === c ? Fo(r = function (e, t, n) { let r = e; do { var i = r.prev, a = r.next.next; !Go(i, a) && ko(i, r, r.next, a) && jo(i, a) && jo(a, i) && (t.push(i.i / n), t.push(r.i / n), t.push(a.i / n), Yo(r), Yo(r.next), r = e = a), r = r.next } while (r !== e); return Oo(r) }(Oo(r), i, a), i, a, s, o, l, 2) : 2 === c && function (e, t, n, r, i, a) { let s = e; do { let e = s.next.next; for (; e !== s.prev;) { var o; if (s.i !== e.i && function (e, t) { return e.next.i !== t.i && e.prev.i !== t.i && !function (e, t) { let n = e; do { if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && ko(n, n.next, e, t)) return 1 } while ((n = n.next) !== e) }(e, t) && (jo(e, t) && jo(t, e) && function (e, t) { let n = e, r = !1; for (var i = (e.x + t.x) / 2, a = (e.y + t.y) / 2; n.y > a != n.next.y > a && n.next.y !== n.y && i < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (r = !r), (n = n.next) !== e;); return r }(e, t) && (_(e.prev, e, t.prev) || _(e, t.prev, t)) || Go(e, t) && 0 < _(e.prev, e, e.next) && 0 < _(t.prev, t, t.next)) }(s, e)) return o = qo(s, e), s = Oo(s, s.next), o = Oo(o, o.next), Fo(s, t, n, r, i, a), Fo(o, t, n, r, i, a); e = e.next } } while (s = s.next, s !== e) }(r, i, a, s, o, l) : Fo(Oo(r), i, a, s, o, l, 1); break } } } function Bo(e, t) { return e.x - t.x } function Uo(e, t, n, r, i) { return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1 } function zo(e, t, n, r, i, a, s, o) { return 0 <= (i - s) * (t - o) - (e - s) * (a - o) && 0 <= (e - s) * (r - o) - (n - s) * (t - o) && 0 <= (n - s) * (a - o) - (i - s) * (r - o) } function _(e, t, n) { return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y) } function Go(e, t) { return e.x === t.x && e.y === t.y } function ko(e, t, n, r) { var i = Wo(_(e, t, n)), a = Wo(_(e, t, r)), s = Wo(_(n, r, e)), o = Wo(_(n, r, t)); return i !== a && s !== o || 0 === i && Vo(e, n, t) || 0 === a && Vo(e, r, t) || 0 === s && Vo(n, e, r) || 0 === o && Vo(n, t, r) } function Vo(e, t, n) { return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y) } function Wo(e) { return 0 < e ? 1 : e < 0 ? -1 : 0 } function jo(e, t) { return _(e.prev, e, e.next) < 0 ? 0 <= _(e, t, e.next) && 0 <= _(e, e.prev, t) : _(e, t, e.prev) < 0 || _(e, e.next, t) < 0 } function qo(e, t) { const n = new Zo(e.i, e.x, e.y), r = new Zo(t.i, t.x, t.y), i = e.next, a = t.prev; return (e.next = t).prev = e, (n.next = i).prev = n, (r.next = n).prev = r, (a.next = r).prev = a, r } function Xo(e, t, n, r) { const i = new Zo(e, t, n); return r ? (i.next = r.next, (i.prev = r).next.prev = i, r.next = i) : (i.prev = i).next = i, i } function Yo(e) { e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ) } function Zo(e, t, n) { this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } class Jo { static area(n) { var r = n.length; let i = 0; for (let e = r - 1, t = 0; t < r; e = t++)i += n[e].x * n[t].y - n[t].x * n[e].y; return .5 * i } static isClockWise(e) { return Jo.area(e) < 0 } static triangulateShape(e, t) { const n = [], r = [], i = []; Ko(e), Qo(n, e); let a = e.length; t.forEach(Ko); for (let e = 0; e < t.length; e++)r.push(a), a += t[e].length, Qo(n, t[e]); const s = No(n, r); for (let e = 0; e < s.length; e += 3)i.push(s.slice(e, e + 3)); return i } } function Ko(e) { var t = e.length; 2 < t && e[t - 1].equals(e[0]) && e.pop() } function Qo(t, n) { for (let e = 0; e < n.length; e++)t.push(n[e].x), t.push(n[e].y) } class $o extends T { constructor(n, B) { super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: n, options: B }, n = Array.isArray(n) ? n : [n]; const U = this, z = [], G = []; for (let e = 0, t = n.length; e < t; e++)!function (e) { const r = [], O = void 0 !== B.curveSegments ? B.curveSegments : 12, u = void 0 !== B.steps ? B.steps : 1; let n = void 0 !== B.depth ? B.depth : 100, i = void 0 === B.bevelEnabled || B.bevelEnabled, t = void 0 !== B.bevelThickness ? B.bevelThickness : 6, a = void 0 !== B.bevelSize ? B.bevelSize : t - 2, s = void 0 !== B.bevelOffset ? B.bevelOffset : 0, d = void 0 !== B.bevelSegments ? B.bevelSegments : 3; const o = B.extrudePath, p = void 0 !== B.UVGenerator ? B.UVGenerator : el; void 0 !== B.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), n = B.amount); let l, c, h, m, f, g = !1; o && (l = o.getSpacedPoints(u), g = !0, i = !1, c = o.computeFrenetFrames(u, !1), h = new Le, m = new Le, f = new Le), i || (d = 0, t = 0, a = 0, s = 0); e = e.extractPoints(O); let v = e.shape; const y = e.holes; if (!Jo.isClockWise(v)) { v = v.reverse(); for (let e = 0, t = y.length; e < t; e++) { const B = y[e]; Jo.isClockWise(B) && (y[e] = B.reverse()) } } const x = Jo.triangulateShape(v, y), _ = v; for (let e = 0, t = y.length; e < t; e++) { const B = y[e]; v = v.concat(B) } function b(e, t, n) { return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e) } const M = v.length, w = x.length; function T(e, t, n) { let r, i, a; const s = e.x - t.x, o = e.y - t.y, l = n.x - e.x, c = n.y - e.y, h = s * s + o * o, u = s * c - o * l; if (Math.abs(u) > Number.EPSILON) { const u = Math.sqrt(h), d = Math.sqrt(l * l + c * c), p = t.x - o / u, m = t.y + s / u, f = ((n.x - c / d - p) * c - (n.y + l / d - m) * l) / (s * c - o * l); r = p + s * f - e.x, i = m + o * f - e.y; t = r * r + i * i; if (t <= 2) return new k(r, i); a = Math.sqrt(t / 2) } else { let e = !1; s > Number.EPSILON ? l > Number.EPSILON && (e = !0) : s < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(o) === Math.sign(c) && (e = !0), a = e ? (r = -o, i = s, Math.sqrt(h)) : (r = s, i = o, Math.sqrt(h / 2)) } return new k(r / a, i / a) } const E = []; for (let e = 0, t = _.length, n = t - 1, r = e + 1; e < t; e++, n++, r++)n === t && (n = 0), r === t && (r = 0), E[e] = T(_[e], _[n], _[r]); const S = []; let A, R = E.concat(); for (let e = 0, t = y.length; e < t; e++) { const B = y[e]; A = []; for (let e = 0, t = B.length, n = t - 1, r = e + 1; e < t; e++, n++, r++)n === t && (n = 0), r === t && (r = 0), A[e] = T(B[e], B[n], B[r]); S.push(A), R = R.concat(A) } for (let e = 0; e < d; e++) { const B = e / d, U = t * Math.cos(B * Math.PI / 2), z = a * Math.sin(B * Math.PI / 2) + s; for (let e = 0, t = _.length; e < t; e++) { const B = b(_[e], E[e], z); C(B.x, B.y, -U) } for (let e = 0, t = y.length; e < t; e++) { const B = y[e]; A = S[e]; for (let e = 0, t = B.length; e < t; e++) { const G = b(B[e], A[e], z); C(G.x, G.y, -U) } } } var L = a + s; for (let e = 0; e < M; e++) { const B = i ? b(v[e], R[e], L) : v[e]; g ? (m.copy(c.normals[0]).multiplyScalar(B.x), h.copy(c.binormals[0]).multiplyScalar(B.y), f.copy(l[0]).add(m).add(h), C(f.x, f.y, f.z)) : C(B.x, B.y, 0) } for (let t = 1; t <= u; t++)for (let e = 0; e < M; e++) { const U = i ? b(v[e], R[e], L) : v[e]; g ? (m.copy(c.normals[t]).multiplyScalar(U.x), h.copy(c.binormals[t]).multiplyScalar(U.y), f.copy(l[t]).add(m).add(h), C(f.x, f.y, f.z)) : C(U.x, U.y, n / u * t) } for (let e = d - 1; 0 <= e; e--) { const B = e / d, U = t * Math.cos(B * Math.PI / 2), z = a * Math.sin(B * Math.PI / 2) + s; for (let e = 0, t = _.length; e < t; e++) { const B = b(_[e], E[e], z); C(B.x, B.y, n + U) } for (let e = 0, t = y.length; e < t; e++) { const B = y[e]; A = S[e]; for (let e = 0, t = B.length; e < t; e++) { const G = b(B[e], A[e], z); g ? C(G.x, G.y + l[u - 1].y, l[u - 1].x + U) : C(G.x, G.y, n + U) } } } function F(e, r) { let i = e.length; for (; 0 <= --i;) { var a = i; let n = i - 1; n < 0 && (n = e.length - 1); for (let e = 0, t = u + 2 * d; e < t; e++) { const i = M * e, h = M * (e + 1); o = s = c = l = o = s = void 0; var s = r + a + i, o = r + n + i, l = r + n + h, c = r + a + h; I(s), I(o), I(c), I(o), I(l), I(c), s = z.length / 3, D((o = p.generateSideWallUV(U, z, s - 6, s - 3, s - 2, s - 1))[0]), D(o[1]), D(o[3]), D(o[1]), D(o[2]), D(o[3]) } } } function C(e, t, n) { r.push(e), r.push(t), r.push(n) } function P(e, t, n) { I(e), I(t), I(n); e = z.length / 3, t = p.generateTopUV(U, z, e - 3, e - 2, e - 1); D(t[0]), D(t[1]), D(t[2]) } function I(e) { z.push(r[3 * e + 0]), z.push(r[3 * e + 1]), z.push(r[3 * e + 2]) } function D(e) { G.push(e.x), G.push(e.y) } { e = z.length / 3; if (i) { let e = 0, t = 0 * M; for (let e = 0; e < w; e++) { const U = x[e]; P(U[2] + t, U[1] + t, U[0] + t) } e = u + 2 * d, t = M * e; for (let e = 0; e < w; e++) { const U = x[e]; P(U[0] + t, U[1] + t, U[2] + t) } } else { for (let e = 0; e < w; e++) { var N = x[e]; P(N[2], N[1], N[0]) } for (let e = 0; e < w; e++) { var H = x[e]; P(H[0] + M * u, H[1] + M * u, H[2] + M * u) } } U.addGroup(e, z.length / 3 - e, 0) } { e = z.length / 3; let n = 0; F(_, n), n += _.length; for (let e = 0, t = y.length; e < t; e++) { const U = y[e]; F(U, n), n += U.length } U.addGroup(e, z.length / 3 - e, 1) } }(n[e]); this.setAttribute("position", new V(z, 3)), this.setAttribute("uv", new V(G, 2)), this.computeVertexNormals() } toJSON() { var e = super.toJSON(), n = this.parameters.shapes, t = this.parameters.options, r = e; if (r.shapes = [], Array.isArray(n)) for (let e = 0, t = n.length; e < t; e++) { var i = n[e]; r.shapes.push(i.uuid) } else r.shapes.push(n.uuid); return void 0 !== t.extrudePath && (r.options.extrudePath = t.extrudePath.toJSON()), r } static fromJSON(n, r) { const i = []; for (let e = 0, t = n.shapes.length; e < t; e++) { var a = r[n.shapes[e]]; i.push(a) } var e = n.options.extrudePath; return void 0 !== e && (n.options.extrudePath = (new Do[e.type]).fromJSON(e)), new $o(i, n.options) } } const el = { generateTopUV: function (e, t, n, r, i) { var a = t[3 * n], n = t[3 * n + 1], s = t[3 * r], r = t[3 * r + 1], o = t[3 * i], t = t[3 * i + 1]; return [new k(a, n), new k(s, r), new k(o, t)] }, generateSideWallUV: function (e, t, n, r, i, a) { var s = t[3 * n], o = t[3 * n + 1], n = t[3 * n + 2], l = t[3 * r], c = t[3 * r + 1], r = t[3 * r + 2], h = t[3 * i], u = t[3 * i + 1], i = t[3 * i + 2], d = t[3 * a], p = t[3 * a + 1], t = t[3 * a + 2]; return Math.abs(o - c) < Math.abs(s - l) ? [new k(s, 1 - n), new k(l, 1 - r), new k(h, 1 - i), new k(d, 1 - t)] : [new k(o, 1 - n), new k(c, 1 - r), new k(u, 1 - i), new k(p, 1 - t)] } }; class tl extends so { constructor(e = 1, t = 0) { var n = (1 + Math.sqrt(5)) / 2; super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new tl(e.radius, e.detail) } } class nl extends T { constructor(n, r = 12, i = 0, a = 2 * Math.PI) { super(), this.type = "LatheGeometry", this.parameters = { points: n, segments: r, phiStart: i, phiLength: a }, r = Math.floor(r), a = m(a, 0, 2 * Math.PI); const s = [], o = [], l = [], c = 1 / r, h = new Le, u = new k; for (let t = 0; t <= r; t++) { var e = i + t * c * a, d = Math.sin(e), p = Math.cos(e); for (let e = 0; e <= n.length - 1; e++)h.x = n[e].x * d, h.y = n[e].y, h.z = n[e].x * p, o.push(h.x, h.y, h.z), u.x = t / r, u.y = e / (n.length - 1), l.push(u.x, u.y) } for (let t = 0; t < r; t++)for (let e = 0; e < n.length - 1; e++) { const a = e + t * n.length, o = a, l = a + n.length, c = a + n.length + 1, h = a + 1; s.push(o, l, h), s.push(l, c, h) } if (this.setIndex(s), this.setAttribute("position", new V(o, 3)), this.setAttribute("uv", new V(l, 2)), this.computeVertexNormals(), a === 2 * Math.PI) { const i = this.attributes.normal.array, a = new Le, s = new Le, o = new Le, l = r * n.length * 3; for (let e = 0, t = 0; e < n.length; e++, t += 3)a.x = i[t + 0], a.y = i[t + 1], a.z = i[t + 2], s.x = i[l + t + 0], s.y = i[l + t + 1], s.z = i[l + t + 2], o.addVectors(a, s).normalize(), i[t + 0] = i[l + t + 0] = o.x, i[t + 1] = i[l + t + 1] = o.y, i[t + 2] = i[l + t + 2] = o.z } } static fromJSON(e) { return new nl(e.points, e.segments, e.phiStart, e.phiLength) } } class rl extends so { constructor(e = 1, t = 0) { super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new rl(e.radius, e.detail) } } class il extends T { constructor(t, n, r) { super(), this.type = "ParametricGeometry", this.parameters = { func: t, slices: n, stacks: r }; const i = [], a = [], s = [], o = [], l = new Le, c = new Le, h = new Le, u = new Le, d = new Le, p = (t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."), n + 1); for (let e = 0; e <= r; e++) { const p = e / r; for (let e = 0; e <= n; e++) { const i = e / n; t(i, p, c), a.push(c.x, c.y, c.z), 0 <= i - 1e-5 ? (t(i - 1e-5, p, h), u.subVectors(c, h)) : (t(1e-5 + i, p, h), u.subVectors(h, c)), 0 <= p - 1e-5 ? (t(i, p - 1e-5, h), d.subVectors(c, h)) : (t(i, 1e-5 + p, h), d.subVectors(h, c)), l.crossVectors(u, d).normalize(), s.push(l.x, l.y, l.z), o.push(i, p) } } for (let t = 0; t < r; t++)for (let e = 0; e < n; e++) { const n = t * p + e, a = t * p + e + 1, s = (t + 1) * p + e + 1, o = (t + 1) * p + e; i.push(n, a, o), i.push(a, s, o) } this.setIndex(i), this.setAttribute("position", new V(a, 3)), this.setAttribute("normal", new V(s, 3)), this.setAttribute("uv", new V(o, 2)) } } class al extends T { constructor(e = .5, t = 1, n = 8, r = 1, i = 0, a = 2 * Math.PI) { super(), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: n, phiSegments: r, thetaStart: i, thetaLength: a }, n = Math.max(3, n); const s = [], o = [], l = [], c = []; let h = e; const u = (t - e) / (r = Math.max(1, r)), d = new Le, p = new k; for (let e = 0; e <= r; e++) { for (let e = 0; e <= n; e++) { const r = i + e / n * a; d.x = h * Math.cos(r), d.y = h * Math.sin(r), o.push(d.x, d.y, d.z), l.push(0, 0, 1), p.x = (d.x / t + 1) / 2, p.y = (d.y / t + 1) / 2, c.push(p.x, p.y) } h += u } for (let e = 0; e < r; e++) { const t = e * (n + 1); for (let e = 0; e < n; e++) { const r = e + t, i = r, a = r + n + 1, o = r + n + 2, l = r + 1; s.push(i, a, l), s.push(a, o, l) } } this.setIndex(s), this.setAttribute("position", new V(o, 3)), this.setAttribute("normal", new V(l, 3)), this.setAttribute("uv", new V(c, 2)) } static fromJSON(e) { return new al(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength) } } class sl extends T { constructor(t, s = 12) { super(), this.type = "ShapeGeometry", this.parameters = { shapes: t, curveSegments: s }; const o = [], l = [], c = [], h = []; let n = 0, u = 0; if (!1 === Array.isArray(t)) r(t); else for (let e = 0; e < t.length; e++)r(t[e]), this.addGroup(n, u, e), n += u, u = 0; function r(e) { var n = l.length / 3, e = e.extractPoints(s); let r = e.shape; const i = e.holes; !1 === Jo.isClockWise(r) && (r = r.reverse()); for (let e = 0, t = i.length; e < t; e++) { const s = i[e]; !0 === Jo.isClockWise(s) && (i[e] = s.reverse()) } var a = Jo.triangulateShape(r, i); for (let e = 0, t = i.length; e < t; e++) { const s = i[e]; r = r.concat(s) } for (let e = 0, t = r.length; e < t; e++) { const s = r[e]; l.push(s.x, s.y, 0), c.push(0, 0, 1), h.push(s.x, s.y) } for (let e = 0, t = a.length; e < t; e++) { const s = a[e], l = s[0] + n, c = s[1] + n, h = s[2] + n; o.push(l, c, h), u += 3 } } this.setIndex(o), this.setAttribute("position", new V(l, 3)), this.setAttribute("normal", new V(c, 3)), this.setAttribute("uv", new V(h, 2)) } toJSON() { var e = super.toJSON(), n = this.parameters.shapes, r = e; if (r.shapes = [], Array.isArray(n)) for (let e = 0, t = n.length; e < t; e++) { var i = n[e]; r.shapes.push(i.uuid) } else r.shapes.push(n.uuid); return r } static fromJSON(n, r) { const i = []; for (let e = 0, t = n.shapes.length; e < t; e++) { var a = r[n.shapes[e]]; i.push(a) } return new sl(i, n.curveSegments) } } class ol extends T { constructor(n = 1, r = 32, i = 16, a = 0, s = 2 * Math.PI, o = 0, l = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: n, widthSegments: r, heightSegments: i, phiStart: a, phiLength: s, thetaStart: o, thetaLength: l }, r = Math.max(3, Math.floor(r)), i = Math.max(2, Math.floor(i)); const c = Math.min(o + l, Math.PI); let h = 0; const u = [], d = new Le, p = new Le, m = [], f = [], g = [], v = []; for (let e = 0; e <= i; e++) { const y = [], x = e / i; let t = 0; 0 == e && 0 == o ? t = .5 / r : e == i && c == Math.PI && (t = -.5 / r); for (let e = 0; e <= r; e++) { const c = e / r; d.x = -n * Math.cos(a + c * s) * Math.sin(o + x * l), d.y = n * Math.cos(o + x * l), d.z = n * Math.sin(a + c * s) * Math.sin(o + x * l), f.push(d.x, d.y, d.z), p.copy(d).normalize(), g.push(p.x, p.y, p.z), v.push(c + t, 1 - x), y.push(h++) } u.push(y) } for (let t = 0; t < i; t++)for (let e = 0; e < r; e++) { const r = u[t][e + 1], s = u[t][e], l = u[t + 1][e], h = u[t + 1][e + 1]; (0 !== t || 0 < o) && m.push(r, s, h), (t !== i - 1 || c < Math.PI) && m.push(s, l, h) } this.setIndex(m), this.setAttribute("position", new V(f, 3)), this.setAttribute("normal", new V(g, 3)), this.setAttribute("uv", new V(v, 2)) } static fromJSON(e) { return new ol(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength) } } class ll extends so { constructor(e = 1, t = 0) { super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new ll(e.radius, e.detail) } } class cl extends $o { constructor(e, t = {}) { const n = t.font; if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new T; e = n.generateShapes(e, t.size); t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), super(e, t), this.type = "TextGeometry" } } class hl extends T { constructor(n = 1, r = .4, i = 8, a = 6, s = 2 * Math.PI) { super(), this.type = "TorusGeometry", this.parameters = { radius: n, tube: r, radialSegments: i, tubularSegments: a, arc: s }, i = Math.floor(i), a = Math.floor(a); const o = [], l = [], c = [], h = [], u = new Le, d = new Le, p = new Le; for (let t = 0; t <= i; t++)for (let e = 0; e <= a; e++) { var m = e / a * s, f = t / i * Math.PI * 2; d.x = (n + r * Math.cos(f)) * Math.cos(m), d.y = (n + r * Math.cos(f)) * Math.sin(m), d.z = r * Math.sin(f), l.push(d.x, d.y, d.z), u.x = n * Math.cos(m), u.y = n * Math.sin(m), p.subVectors(d, u).normalize(), c.push(p.x, p.y, p.z), h.push(e / a), h.push(t / i) } for (let t = 1; t <= i; t++)for (let e = 1; e <= a; e++) { const i = (a + 1) * t + e - 1, s = (a + 1) * (t - 1) + e - 1, l = (a + 1) * (t - 1) + e, c = (a + 1) * t + e; o.push(i, s, c), o.push(s, l, c) } this.setIndex(o), this.setAttribute("position", new V(l, 3)), this.setAttribute("normal", new V(c, 3)), this.setAttribute("uv", new V(h, 2)) } static fromJSON(e) { return new hl(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc) } } class ul extends T { constructor(e = 1, n = .4, r = 64, i = 8, a = 2, s = 3) { super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: n, tubularSegments: r, radialSegments: i, p: a, q: s }, r = Math.floor(r), i = Math.floor(i); const o = [], l = [], c = [], h = [], u = new Le, d = new Le, p = new Le, m = new Le, f = new Le, g = new Le, v = new Le; for (let t = 0; t <= r; ++t) { var y = t / r * a * Math.PI * 2; x(y, a, s, e, p), x(.01 + y, a, s, e, m), g.subVectors(m, p), v.addVectors(m, p), f.crossVectors(g, v), v.crossVectors(f, g), f.normalize(), v.normalize(); for (let e = 0; e <= i; ++e) { const a = e / i * Math.PI * 2, s = -n * Math.cos(a), m = n * Math.sin(a); u.x = p.x + (s * v.x + m * f.x), u.y = p.y + (s * v.y + m * f.y), u.z = p.z + (s * v.z + m * f.z), l.push(u.x, u.y, u.z), d.subVectors(u, p).normalize(), c.push(d.x, d.y, d.z), h.push(t / r), h.push(e / i) } } for (let t = 1; t <= r; t++)for (let e = 1; e <= i; e++) { const r = (i + 1) * (t - 1) + (e - 1), a = (i + 1) * t + (e - 1), s = (i + 1) * t + e, l = (i + 1) * (t - 1) + e; o.push(r, a, l), o.push(a, s, l) } function x(e, t, n, r, i) { var a = Math.cos(e), s = Math.sin(e), n = n / t * e, t = Math.cos(n); i.x = r * (2 + t) * .5 * a, i.y = r * (2 + t) * s * .5, i.z = r * Math.sin(n) * .5 } this.setIndex(o), this.setAttribute("position", new V(l, 3)), this.setAttribute("normal", new V(c, 3)), this.setAttribute("uv", new V(h, 2)) } static fromJSON(e) { return new ul(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q) } } class dl extends T { constructor(e, i = 64, a = 1, s = 8, t = !1) { super(), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: i, radius: a, radialSegments: s, closed: t }; const o = e.computeFrenetFrames(i, t), l = (this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals, new Le), c = new Le, n = new k; let h = new Le; const u = [], d = [], r = [], p = []; function m(t) { h = e.getPointAt(t / i, h); var n = o.normals[t], r = o.binormals[t]; for (let e = 0; e <= s; e++) { const i = e / s * Math.PI * 2, t = Math.sin(i), o = -Math.cos(i); c.x = o * n.x + t * r.x, c.y = o * n.y + t * r.y, c.z = o * n.z + t * r.z, c.normalize(), d.push(c.x, c.y, c.z), l.x = h.x + a * c.x, l.y = h.y + a * c.y, l.z = h.z + a * c.z, u.push(l.x, l.y, l.z) } } for (let e = 0; e < i; e++)m(e); m(!1 === t ? i : 0); for (let t = 0; t <= i; t++)for (let e = 0; e <= s; e++)n.x = t / i, n.y = e / s, r.push(n.x, n.y); for (let t = 1; t <= i; t++)for (let e = 1; e <= s; e++) { var f = (s + 1) * (t - 1) + (e - 1), g = (s + 1) * t + (e - 1), v = (s + 1) * t + e, y = (s + 1) * (t - 1) + e; p.push(f, g, y), p.push(g, v, y) } this.setIndex(p), this.setAttribute("position", new V(u, 3)), this.setAttribute("normal", new V(d, 3)), this.setAttribute("uv", new V(r, 2)) } toJSON() { const e = super.toJSON(); return e.path = this.parameters.path.toJSON(), e } static fromJSON(e) { return new dl((new Do[e.path.type]).fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed) } } class pl extends T { constructor(e) { if (super(), this.type = "WireframeGeometry", !0 === e.isGeometry) console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); else { const c = [], h = new Set, u = new Le, d = new Le; if (null !== e.index) { const p = e.attributes.position, m = e.index; let n = e.groups; for (let e = 0, t = (n = 0 === n.length ? [{ start: 0, count: m.count, materialIndex: 0 }] : n).length; e < t; ++e) { var r = n[e], i = r.start; for (let t = i, e = i + r.count; t < e; t += 3)for (let e = 0; e < 3; e++) { var a = m.getX(t + e), s = m.getX(t + (e + 1) % 3); u.fromBufferAttribute(p, a), d.fromBufferAttribute(p, s), !0 === ml(u, d, h) && (c.push(u.x, u.y, u.z), c.push(d.x, d.y, d.z)) } } } else { var n = e.attributes.position; for (let t = 0, e = n.count / 3; t < e; t++)for (let e = 0; e < 3; e++) { var o = 3 * t + e, l = 3 * t + (e + 1) % 3; u.fromBufferAttribute(n, o), d.fromBufferAttribute(n, l), !0 === ml(u, d, h) && (c.push(u.x, u.y, u.z), c.push(d.x, d.y, d.z)) } } this.setAttribute("position", new V(c, 3)) } } } function ml(e, t, n) { var r = `${e.x},${e.y},${e.z}-${t.x},${t.y},` + t.z, t = `${t.x},${t.y},${t.z}-${e.x},${e.y},` + e.z; return !0 !== n.has(r) && !0 !== n.has(t) && (n.add(r, t), !0) } var fl = Object.freeze({ __proto__: null, BoxGeometry: er, BoxBufferGeometry: er, CircleGeometry: ro, CircleBufferGeometry: ro, ConeGeometry: ao, ConeBufferGeometry: ao, CylinderGeometry: io, CylinderBufferGeometry: io, DodecahedronGeometry: oo, DodecahedronBufferGeometry: oo, EdgesGeometry: po, ExtrudeGeometry: $o, ExtrudeBufferGeometry: $o, IcosahedronGeometry: tl, IcosahedronBufferGeometry: tl, LatheGeometry: nl, LatheBufferGeometry: nl, OctahedronGeometry: rl, OctahedronBufferGeometry: rl, ParametricGeometry: il, ParametricBufferGeometry: il, PlaneGeometry: vr, PlaneBufferGeometry: vr, PolyhedronGeometry: so, PolyhedronBufferGeometry: so, RingGeometry: al, RingBufferGeometry: al, ShapeGeometry: sl, ShapeBufferGeometry: sl, SphereGeometry: ol, SphereBufferGeometry: ol, TetrahedronGeometry: ll, TetrahedronBufferGeometry: ll, TextGeometry: cl, TextBufferGeometry: cl, TorusGeometry: hl, TorusBufferGeometry: hl, TorusKnotGeometry: ul, TorusKnotBufferGeometry: ul, TubeGeometry: dl, TubeBufferGeometry: dl, WireframeGeometry: pl }); class gl extends t { constructor(e) { super(), this.type = "ShadowMaterial", this.color = new y(0), this.transparent = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this } } class vl extends t { constructor(e) { super(), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new y(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new y(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new k(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this } } vl.prototype.isMeshStandardMaterial = gl.prototype.isShadowMaterial = !0; class yl extends vl { constructor(e) { super(), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new k(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", { get: function () { return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity) }, set: function (e) { this.reflectivity = m(2.5 * (e - 1) / (e + 1), 0, 1) } }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.thickness = .01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationTint = new y(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularTint = new y(1, 1, 1), this.specularTintMap = null, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.reflectivity = e.reflectivity, e.sheen ? this.sheen = (this.sheen || new y).copy(e.sheen) : this.sheen = null, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationTint.copy(e.attenuationTint), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularTint.copy(e.specularTint), this.specularTintMap = e.specularTintMap, this } } class xl extends t { constructor(e) { super(), this.type = "MeshPhongMaterial", this.color = new y(16777215), this.specular = new y(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new y(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new k(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this } } class _l extends t { constructor(e) { super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new y(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new y(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new k(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this } } class bl extends t { constructor(e) { super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new k(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this } } class Ml extends t { constructor(e) { super(), this.type = "MeshLambertMaterial", this.color = new y(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new y(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this } } class wl extends t { constructor(e) { super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new y(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new k(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this } } class Tl extends x { constructor(e) { super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) } copy(e) { return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this } } Tl.prototype.isLineDashedMaterial = wl.prototype.isMeshMatcapMaterial = Ml.prototype.isMeshLambertMaterial = bl.prototype.isMeshNormalMaterial = _l.prototype.isMeshToonMaterial = xl.prototype.isMeshPhongMaterial = yl.prototype.isMeshPhysicalMaterial = !0; var El = Object.freeze({ __proto__: null, ShadowMaterial: gl, SpriteMaterial: ts, RawShaderMaterial: Sr, ShaderMaterial: rr, PointsMaterial: qs, MeshPhysicalMaterial: yl, MeshStandardMaterial: vl, MeshPhongMaterial: xl, MeshToonMaterial: _l, MeshNormalMaterial: bl, MeshLambertMaterial: Ml, MeshDepthMaterial: Fa, MeshDistanceMaterial: Ba, MeshBasicMaterial: gn, MeshMatcapMaterial: wl, LineDashedMaterial: Tl, LineBasicMaterial: x, Material: t }); const b = { arraySlice: function (e, t, n) { return b.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n) }, convertArray: function (e, t, n) { return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) }, isTypedArray: function (e) { return ArrayBuffer.isView(e) && !(e instanceof DataView) }, getKeyframeOrder: function (n) { const t = n.length, r = new Array(t); for (let e = 0; e !== t; ++e)r[e] = e; return r.sort(function (e, t) { return n[e] - n[t] }), r }, sortedArray: function (n, r, i) { const a = n.length, s = new n.constructor(a); for (let e = 0, t = 0; t !== a; ++e) { const a = i[e] * r; for (let e = 0; e !== r; ++e)s[t++] = n[a + e] } return s }, flattenJSON: function (t, n, r, i) { let a = 1, s = t[0]; for (; void 0 !== s && void 0 === s[i];)s = t[a++]; if (void 0 !== s) { let e = s[i]; if (void 0 !== e) if (Array.isArray(e)) for (; void 0 !== (e = s[i]) && (n.push(s.time), r.push.apply(r, e)), void 0 !== (s = t[a++]);); else if (void 0 !== e.toArray) for (; void 0 !== (e = s[i]) && (n.push(s.time), e.toArray(r, r.length)), void 0 !== (s = t[a++]);); else for (; void 0 !== (e = s[i]) && (n.push(s.time), r.push(e)), void 0 !== (s = t[a++]);); } }, subclip: function (e, n, r, i, a = 30) { const s = e.clone(), t = (s.name = n, []); for (let e = 0; e < s.tracks.length; ++e) { const n = s.tracks[e], o = n.getValueSize(), l = [], c = []; for (let t = 0; t < n.times.length; ++t) { const s = n.times[t] * a; if (!(s < r || s >= i)) { l.push(n.times[t]); for (let e = 0; e < o; ++e)c.push(n.values[t * o + e]) } } 0 !== l.length && (n.times = b.convertArray(l, n.times.constructor), n.values = b.convertArray(c, n.values.constructor), t.push(n)) } s.tracks = t; let o = 1 / 0; for (let e = 0; e < s.tracks.length; ++e)o > s.tracks[e].times[0] && (o = s.tracks[e].times[0]); for (let e = 0; e < s.tracks.length; ++e)s.tracks[e].shift(-1 * o); return s.resetDuration(), s }, makeClipAdditive: function (r, i = 0, a = r, s = 30) { const o = a.tracks.length, l = i / (s = s <= 0 ? 30 : s); for (let e = 0; e < o; ++e) { const s = a.tracks[e], o = s.ValueTypeName; if ("bool" !== o && "string" !== o) { const p = r.tracks.find(function (e) { return e.name === s.name && e.ValueTypeName === o }); if (void 0 !== p) { let e = 0; var c = s.getValueSize(); s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (e = c / 3); let t = 0; var h = p.getValueSize(), u = (p.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (t = h / 3), s.times.length - 1); let n; if (l <= s.times[0]) { const r = e, i = c - e; n = b.arraySlice(s.values, r, i) } else if (l >= s.times[u]) { const r = u * c + e, i = r + c - e; n = b.arraySlice(s.values, r, i) } else { const r = s.createInterpolant(), i = e, a = c - e; r.evaluate(l), n = b.arraySlice(r.resultBuffer, i, a) } "quaternion" === o && (new f).fromArray(n).normalize().conjugate().toArray(n); var d = p.times.length; for (let e = 0; e < d; ++e) { const i = e * h + t; if ("quaternion" === o) f.multiplyQuaternionsFlat(p.values, i, n, 0, p.values, i); else { const r = h - 2 * t; for (let e = 0; e < r; ++e)p.values[i + e] -= n[e] } } } } } return r.blendMode = fe, r } }; class Sl { constructor(e, t, n, r) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {} } evaluate(t) { var n = this.parameterPositions; let r = this._cachedIndex, i = n[r], a = n[r - 1]; e: { t: { let e; n: { r: if (!(t < i)) { for (var s = r + 2; ;) { if (void 0 === i) { if (t < a) break r; return r = n.length, this._cachedIndex = r, this.afterEnd_(r - 1, t, a) } if (r === s) break; if (a = i, t < (i = n[++r])) break t } e = n.length; break n } if (t >= a) break e; var o = n[1]; t < o && (r = 2, a = o); for (var l = r - 2; ;) { if (void 0 === a) return this._cachedIndex = 0, this.beforeStart_(0, t, i); if (r === l) break; if (i = a, t >= (a = n[--r - 1])) break t } e = r, r = 0 } for (; r < e;) { const i = r + e >>> 1; t < n[i] ? e = i : r = 1 + i } if (i = n[r], void 0 === (a = n[r - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, i); if (void 0 === i) return r = n.length, this._cachedIndex = r, this.afterEnd_(r - 1, a, t) } this._cachedIndex = r, this.intervalChanged_(r, a, i) } return this.interpolate_(r, a, t, i) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(e) { const t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r; for (let e = 0; e !== r; ++e)t[e] = n[i + e]; return t } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } Sl.prototype.beforeStart_ = Sl.prototype.copySampleValue_, Sl.prototype.afterEnd_ = Sl.prototype.copySampleValue_; class Al extends Sl { constructor(e, t, n, r) { super(e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: ue, endingEnd: ue } } intervalChanged_(e, t, n) { var r = this.parameterPositions; let i = e - 2, a = e + 1, s = r[i], o = r[a]; if (void 0 === s) switch (this.getSettings_().endingStart) { case de: i = e, s = 2 * t - n; break; case pe: i = r.length - 2, s = t + r[i] - r[i + 1]; break; default: i = e, s = n }if (void 0 === o) switch (this.getSettings_().endingEnd) { case de: a = e, o = 2 * n - t; break; case pe: a = 1, o = n + r[1] - r[0]; break; default: a = e - 1, o = t }var l = .5 * (n - t), c = this.valueSize; this._weightPrev = l / (t - s), this._weightNext = l / (o - n), this._offsetPrev = i * c, this._offsetNext = a * c } interpolate_(e, t, n, r) { const i = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = e * s, l = o - s, c = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, d = this._weightNext, p = (n - t) / (r - t), m = p * p, f = m * p, g = -u * f + 2 * u * m - u * p, v = (1 + u) * f + (-1.5 - 2 * u) * m + (-.5 + u) * p + 1, y = (-1 - d) * f + (1.5 + d) * m + .5 * p, x = d * f - d * m; for (let e = 0; e !== s; ++e)i[e] = g * a[c + e] + v * a[l + e] + y * a[o + e] + x * a[h + e]; return i } } class Rl extends Sl { constructor(e, t, n, r) { super(e, t, n, r) } interpolate_(e, t, n, r) { const i = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = e * s, l = o - s, c = (n - t) / (r - t), h = 1 - c; for (let e = 0; e !== s; ++e)i[e] = a[l + e] * h + a[o + e] * c; return i } } class Ll extends Sl { constructor(e, t, n, r) { super(e, t, n, r) } interpolate_(e) { return this.copySampleValue_(e - 1) } } class Cl { constructor(e, t, n, r) { if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = b.convertArray(t, this.TimeBufferType), this.values = b.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation) } static toJSON(e) { const t = e.constructor; let n; if (t.toJSON !== this.toJSON) n = t.toJSON(e); else { n = { name: e.name, times: b.convertArray(e.times, Array), values: b.convertArray(e.values, Array) }; const t = e.getInterpolation(); t !== e.DefaultInterpolation && (n.interpolation = t) } return n.type = e.ValueTypeName, n } InterpolantFactoryMethodDiscrete(e) { return new Ll(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodLinear(e) { return new Rl(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodSmooth(e) { return new Al(this.times, this.values, this.getValueSize(), e) } setInterpolation(e) { let t; switch (e) { case le: t = this.InterpolantFactoryMethodDiscrete; break; case ce: t = this.InterpolantFactoryMethodLinear; break; case he: t = this.InterpolantFactoryMethodSmooth }if (void 0 !== t) return this.createInterpolant = t, this; { const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (e === this.DefaultInterpolation) throw new Error(t); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", t), this } } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return le; case this.InterpolantFactoryMethodLinear: return ce; case this.InterpolantFactoryMethodSmooth: return he } } getValueSize() { return this.values.length / this.times.length } shift(n) { if (0 !== n) { const r = this.times; for (let e = 0, t = r.length; e !== t; ++e)r[e] += n } return this } scale(n) { if (1 !== n) { const r = this.times; for (let e = 0, t = r.length; e !== t; ++e)r[e] *= n } return this } trim(e, t) { var n = this.times, r = n.length; let i = 0, a = r - 1; for (; i !== r && n[i] < e;)++i; for (; -1 !== a && n[a] > t;)--a; if (++a, 0 !== i || a !== r) { i >= a && (a = Math.max(a, 1), i = a - 1); const e = this.getValueSize(); this.times = b.arraySlice(n, i, a), this.values = b.arraySlice(this.values, i * e, a * e) } return this } validate() { let n = !0; var e = this.getValueSize(); e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), n = !1); const r = this.times, i = this.values, t = r.length; 0 === t && (console.error("THREE.KeyframeTrack: Track is empty.", this), n = !1); let a = null; for (let e = 0; e !== t; e++) { const i = r[e]; if ("number" == typeof i && isNaN(i)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i), n = !1; break } if (null !== a && a > i) { console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, a), n = !1; break } a = i } if (void 0 !== i && b.isTypedArray(i)) for (let e = 0, t = i.length; e !== t; ++e) { const r = i[e]; if (isNaN(r)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, r), n = !1; break } } return n } optimize() { const n = b.arraySlice(this.times), r = b.arraySlice(this.values), i = this.getValueSize(), a = this.getInterpolation() === he, s = n.length - 1; let o = 1; for (let e = 1; e < s; ++e) { let t = !1; var l = n[e]; if (l !== n[e + 1] && (1 !== e || l !== n[0])) if (a) t = !0; else { const n = e * i, a = n - i, o = n + i; for (let e = 0; e !== i; ++e) { const i = r[n + e]; if (i !== r[a + e] || i !== r[o + e]) { t = !0; break } } } if (t) { if (e !== o) { n[o] = n[e]; const a = e * i, s = o * i; for (let e = 0; e !== i; ++e)r[s + e] = r[a + e] } ++o } } if (0 < s) { n[o] = n[s]; for (let e = s * i, t = o * i, n = 0; n !== i; ++n)r[t + n] = r[e + n]; ++o } return o !== n.length ? (this.times = b.arraySlice(n, 0, o), this.values = b.arraySlice(r, 0, o * i)) : (this.times = n, this.values = r), this } clone() { const e = b.arraySlice(this.times, 0), t = b.arraySlice(this.values, 0), n = new this.constructor(this.name, e, t); return n.createInterpolant = this.createInterpolant, n } } Cl.prototype.TimeBufferType = Float32Array, Cl.prototype.ValueBufferType = Float32Array, Cl.prototype.DefaultInterpolation = ce; class Pl extends Cl { } Pl.prototype.ValueTypeName = "bool", Pl.prototype.ValueBufferType = Array, Pl.prototype.DefaultInterpolation = le, Pl.prototype.InterpolantFactoryMethodLinear = void 0, Pl.prototype.InterpolantFactoryMethodSmooth = void 0; class Il extends Cl { } Il.prototype.ValueTypeName = "color"; class Dl extends Cl { } Dl.prototype.ValueTypeName = "number"; class Nl extends Sl { constructor(e, t, n, r) { super(e, t, n, r) } interpolate_(e, t, n, r) { var i = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = (n - t) / (r - t); let l = e * s; for (var c = l + s; l !== c; l += 4)f.slerpFlat(i, 0, a, l - s, a, l, o); return i } } class Hl extends Cl { InterpolantFactoryMethodLinear(e) { return new Nl(this.times, this.values, this.getValueSize(), e) } } Hl.prototype.ValueTypeName = "quaternion", Hl.prototype.DefaultInterpolation = ce, Hl.prototype.InterpolantFactoryMethodSmooth = void 0; class Ol extends Cl { } Ol.prototype.ValueTypeName = "string", Ol.prototype.ValueBufferType = Array, Ol.prototype.DefaultInterpolation = le, Ol.prototype.InterpolantFactoryMethodLinear = void 0, Ol.prototype.InterpolantFactoryMethodSmooth = void 0; class Fl extends Cl { } class Bl { constructor(e, t = -1, n, r = 2500) { this.name = e, this.tracks = n, this.duration = t, this.blendMode = r, this.uuid = Be(), this.duration < 0 && this.resetDuration() } static parse(e) { const n = [], r = e.tracks, i = 1 / (e.fps || 1); for (let e = 0, t = r.length; e !== t; ++e)n.push(function (e) { if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const t = function (e) { switch (e.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return Dl; case "vector": case "vector2": case "vector3": case "vector4": return Fl; case "color": return Il; case "quaternion": return Hl; case "bool": case "boolean": return Pl; case "string": return Ol }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e) }(e.type); if (void 0 === e.times) { const t = [], n = []; b.flattenJSON(e.keys, t, n, "value"), e.times = t, e.values = n } return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation) }(r[e]).scale(i)); const t = new this(e.name, e.duration, n, e.blendMode); return t.uuid = e.uuid, t } static toJSON(e) { const n = [], r = e.tracks, t = { name: e.name, duration: e.duration, tracks: n, uuid: e.uuid, blendMode: e.blendMode }; for (let e = 0, t = r.length; e !== t; ++e)n.push(Cl.toJSON(r[e])); return t } static CreateFromMorphTargetSequence(e, r, i, a) { const s = r.length, o = []; for (let n = 0; n < s; n++) { let e = [], t = []; e.push((n + s - 1) % s, n, (n + 1) % s), t.push(0, 1, 0); var l = b.getKeyframeOrder(e); e = b.sortedArray(e, 1, l), t = b.sortedArray(t, 1, l), a || 0 !== e[0] || (e.push(s), t.push(t[0])), o.push(new Dl(".morphTargetInfluences[" + r[n].name + "]", e, t).scale(1 / i)) } return new this(e, -1, o) } static findByName(e, t) { let n = e; if (!Array.isArray(e)) { const t = e; n = t.geometry && t.geometry.animations || t.animations } for (let e = 0; e < n.length; e++)if (n[e].name === t) return n[e]; return null } static CreateClipsFromMorphTargetSequences(n, e, r) { const i = {}, a = /^([\w-]*?)([\d]+)$/; for (let e = 0, t = n.length; e < t; e++) { const r = n[e], s = r.name.match(a); if (s && 1 < s.length) { const n = s[1]; let e = i[n]; e || (i[n] = e = []), e.push(r) } } const s = []; for (const n in i) s.push(this.CreateFromMorphTargetSequence(n, i[n], e, r)); return s } static parseAnimation(n, t) { if (!n) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const r = function (e, t, n, r, i) { var a, s; 0 !== n.length && (a = [], s = [], b.flattenJSON(n, a, s, r), 0 !== a.length && i.push(new e(t, a, s))) }, i = [], a = n.name || "default", s = n.fps || 30, e = n.blendMode; let o = n.length || -1; var l = n.hierarchy || []; for (let e = 0; e < l.length; e++) { const a = l[e].keys; if (a && 0 !== a.length) if (a[0].morphTargets) { const n = {}; let t; for (t = 0; t < a.length; t++)if (a[t].morphTargets) for (let e = 0; e < a[t].morphTargets.length; e++)n[a[t].morphTargets[e]] = -1; for (const r in n) { const n = [], s = []; for (let e = 0; e !== a[t].morphTargets.length; ++e) { const i = a[t]; n.push(i.time), s.push(i.morphTarget === r ? 1 : 0) } i.push(new Dl(".morphTargetInfluence[" + r + "]", n, s)) } o = n.length * (s || 1) } else { const s = ".bones[" + t[e].name + "]"; r(Fl, s + ".position", a, "pos", i), r(Hl, s + ".quaternion", a, "rot", i), r(Fl, s + ".scale", a, "scl", i) } } return 0 === i.length ? null : new this(a, o, i, e) } resetDuration() { let n = 0; for (let e = 0, t = this.tracks.length; e !== t; ++e) { var r = this.tracks[e]; n = Math.max(n, r.times[r.times.length - 1]) } return this.duration = n, this } trim() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this } validate() { let t = !0; for (let e = 0; e < this.tracks.length; e++)t = t && this.tracks[e].validate(); return t } optimize() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this } clone() { const t = []; for (let e = 0; e < this.tracks.length; e++)t.push(this.tracks[e].clone()); return new this.constructor(this.name, this.duration, t, this.blendMode) } toJSON() { return this.constructor.toJSON(this) } } const Ul = { enabled: !(Fl.prototype.ValueTypeName = "vector"), files: {}, add: function (e, t) { !1 !== this.enabled && (this.files[e] = t) }, get: function (e) { if (!1 !== this.enabled) return this.files[e] }, remove: function (e) { delete this.files[e] }, clear: function () { this.files = {} } }; class zl { constructor(e, t, n) { const r = this; let i, a = !1, s = 0, o = 0; const l = []; this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function (e) { o++, !1 === a && void 0 !== r.onStart && r.onStart(e, s, o), a = !0 }, this.itemEnd = function (e) { s++, void 0 !== r.onProgress && r.onProgress(e, s, o), s === o && (a = !1, void 0 !== r.onLoad && r.onLoad()) }, this.itemError = function (e) { void 0 !== r.onError && r.onError(e) }, this.resolveURL = function (e) { return i ? i(e) : e }, this.setURLModifier = function (e) { return i = e, this }, this.addHandler = function (e, t) { return l.push(e, t), this }, this.removeHandler = function (e) { e = l.indexOf(e); return -1 !== e && l.splice(e, 2), this }, this.getHandler = function (n) { for (let e = 0, t = l.length; e < t; e += 2) { const r = l[e], i = l[e + 1]; if (r.global && (r.lastIndex = 0), r.test(n)) return i } return null } } } const Gl = new zl; class l { constructor(e) { this.manager = void 0 !== e ? e : Gl, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(n, r) { const i = this; return new Promise(function (e, t) { i.load(n, e, r, t) }) } parse() { } setCrossOrigin(e) { return this.crossOrigin = e, this } setWithCredentials(e) { return this.withCredentials = e, this } setPath(e) { return this.path = e, this } setResourcePath(e) { return this.resourcePath = e, this } setRequestHeader(e) { return this.requestHeader = e, this } } const kl = {}; class Vl extends l { constructor(e) { super(e) } load(a, n, r, i) { void 0 === a && (a = ""), void 0 !== this.path && (a = this.path + a), a = this.manager.resolveURL(a); const s = this, o = Ul.get(a); if (void 0 !== o) return s.manager.itemStart(a), setTimeout(function () { n && n(o), s.manager.itemEnd(a) }, 0), o; if (void 0 === kl[a]) { var l = a.match(/^data:(.*?)(;base64)?,(.*)$/); let e; if (l) { const r = l[1], o = !!l[2]; let t = l[3]; t = decodeURIComponent(t), o && (t = atob(t)); try { let e; const o = (this.responseType || "").toLowerCase(); switch (o) { case "arraybuffer": case "blob": const a = new Uint8Array(t.length); for (let e = 0; e < t.length; e++)a[e] = t.charCodeAt(e); e = "blob" === o ? new Blob([a.buffer], { type: r }) : a.buffer; break; case "document": const n = new DOMParser; e = n.parseFromString(t, r); break; case "json": e = JSON.parse(t); break; default: e = t }setTimeout(function () { n && n(e), s.manager.itemEnd(a) }, 0) } catch (n) { setTimeout(function () { i && i(n), s.manager.itemError(a), s.manager.itemEnd(a) }, 0) } } else { kl[a] = [], kl[a].push({ onLoad: n, onProgress: r, onError: i }), (e = new XMLHttpRequest).open("GET", a, !0), e.addEventListener("load", function (n) { const r = this.response, i = kl[a]; if (delete kl[a], 200 === this.status || 0 === this.status) { 0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), Ul.add(a, r); for (let e = 0, t = i.length; e < t; e++) { const n = i[e]; n.onLoad && n.onLoad(r) } s.manager.itemEnd(a) } else { for (let e = 0, t = i.length; e < t; e++) { const r = i[e]; r.onError && r.onError(n) } s.manager.itemError(a), s.manager.itemEnd(a) } }, !1), e.addEventListener("progress", function (n) { var r = kl[a]; for (let e = 0, t = r.length; e < t; e++) { const i = r[e]; i.onProgress && i.onProgress(n) } }, !1), e.addEventListener("error", function (n) { var r = kl[a]; delete kl[a]; for (let e = 0, t = r.length; e < t; e++) { const i = r[e]; i.onError && i.onError(n) } s.manager.itemError(a), s.manager.itemEnd(a) }, !1), e.addEventListener("abort", function (n) { var r = kl[a]; delete kl[a]; for (let e = 0, t = r.length; e < t; e++) { const i = r[e]; i.onError && i.onError(n) } s.manager.itemError(a), s.manager.itemEnd(a) }, !1), void 0 !== this.responseType && (e.responseType = this.responseType), void 0 !== this.withCredentials && (e.withCredentials = this.withCredentials), e.overrideMimeType && e.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"); for (const a in this.requestHeader) e.setRequestHeader(a, this.requestHeader[a]); e.send(null) } return s.manager.itemStart(a), e } kl[a].push({ onLoad: n, onProgress: r, onError: i }) } setResponseType(e) { return this.responseType = e, this } setMimeType(e) { return this.mimeType = e, this } } class Wl extends l { constructor(e) { super(e) } load(t, e, n, r) { void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const i = this, a = Ul.get(t); if (void 0 !== a) return i.manager.itemStart(t), setTimeout(function () { e && e(a), i.manager.itemEnd(t) }, 0), a; const s = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); function o() { s.removeEventListener("load", o, !1), s.removeEventListener("error", l, !1), Ul.add(t, this), e && e(this), i.manager.itemEnd(t) } function l(e) { s.removeEventListener("load", o, !1), s.removeEventListener("error", l, !1), r && r(e), i.manager.itemError(t), i.manager.itemEnd(t) } return s.addEventListener("load", o, !1), s.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), i.manager.itemStart(t), s.src = t, s } } class jl extends l { constructor(e) { super(e) } load(n, r, e, i) { const a = new sr, s = new Wl(this.manager); s.setCrossOrigin(this.crossOrigin), s.setPath(this.path); let o = 0; for (let e = 0; e < n.length; ++e)!function (t) { s.load(n[t], function (e) { a.images[t] = e, 6 === ++o && (a.needsUpdate = !0, r && r(a)) }, void 0, i) }(e); return a } } class ql extends l { constructor(e) { super(e) } load(e, t, n, r) { const i = this, a = new As, s = new Vl(this.manager); return s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setPath(this.path), s.setWithCredentials(i.withCredentials), s.load(e, function (e) { e = i.parse(e); e && (void 0 !== e.image ? a.image = e.image : void 0 !== e.data && (a.image.width = e.width, a.image.height = e.height, a.image.data = e.data), a.wrapS = void 0 !== e.wrapS ? e.wrapS : Pe, a.wrapT = void 0 !== e.wrapT ? e.wrapT : Pe, a.magFilter = void 0 !== e.magFilter ? e.magFilter : B, a.minFilter = void 0 !== e.minFilter ? e.minFilter : B, a.anisotropy = void 0 !== e.anisotropy ? e.anisotropy : 1, void 0 !== e.encoding && (a.encoding = e.encoding), void 0 !== e.flipY && (a.flipY = e.flipY), void 0 !== e.format && (a.format = e.format), void 0 !== e.type && (a.type = e.type), void 0 !== e.mipmaps && (a.mipmaps = e.mipmaps, a.minFilter = Ie), 1 === e.mipmapCount && (a.minFilter = B), void 0 !== e.generateMipmaps && (a.generateMipmaps = e.generateMipmaps), a.needsUpdate = !0, t && t(a, e)) }, n, r), a } } class Xl extends l { constructor(e) { super(e) } load(t, n, e, r) { const i = new h, a = new Wl(this.manager); return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(t, function (e) { i.image = e; e = 0 < t.search(/\.jpe?g($|\?)/i) || 0 === t.search(/^data\:image\/jpeg/); i.format = e ? J : Oe, i.needsUpdate = !0, void 0 !== n && n(i) }, e, r), i } } class Yl extends mo { constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } add(e) { this.curves.push(e) } closePath() { const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1); e.equals(t) || this.curves.push(new Ro(t, e)) } getPoint(e) { var t = e * this.getLength(), n = this.getCurveLengths(); let r = 0; for (; r < n.length;) { if (n[r] >= t) { const e = n[r] - t, i = this.curves[r], a = i.getLength(), s = 0 === a ? 0 : 1 - e / a; return i.getPointAt(s) } r++ } return null } getLength() { var e = this.getCurveLengths(); return e[e.length - 1] } updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() } getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const n = []; let r = 0; for (let e = 0, t = this.curves.length; e < t; e++)r += this.curves[e].getLength(), n.push(r); return this.cacheLengths = n } getSpacedPoints(t = 40) { const n = []; for (let e = 0; e <= t; e++)n.push(this.getPoint(e / t)); return this.autoClose && n.push(n[0]), n } getPoints(n = 12) { const r = []; let i; for (let e = 0, t = this.curves; e < t.length; e++) { const s = t[e], o = s && s.isEllipseCurve ? 2 * n : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? n * s.points.length : n, l = s.getPoints(o); for (let e = 0; e < l.length; e++) { var a = l[e]; i && i.equals(a) || (r.push(a), i = a) } } return this.autoClose && 1 < r.length && !r[r.length - 1].equals(r[0]) && r.push(r[0]), r } copy(n) { super.copy(n), this.curves = []; for (let e = 0, t = n.curves.length; e < t; e++) { const r = n.curves[e]; this.curves.push(r.clone()) } return this.autoClose = n.autoClose, this } toJSON() { const n = super.toJSON(); n.autoClose = this.autoClose, n.curves = []; for (let e = 0, t = this.curves.length; e < t; e++) { const r = this.curves[e]; n.curves.push(r.toJSON()) } return n } fromJSON(n) { super.fromJSON(n), this.autoClose = n.autoClose, this.curves = []; for (let e = 0, t = n.curves.length; e < t; e++) { var r = n.curves[e]; this.curves.push((new Do[r.type]).fromJSON(r)) } return this } } class Zl extends Yl { constructor(e) { super(), this.type = "Path", this.currentPoint = new k, e && this.setFromPoints(e) } setFromPoints(n) { this.moveTo(n[0].x, n[0].y); for (let e = 1, t = n.length; e < t; e++)this.lineTo(n[e].x, n[e].y); return this } moveTo(e, t) { return this.currentPoint.set(e, t), this } lineTo(e, t) { var n = new Ro(this.currentPoint.clone(), new k(e, t)); return this.curves.push(n), this.currentPoint.set(e, t), this } quadraticCurveTo(e, t, n, r) { e = new Co(this.currentPoint.clone(), new k(e, t), new k(n, r)); return this.curves.push(e), this.currentPoint.set(n, r), this } bezierCurveTo(e, t, n, r, i, a) { e = new So(this.currentPoint.clone(), new k(e, t), new k(n, r), new k(i, a)); return this.curves.push(e), this.currentPoint.set(i, a), this } splineThru(e) { var t = [this.currentPoint.clone()].concat(e), t = new Io(t); return this.curves.push(t), this.currentPoint.copy(e[e.length - 1]), this } arc(e, t, n, r, i, a) { var s = this.currentPoint.x, o = this.currentPoint.y; return this.absarc(e + s, t + o, n, r, i, a), this } absarc(e, t, n, r, i, a) { return this.absellipse(e, t, n, n, r, i, a), this } ellipse(e, t, n, r, i, a, s, o) { var l = this.currentPoint.x, c = this.currentPoint.y; return this.absellipse(e + l, t + c, n, r, i, a, s, o), this } absellipse(e, t, n, r, i, a, s, o) { const l = new fo(e, t, n, r, i, a, s, o); if (0 < this.curves.length) { const e = l.getPoint(0); e.equals(this.currentPoint) || this.lineTo(e.x, e.y) } this.curves.push(l); e = l.getPoint(1); return this.currentPoint.copy(e), this } copy(e) { return super.copy(e), this.currentPoint.copy(e.currentPoint), this } toJSON() { const e = super.toJSON(); return e.currentPoint = this.currentPoint.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this } } class Jl extends Zl { constructor(e) { super(e), this.uuid = Be(), this.type = "Shape", this.holes = [] } getPointsHoles(n) { const r = []; for (let e = 0, t = this.holes.length; e < t; e++)r[e] = this.holes[e].getPoints(n); return r } extractPoints(e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } } copy(n) { super.copy(n), this.holes = []; for (let e = 0, t = n.holes.length; e < t; e++) { const r = n.holes[e]; this.holes.push(r.clone()) } return this } toJSON() { const n = super.toJSON(); n.uuid = this.uuid, n.holes = []; for (let e = 0, t = this.holes.length; e < t; e++) { const r = this.holes[e]; n.holes.push(r.toJSON()) } return n } fromJSON(n) { super.fromJSON(n), this.uuid = n.uuid, this.holes = []; for (let e = 0, t = n.holes.length; e < t; e++) { var r = n.holes[e]; this.holes.push((new Zl).fromJSON(r)) } return this } } class Kl extends u { constructor(e, t = 1) { super(), this.type = "Light", this.color = new y(e), this.intensity = t } dispose() { } copy(e) { return super.copy(e), this.color.copy(e.color), this.intensity = e.intensity, this } toJSON(e) { const t = super.toJSON(e); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t } } Kl.prototype.isLight = !0; class Ql extends Kl { constructor(e, t, n) { super(e, n), this.type = "HemisphereLight", this.position.copy(u.DefaultUp), this.updateMatrix(), this.groundColor = new y(t) } copy(e) { return Kl.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this } } Ql.prototype.isHemisphereLight = !0; const $l = new Ce, ec = new Le, tc = new Le; class nc { constructor(e) { this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new k(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ce, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new mr, this._frameExtents = new k(1, 1), this._viewportCount = 1, this._viewports = [new Re(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(e) { const t = this.camera, n = this.matrix; ec.setFromMatrixPosition(e.matrixWorld), t.position.copy(ec), tc.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(tc), t.updateMatrixWorld(), $l.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix($l), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse) } getViewport(e) { return this._viewports[e] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(e) { return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this } clone() { return (new this.constructor).copy(this) } toJSON() { const e = {}; return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } } class rc extends nc { constructor() { super(new C(50, 1, .5, 500)), this.focus = 1 } updateMatrices(e) { const t = this.camera, n = 2 * Se * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, i = e.distance || t.far; n === t.fov && r === t.aspect && i === t.far || (t.fov = n, t.aspect = r, t.far = i, t.updateProjectionMatrix()), super.updateMatrices(e) } copy(e) { return super.copy(e), this.focus = e.focus, this } } rc.prototype.isSpotLightShadow = !0; class ic extends Kl { constructor(e, t, n = 0, r = Math.PI / 3, i = 0, a = 1) { super(e, t), this.type = "SpotLight", this.position.copy(u.DefaultUp), this.updateMatrix(), this.target = new u, this.distance = n, this.angle = r, this.penumbra = i, this.decay = a, this.shadow = new rc } get power() { return this.intensity * Math.PI } set power(e) { this.intensity = e / Math.PI } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } ic.prototype.isSpotLight = !0; const ac = new Ce, sc = new Le, oc = new Le; class lc extends nc { constructor() { super(new C(90, 1, .5, 500)), this._frameExtents = new k(4, 2), this._viewportCount = 6, this._viewports = [new Re(2, 1, 1, 1), new Re(0, 1, 1, 1), new Re(3, 1, 1, 1), new Re(1, 1, 1, 1), new Re(3, 0, 1, 1), new Re(1, 0, 1, 1)], this._cubeDirections = [new Le(1, 0, 0), new Le(-1, 0, 0), new Le(0, 0, 1), new Le(0, 0, -1), new Le(0, 1, 0), new Le(0, -1, 0)], this._cubeUps = [new Le(0, 1, 0), new Le(0, 1, 0), new Le(0, 1, 0), new Le(0, 1, 0), new Le(0, 0, 1), new Le(0, 0, -1)] } updateMatrices(e, t = 0) { const n = this.camera, r = this.matrix, i = e.distance || n.far; i !== n.far && (n.far = i, n.updateProjectionMatrix()), sc.setFromMatrixPosition(e.matrixWorld), n.position.copy(sc), oc.copy(n.position), oc.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(oc), n.updateMatrixWorld(), r.makeTranslation(-sc.x, -sc.y, -sc.z), ac.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ac) } } lc.prototype.isPointLightShadow = !0; class cc extends Kl { constructor(e, t, n = 0, r = 1) { super(e, t), this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new lc } get power() { return 4 * this.intensity * Math.PI } set power(e) { this.intensity = e / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } } cc.prototype.isPointLight = !0; class hc extends nc { constructor() { super(new Er(-5, 5, 5, -5, .5, 500)) } } hc.prototype.isDirectionalLightShadow = !0; class uc extends Kl { constructor(e, t) { super(e, t), this.type = "DirectionalLight", this.position.copy(u.DefaultUp), this.updateMatrix(), this.target = new u, this.shadow = new hc } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } uc.prototype.isDirectionalLight = !0; class dc extends Kl { constructor(e, t) { super(e, t), this.type = "AmbientLight" } } dc.prototype.isAmbientLight = !0; class pc extends Kl { constructor(e, t, n = 10, r = 10) { super(e, t), this.type = "RectAreaLight", this.width = n, this.height = r } copy(e) { return super.copy(e), this.width = e.width, this.height = e.height, this } toJSON(e) { const t = super.toJSON(e); return t.object.width = this.width, t.object.height = this.height, t } } pc.prototype.isRectAreaLight = !0; class mc { constructor() { this.coefficients = []; for (let e = 0; e < 9; e++)this.coefficients.push(new Le) } set(t) { for (let e = 0; e < 9; e++)this.coefficients[e].copy(t[e]); return this } zero() { for (let e = 0; e < 9; e++)this.coefficients[e].set(0, 0, 0); return this } getAt(e, t) { var n = e.x, r = e.y, e = e.z, i = this.coefficients; return t.copy(i[0]).multiplyScalar(.282095), t.addScaledVector(i[1], .488603 * r), t.addScaledVector(i[2], .488603 * e), t.addScaledVector(i[3], .488603 * n), t.addScaledVector(i[4], n * r * 1.092548), t.addScaledVector(i[5], r * e * 1.092548), t.addScaledVector(i[6], .315392 * (3 * e * e - 1)), t.addScaledVector(i[7], n * e * 1.092548), t.addScaledVector(i[8], .546274 * (n * n - r * r)), t } getIrradianceAt(e, t) { var n = e.x, r = e.y, e = e.z, i = this.coefficients; return t.copy(i[0]).multiplyScalar(.886227), t.addScaledVector(i[1], 1.023328 * r), t.addScaledVector(i[2], 1.023328 * e), t.addScaledVector(i[3], 1.023328 * n), t.addScaledVector(i[4], .858086 * n * r), t.addScaledVector(i[5], .858086 * r * e), t.addScaledVector(i[6], .743125 * e * e - .247708), t.addScaledVector(i[7], .858086 * n * e), t.addScaledVector(i[8], .429043 * (n * n - r * r)), t } add(t) { for (let e = 0; e < 9; e++)this.coefficients[e].add(t.coefficients[e]); return this } addScaledSH(t, n) { for (let e = 0; e < 9; e++)this.coefficients[e].addScaledVector(t.coefficients[e], n); return this } scale(t) { for (let e = 0; e < 9; e++)this.coefficients[e].multiplyScalar(t); return this } lerp(t, n) { for (let e = 0; e < 9; e++)this.coefficients[e].lerp(t.coefficients[e], n); return this } equals(t) { for (let e = 0; e < 9; e++)if (!this.coefficients[e].equals(t.coefficients[e])) return !1; return !0 } copy(e) { return this.set(e.coefficients) } clone() { return (new this.constructor).copy(this) } fromArray(t, n = 0) { const r = this.coefficients; for (let e = 0; e < 9; e++)r[e].fromArray(t, n + 3 * e); return this } toArray(t = [], n = 0) { const r = this.coefficients; for (let e = 0; e < 9; e++)r[e].toArray(t, n + 3 * e); return t } static getBasisAt(e, t) { var n = e.x, r = e.y, e = e.z; t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * e, t[3] = .488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * e, t[6] = .315392 * (3 * e * e - 1), t[7] = 1.092548 * n * e, t[8] = .546274 * (n * n - r * r) } } mc.prototype.isSphericalHarmonics3 = !0; class fc extends Kl { constructor(e = new mc, t = 1) { super(void 0, t), this.sh = e } copy(e) { return super.copy(e), this.sh.copy(e.sh), this } fromJSON(e) { return this.intensity = e.intensity, this.sh.fromArray(e.sh), this } toJSON(e) { const t = super.toJSON(e); return t.object.sh = this.sh.toArray(), t } } fc.prototype.isLightProbe = !0; class gc extends l { constructor(e) { super(e), this.textures = {} } load(t, n, e, r) { const i = this, a = new Vl(i.manager); a.setPath(i.path), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(t, function (e) { try { n(i.parse(JSON.parse(e))) } catch (e) { r ? r(e) : console.error(e), i.manager.itemError(t) } }, e, r) } parse(t) { const n = this.textures; function e(e) { return void 0 === n[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), n[e] } const r = new El[t.type]; if (void 0 !== t.uuid && (r.uuid = t.uuid), void 0 !== t.name && (r.name = t.name), void 0 !== t.color && void 0 !== r.color && r.color.setHex(t.color), void 0 !== t.roughness && (r.roughness = t.roughness), void 0 !== t.metalness && (r.metalness = t.metalness), void 0 !== t.sheen && (r.sheen = (new y).setHex(t.sheen)), void 0 !== t.emissive && void 0 !== r.emissive && r.emissive.setHex(t.emissive), void 0 !== t.specular && void 0 !== r.specular && r.specular.setHex(t.specular), void 0 !== t.specularIntensity && (r.specularIntensity = t.specularIntensity), void 0 !== t.specularTint && void 0 !== r.specularTint && r.specularTint.setHex(t.specularTint), void 0 !== t.shininess && (r.shininess = t.shininess), void 0 !== t.clearcoat && (r.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (r.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.transmission && (r.transmission = t.transmission), void 0 !== t.thickness && (r.thickness = t.thickness), void 0 !== t.attenuationDistance && (r.attenuationDistance = t.attenuationDistance), void 0 !== t.attenuationTint && void 0 !== r.attenuationTint && r.attenuationTint.setHex(t.attenuationTint), void 0 !== t.fog && (r.fog = t.fog), void 0 !== t.flatShading && (r.flatShading = t.flatShading), void 0 !== t.blending && (r.blending = t.blending), void 0 !== t.combine && (r.combine = t.combine), void 0 !== t.side && (r.side = t.side), void 0 !== t.shadowSide && (r.shadowSide = t.shadowSide), void 0 !== t.opacity && (r.opacity = t.opacity), void 0 !== t.transparent && (r.transparent = t.transparent), void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest), void 0 !== t.depthTest && (r.depthTest = t.depthTest), void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (r.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (r.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (r.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (r.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (r.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (r.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (r.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (r.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (r.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (r.rotation = t.rotation), 1 !== t.linewidth && (r.linewidth = t.linewidth), void 0 !== t.dashSize && (r.dashSize = t.dashSize), void 0 !== t.gapSize && (r.gapSize = t.gapSize), void 0 !== t.scale && (r.scale = t.scale), void 0 !== t.polygonOffset && (r.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (r.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (r.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.dithering && (r.dithering = t.dithering), void 0 !== t.alphaToCoverage && (r.alphaToCoverage = t.alphaToCoverage), void 0 !== t.premultipliedAlpha && (r.premultipliedAlpha = t.premultipliedAlpha), void 0 !== t.visible && (r.visible = t.visible), void 0 !== t.toneMapped && (r.toneMapped = t.toneMapped), void 0 !== t.userData && (r.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? r.vertexColors = 0 < t.vertexColors : r.vertexColors = t.vertexColors), void 0 !== t.uniforms) for (const n in t.uniforms) { var i = t.uniforms[n]; switch (r.uniforms[n] = {}, i.type) { case "t": r.uniforms[n].value = e(i.value); break; case "c": r.uniforms[n].value = (new y).setHex(i.value); break; case "v2": r.uniforms[n].value = (new k).fromArray(i.value); break; case "v3": r.uniforms[n].value = (new Le).fromArray(i.value); break; case "v4": r.uniforms[n].value = (new Re).fromArray(i.value); break; case "m3": r.uniforms[n].value = (new v).fromArray(i.value); break; case "m4": r.uniforms[n].value = (new Ce).fromArray(i.value); break; default: r.uniforms[n].value = i.value } } if (void 0 !== t.defines && (r.defines = t.defines), void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader), void 0 !== t.extensions) for (const n in t.extensions) r.extensions[n] = t.extensions[n]; if (void 0 !== t.shading && (r.flatShading = 1 === t.shading), void 0 !== t.size && (r.size = t.size), void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (r.map = e(t.map)), void 0 !== t.matcap && (r.matcap = e(t.matcap)), void 0 !== t.alphaMap && (r.alphaMap = e(t.alphaMap)), void 0 !== t.bumpMap && (r.bumpMap = e(t.bumpMap)), void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale), void 0 !== t.normalMap && (r.normalMap = e(t.normalMap)), void 0 !== t.normalMapType && (r.normalMapType = t.normalMapType), void 0 !== t.normalScale) { let e = t.normalScale; !1 === Array.isArray(e) && (e = [e, e]), r.normalScale = (new k).fromArray(e) } return void 0 !== t.displacementMap && (r.displacementMap = e(t.displacementMap)), void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (r.roughnessMap = e(t.roughnessMap)), void 0 !== t.metalnessMap && (r.metalnessMap = e(t.metalnessMap)), void 0 !== t.emissiveMap && (r.emissiveMap = e(t.emissiveMap)), void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (r.specularMap = e(t.specularMap)), void 0 !== t.specularIntensityMap && (r.specularIntensityMap = e(t.specularIntensityMap)), void 0 !== t.specularTintMap && (r.specularTintMap = e(t.specularTintMap)), void 0 !== t.envMap && (r.envMap = e(t.envMap)), void 0 !== t.envMapIntensity && (r.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (r.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (r.lightMap = e(t.lightMap)), void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (r.aoMap = e(t.aoMap)), void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (r.gradientMap = e(t.gradientMap)), void 0 !== t.clearcoatMap && (r.clearcoatMap = e(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = e(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (r.clearcoatNormalMap = e(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (r.clearcoatNormalScale = (new k).fromArray(t.clearcoatNormalScale)), void 0 !== t.transmissionMap && (r.transmissionMap = e(t.transmissionMap)), void 0 !== t.thicknessMap && (r.thicknessMap = e(t.thicknessMap)), r } setTextures(e) { return this.textures = e, this } } class vc { static decodeText(n) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(n); let r = ""; for (let e = 0, t = n.length; e < t; e++)r += String.fromCharCode(n[e]); try { return decodeURIComponent(escape(r)) } catch (n) { return r } } static extractUrlBase(e) { var t = e.lastIndexOf("/"); return -1 === t ? "./" : e.substr(0, t + 1) } } class yc extends T { constructor() { super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } copy(e) { return super.copy(e), this.instanceCount = e.instanceCount, this } clone() { return (new this.constructor).copy(this) } toJSON() { const e = super.toJSON(this); return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e } } yc.prototype.isInstancedBufferGeometry = !0; class xc extends E { constructor(e, t, n, r = 1) { "number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(e, t, n), this.meshPerAttribute = r } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } toJSON() { const e = super.toJSON(); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } } xc.prototype.isInstancedBufferAttribute = !0; class _c extends l { constructor(e) { super(e) } load(t, n, e, r) { const i = this, a = new Vl(i.manager); a.setPath(i.path), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(t, function (e) { try { n(i.parse(JSON.parse(e))) } catch (e) { r ? r(e) : console.error(e), i.manager.itemError(t) } }, e, r) } parse(n) { const s = {}, o = {}; function r(e, t) { if (void 0 !== s[t]) return s[t]; const n = e.interleavedBuffers[t], r = function (e, t) { if (void 0 !== o[t]) return o[t]; e = e.arrayBuffers[t], e = new Uint32Array(e).buffer; return o[t] = e }(e, n.buffer), i = Ln(n.type, r), a = new $a(i, n.stride); return a.uuid = n.uuid, s[t] = a } const i = new (n.isInstancedBufferGeometry ? yc : T), a = n.data.index; if (void 0 !== a) { const n = Ln(a.type, a.array); i.setIndex(new E(n, 1)) } var t = n.data.attributes; for (const s in t) { const o = t[s]; let e; if (o.isInterleavedBufferAttribute) { const s = r(n.data, o.data); e = new es(s, o.itemSize, o.offset, o.normalized) } else { const n = Ln(o.type, o.array); e = new (o.isInstancedBufferAttribute ? xc : E)(n, o.itemSize, o.normalized) } void 0 !== o.name && (e.name = o.name), void 0 !== o.usage && e.setUsage(o.usage), void 0 !== o.updateRange && (e.updateRange.offset = o.updateRange.offset, e.updateRange.count = o.updateRange.count), i.setAttribute(s, e) } var e = n.data.morphAttributes; if (e) for (const s in e) { const o = e[s], a = []; for (let t = 0, e = o.length; t < e; t++) { const i = o[t]; let e; if (i.isInterleavedBufferAttribute) { const s = r(n.data, i.data); e = new es(s, i.itemSize, i.offset, i.normalized) } else { const n = Ln(i.type, i.array); e = new E(n, i.itemSize, i.normalized) } void 0 !== i.name && (e.name = i.name), a.push(e) } i.morphAttributes[s] = a } n.data.morphTargetsRelative && (i.morphTargetsRelative = !0); var l = n.data.groups || n.data.drawcalls || n.data.offsets; if (void 0 !== l) for (let e = 0, t = l.length; e !== t; ++e) { const s = l[e]; i.addGroup(s.start, s.count, s.materialIndex) } var c = n.data.boundingSphere; if (void 0 !== c) { const n = new Le; void 0 !== c.center && n.fromArray(c.center), i.boundingSphere = new xt(n, c.radius) } return n.name && (i.name = n.name), n.userData && (i.userData = n.userData), i } } const bc = { UVMapping: L, CubeReflectionMapping: P, CubeRefractionMapping: I, EquirectangularReflectionMapping: D, EquirectangularRefractionMapping: N, CubeUVReflectionMapping: H, CubeUVRefractionMapping: O }, Mc = { RepeatWrapping: U, ClampToEdgeWrapping: Pe, MirroredRepeatWrapping: z }, wc = { NearestFilter: Ae, NearestMipmapNearestFilter: G, NearestMipmapLinearFilter: W, LinearFilter: B, LinearMipmapNearestFilter: j, LinearMipmapLinearFilter: Ie }; class Tc extends l { constructor(e) { super(e), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } } setOptions(e) { return this.options = e, this } load(t, n, e, r) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const i = this, a = Ul.get(t); if (void 0 !== a) return i.manager.itemStart(t), setTimeout(function () { n && n(a), i.manager.itemEnd(t) }, 0), a; const s = {}; s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", s.headers = this.requestHeader, fetch(t, s).then(function (e) { return e.blob() }).then(function (e) { return createImageBitmap(e, Object.assign(i.options, { colorSpaceConversion: "none" })) }).then(function (e) { Ul.add(t, e), n && n(e), i.manager.itemEnd(t) }).catch(function (e) { r && r(e), i.manager.itemError(t), i.manager.itemEnd(t) }), i.manager.itemStart(t) } } class Ec { constructor() { this.type = "ShapePath", this.color = new y, this.subPaths = [], this.currentPath = null } moveTo(e, t) { return this.currentPath = new Zl, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this } lineTo(e, t) { return this.currentPath.lineTo(e, t), this } quadraticCurveTo(e, t, n, r) { return this.currentPath.quadraticCurveTo(e, t, n, r), this } bezierCurveTo(e, t, n, r, i, a) { return this.currentPath.bezierCurveTo(e, t, n, r, i, a), this } splineThru(e) { return this.currentPath.splineThru(e), this } toShapes(n, a) { function e(n) { const r = []; for (let e = 0, t = n.length; e < t; e++) { const i = n[e], a = new Jl; a.curves = i.curves, r.push(a) } return r } const s = Jo.isClockWise, r = this.subPaths; if (0 === r.length) return []; if (!0 === a) return e(r); let o, i, l; const t = []; if (1 === r.length) return i = r[0], (l = new Jl).curves = i.curves, t.push(l), t; let c = !s(r[0].getPoints()); c = n ? !c : c; const h = [], u = []; let d, p, m = [], f = 0; u[f] = void 0, m[f] = []; for (let e = 0, t = r.length; e < t; e++)d = (i = r[e]).getPoints(), o = s(d), (o = n ? !o : o) ? (!c && u[f] && f++, u[f] = { s: new Jl, p: d }, u[f].s.curves = i.curves, c && f++, m[f] = []) : m[f].push({ h: i, p: d[0] }); if (!u[0]) return e(r); if (1 < u.length) { let i = !1; const a = []; for (let e = 0, t = u.length; e < t; e++)h[e] = []; for (let r = 0, e = u.length; r < e; r++) { const s = m[r]; for (let n = 0; n < s.length; n++) { const o = s[n]; let t = !0; for (let e = 0; e < u.length; e++)!function (s, o) { var e = o.length; let l = !1; for (let i = e - 1, a = 0; a < e; i = a++) { let e = o[i], t = o[a], n = t.x - e.x, r = t.y - e.y; if (Math.abs(r) > Number.EPSILON) { if (r < 0 && (e = o[a], n = -n, t = o[i], r = -r), !(s.y < e.y || s.y > t.y)) if (s.y === e.y) { if (s.x === e.x) return 1 } else { const o = r * (s.x - e.x) - n * (s.y - e.y); if (0 == o) return 1; o < 0 || (l = !l) } } else if (s.y === e.y && (t.x <= s.x && s.x <= e.x || e.x <= s.x && s.x <= t.x)) return 1 } return l }(o.p, u[e].p) || (r !== e && a.push({ froms: r, tos: e, hole: n }), t ? (t = !1, h[e].push(o)) : i = !0); t && h[r].push(o) } } 0 < a.length && (i || (m = h)) } for (let n = 0, e = u.length; n < e; n++) { l = u[n].s, t.push(l); for (let e = 0, t = (p = m[n]).length; e < t; e++)l.holes.push(p[e].h) } return t } } class Sc { constructor(e) { this.type = "Font", this.data = e } generateShapes(e, t = 100) { const n = [], r = function (t, n, r) { const i = Array.from(t), a = n / r.resolution, s = (r.boundingBox.yMax - r.boundingBox.yMin + r.underlineThickness) * a, o = []; let l = 0, c = 0; for (let e = 0; e < i.length; e++) { const n = i[e]; if ("\n" === n) l = 0, c -= s; else { const t = function (h, u, d, p, e) { const t = e.glyphs[h] || e.glyphs["?"]; if (t) { const m = new Ec; let n, r, i, a, s, o, l, c; if (t.o) { const h = t._cachedOutline || (t._cachedOutline = t.o.split(" ")); for (let e = 0, t = h.length; e < t;)switch (h[e++]) { case "m": n = h[e++] * u + d, r = h[e++] * u + p, m.moveTo(n, r); break; case "l": n = h[e++] * u + d, r = h[e++] * u + p, m.lineTo(n, r); break; case "q": i = h[e++] * u + d, a = h[e++] * u + p, s = h[e++] * u + d, o = h[e++] * u + p, m.quadraticCurveTo(s, o, i, a); break; case "b": i = h[e++] * u + d, a = h[e++] * u + p, s = h[e++] * u + d, o = h[e++] * u + p, l = h[e++] * u + d, c = h[e++] * u + p, m.bezierCurveTo(s, o, l, c, i, a) } } return { offsetX: t.ha * u, path: m } } console.error('THREE.Font: character "' + h + '" does not exists in font family ' + e.familyName + ".") }(n, a, l, c, r); l += t.offsetX, o.push(t.path) } } return o }(e, t, this.data); for (let e = 0, t = r.length; e < t; e++)Array.prototype.push.apply(n, r[e].toShapes()); return n } } Sc.prototype.isFont = Tc.prototype.isImageBitmapLoader = !0; let Ac; const Rc = { getContext: function () { return Ac = void 0 === Ac ? new (window.AudioContext || window.webkitAudioContext) : Ac }, setContext: function (e) { Ac = e } }; class Lc extends l { constructor(e) { super(e) } load(t, n, e, r) { const i = this, a = new Vl(this.manager); a.setResponseType("arraybuffer"), a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, function (e) { try { const t = e.slice(0); Rc.getContext().decodeAudioData(t, function (e) { n(e) }) } catch (e) { r ? r(e) : console.error(e), i.manager.itemError(t) } }, e, r) } } class Cc extends fc { constructor(e, t, n = 1) { super(void 0, n); var n = (new y).set(e), e = (new y).set(t), t = new Le(n.r, n.g, n.b), n = new Le(e.r, e.g, e.b), e = Math.sqrt(Math.PI), r = e * Math.sqrt(.75); this.sh.coefficients[0].copy(t).add(n).multiplyScalar(e), this.sh.coefficients[1].copy(t).sub(n).multiplyScalar(r) } } class Pc extends fc { constructor(e, t = 1) { super(void 0, t); t = (new y).set(e); this.sh.coefficients[0].set(t.r, t.g, t.b).multiplyScalar(2 * Math.sqrt(Math.PI)) } } Pc.prototype.isAmbientLightProbe = Cc.prototype.isHemisphereLightProbe = !0; const Ic = new Ce, Dc = new Ce; class Nc { constructor(e = !0) { this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start() { this.startTime = Hc(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime() { return this.getDelta(), this.elapsedTime } getDelta() { let e = 0; return this.autoStart && !this.running ? (this.start(), 0) : (this.running && (t = Hc(), e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e), e); var t } } function Hc() { return ("undefined" == typeof performance ? Date : performance).now() } const Oc = new Le, Fc = new f, Bc = new Le, Uc = new Le; class zc extends u { constructor(e) { super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] } getOutput() { return this.gain } setNodeSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this } setMediaElementSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this } setMediaStreamSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this } setBuffer(e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this } play(e = 0) { if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing."); else { if (!1 !== this.hasPlaybackControl) { this._startedAt = this.context.currentTime + e; const t = this.context.createBufferSource(); return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } console.warn("THREE.Audio: this Audio has no playback control.") } } pause() { if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this; console.warn("THREE.Audio: this Audio has no playback control.") } stop() { if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this; console.warn("THREE.Audio: this Audio has no playback control.") } connect() { if (0 < this.filters.length) { this.source.connect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].connect(this.filters[e]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } disconnect() { if (0 < this.filters.length) { this.source.disconnect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].disconnect(this.filters[e]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } getFilters() { return this.filters } setFilters(e) { return e = e || [], !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this } setDetune(e) { if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } getDetune() { return this.detune } getFilter() { return this.getFilters()[0] } setFilter(e) { return this.setFilters(e ? [e] : []) } setPlaybackRate(e) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this; console.warn("THREE.Audio: this Audio has no playback control.") } getPlaybackRate() { return this.playbackRate } onEnded() { this.isPlaying = !1 } getLoop() { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } setLoop(e) { if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this; console.warn("THREE.Audio: this Audio has no playback control.") } setLoopStart(e) { return this.loopStart = e, this } setLoopEnd(e) { return this.loopEnd = e, this } getVolume() { return this.gain.gain.value } setVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } } const Gc = new Le, kc = new f, Vc = new Le, Wc = new Le; class jc { constructor(e, t = 2048) { this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser) } getFrequencyData() { return this.analyser.getByteFrequencyData(this.data), this.data } getAverageFrequency() { let t = 0; var n = this.getFrequencyData(); for (let e = 0; e < n.length; e++)t += n[e]; return t / n.length } } class qc { constructor(e, t, n) { let r, i, a; switch (this.binding = e, this.valueSize = n, t) { case "quaternion": r = this._slerp, i = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5; break; case "string": case "bool": r = this._select, i = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n); break; default: r = this._lerp, i = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n) }this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate(e, t) { const n = this.buffer, r = this.valueSize, i = e * r + r; let a = this.cumulativeWeight; if (0 === a) { for (let e = 0; e !== r; ++e)n[i + e] = n[e]; a = t } else { const e = t / (a += t); this._mixBufferRegion(n, i, 0, e, r) } this.cumulativeWeight = a } accumulateAdditive(e) { var t = this.buffer, n = this.valueSize, r = n * this._addIndex; 0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, n), this.cumulativeWeightAdditive += e } apply(e) { const n = this.valueSize, r = this.buffer, i = e * n + n, t = this.cumulativeWeight, a = this.cumulativeWeightAdditive, s = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, t < 1) { const e = n * this._origIndex; this._mixBufferRegion(r, i, e, 1 - t, n) } 0 < a && this._mixBufferRegionAdditive(r, i, this._addIndex * n, 1, n); for (let e = n, t = n + n; e !== t; ++e)if (r[e] !== r[e + n]) { s.setValue(r, i); break } } saveOriginalState() { const e = this.binding, n = this.buffer, r = this.valueSize, i = r * this._origIndex; e.getValue(n, i); for (let e = r, t = i; e !== t; ++e)n[e] = n[i + e % r]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState() { var e = 3 * this.valueSize; this.binding.setValue(this.buffer, e) } _setAdditiveIdentityNumeric() { var t = this._addIndex * this.valueSize, n = t + this.valueSize; for (let e = t; e < n; e++)this.buffer[e] = 0 } _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther() { var t = this._origIndex * this.valueSize, n = this._addIndex * this.valueSize; for (let e = 0; e < this.valueSize; e++)this.buffer[n + e] = this.buffer[t + e] } _select(t, n, r, e, i) { if (.5 <= e) for (let e = 0; e !== i; ++e)t[n + e] = t[r + e] } _slerp(e, t, n, r) { f.slerpFlat(e, t, e, t, e, n, r) } _slerpAdditive(e, t, n, r, i) { i = this._workIndex * i; f.multiplyQuaternionsFlat(e, i, e, t, e, n), f.slerpFlat(e, t, e, t, e, i, r) } _lerp(t, n, r, i, a) { var s = 1 - i; for (let e = 0; e !== a; ++e) { const a = n + e; t[a] = t[a] * s + t[r + e] * i } } _lerpAdditive(t, n, r, i, a) { for (let e = 0; e !== a; ++e) { const a = n + e; t[a] = t[a] + t[r + e] * i } } } const Xc = new RegExp("[\\[\\]\\.:\\/]", "g"), Yc = "[^\\[\\]\\.:\\/]", Zc = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", Jc = /((?:WC+[\/:])*)/.source.replace("WC", Yc), Kc = /(WCOD+)?/.source.replace("WCOD", Zc), Qc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Yc), $c = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Yc), eh = new RegExp("^" + Jc + Kc + Qc + $c + "$"), th = ["material", "materials", "bones"]; class M { constructor(e, t, n) { this.path = t, this.parsedPath = n || M.parseTrackName(t), this.node = M.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(e, t, n) { return new (e && e.isAnimationObjectGroup ? M.Composite : M)(e, t, n) } static sanitizeNodeName(e) { return e.replace(/\s/g, "_").replace(Xc, "") } static parseTrackName(e) { var t = eh.exec(e); if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e); const n = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, r = n.nodeName && n.nodeName.lastIndexOf("."); if (void 0 !== r && -1 !== r) { const e = n.nodeName.substring(r + 1); -1 !== th.indexOf(e) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = e) } if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return n } static findNode(e, r) { if (!r || "" === r || "." === r || -1 === r || r === e.name || r === e.uuid) return e; if (e.skeleton) { var t = e.skeleton.getBoneByName(r); if (void 0 !== t) return t } if (e.children) { const i = function (t) { for (let e = 0; e < t.length; e++) { var n = t[e]; if (n.name === r || n.uuid === r) return n; n = i(n.children); if (n) return n } return null }, n = i(e.children); if (n) return n } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(e, t) { e[t] = this.node[this.propertyName] } _getValue_array(n, r) { var i = this.resolvedProperty; for (let e = 0, t = i.length; e !== t; ++e)n[r++] = i[e] } _getValue_arrayElement(e, t) { e[t] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(e, t) { this.resolvedProperty.toArray(e, t) } _setValue_direct(e, t) { this.targetObject[this.propertyName] = e[t] } _setValue_direct_setNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(n, r) { const i = this.resolvedProperty; for (let e = 0, t = i.length; e !== t; ++e)i[e] = n[r++] } _setValue_array_setNeedsUpdate(n, r) { const i = this.resolvedProperty; for (let e = 0, t = i.length; e !== t; ++e)i[e] = n[r++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(n, r) { const i = this.resolvedProperty; for (let e = 0, t = i.length; e !== t; ++e)i[e] = n[r++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(e, t) { this.resolvedProperty[this.propertyIndex] = e[t] } _setValue_arrayElement_setNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(e, t) { this.resolvedProperty.fromArray(e, t) } _setValue_fromArray_setNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(e, t) { this.bind(), this.getValue(e, t) } _setValue_unbound(e, t) { this.bind(), this.setValue(e, t) } bind() { let n = this.node; const e = this.parsedPath, r = e.objectName, i = e.propertyName; let a = e.propertyIndex; if (n || (n = M.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = n), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, n) { if (r) { let t = e.objectIndex; switch (r) { case "materials": if (!n.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!n.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); n = n.material.materials; break; case "bones": if (!n.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); n = n.skeleton.bones; for (let e = 0; e < n.length; e++)if (n[e].name === t) { t = e; break } break; default: if (void 0 === n[r]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); n = n[r] }if (void 0 !== t) { if (void 0 === n[t]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, n); n = n[t] } } var s = n[i]; if (void 0 === s) { const r = e.nodeName; void console.error("THREE.PropertyBinding: Trying to update property for track: " + r + "." + i + " but it wasn't found.", n) } else { let e = this.Versioning.None, t = (void 0 !== (this.targetObject = n).needsUpdate ? e = this.Versioning.NeedsUpdate : void 0 !== n.matrixWorldNeedsUpdate && (e = this.Versioning.MatrixWorldNeedsUpdate), this.BindingType.Direct); if (void 0 !== a) { if ("morphTargetInfluences" === i) { if (!n.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (!n.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this); if (!n.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); void 0 !== n.morphTargetDictionary[a] && (a = n.morphTargetDictionary[a]) } t = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = a } else void 0 !== s.fromArray && void 0 !== s.toArray ? (t = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (t = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i; this.getValue = this.GetterByBindingType[t], this.setValue = this.SetterByBindingTypeAndVersioning[t][e] } } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.") } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } M.Composite = class { constructor(e, t, n) { n = n || M.parseTrackName(t); this._targetGroup = e, this._bindings = e.subscribe_(t, n) } getValue(e, t) { this.bind(); const n = this._targetGroup.nCachedObjects_, r = this._bindings[n]; void 0 !== r && r.getValue(e, t) } setValue(n, r) { const i = this._bindings; for (let e = this._targetGroup.nCachedObjects_, t = i.length; e !== t; ++e)i[e].setValue(n, r) } bind() { const n = this._bindings; for (let e = this._targetGroup.nCachedObjects_, t = n.length; e !== t; ++e)n[e].bind() } unbind() { const n = this._bindings; for (let e = this._targetGroup.nCachedObjects_, t = n.length; e !== t; ++e)n[e].unbind() } }, M.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, M.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, M.prototype.GetterByBindingType = [M.prototype._getValue_direct, M.prototype._getValue_array, M.prototype._getValue_arrayElement, M.prototype._getValue_toArray], M.prototype.SetterByBindingTypeAndVersioning = [[M.prototype._setValue_direct, M.prototype._setValue_direct_setNeedsUpdate, M.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [M.prototype._setValue_array, M.prototype._setValue_array_setNeedsUpdate, M.prototype._setValue_array_setMatrixWorldNeedsUpdate], [M.prototype._setValue_arrayElement, M.prototype._setValue_arrayElement_setNeedsUpdate, M.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [M.prototype._setValue_fromArray, M.prototype._setValue_fromArray_setNeedsUpdate, M.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; class nh { constructor() { this.uuid = Be(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; const n = {}; this._indicesByUUID = n; for (let e = 0, t = arguments.length; e !== t; ++e)n[arguments[e].uuid] = e; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; const e = this; this.stats = { objects: { get total() { return e._objects.length }, get inUse() { return this.total - e.nCachedObjects_ } }, get bindingsPerObject() { return e._bindings.length } } } add() { const r = this._objects, i = this._indicesByUUID, a = this._paths, s = this._parsedPaths, o = this._bindings, l = o.length; let c, h = r.length, u = this.nCachedObjects_; for (let e = 0, t = arguments.length; e !== t; ++e) { var d = arguments[e], p = d.uuid; let n = i[p]; if (void 0 === n) { n = h++, i[p] = n, r.push(d); for (let e = 0, t = l; e !== t; ++e)o[e].push(new M(d, a[e], s[e])) } else if (n < u) { c = r[n]; const h = --u, m = r[h]; i[m.uuid] = n, r[n] = m, i[p] = h, r[h] = d; for (let t = 0, e = l; t !== e; ++t) { const i = o[t], l = i[h]; let e = i[n]; i[n] = l, void 0 === e && (e = new M(d, a[t], s[t])), i[h] = e } } else r[n] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = u } remove() { const n = this._objects, r = this._indicesByUUID, i = this._bindings, a = i.length; let s = this.nCachedObjects_; for (let e = 0, t = arguments.length; e !== t; ++e) { var o = arguments[e], l = o.uuid, c = r[l]; if (void 0 !== c && c >= s) { var h = s++, u = n[h]; r[u.uuid] = c, n[c] = u, r[l] = h, n[h] = o; for (let e = 0, t = a; e !== t; ++e) { const r = i[e], a = r[h], s = r[c]; r[c] = a, r[h] = s } } } this.nCachedObjects_ = s } uncache() { const n = this._objects, r = this._indicesByUUID, i = this._bindings, a = i.length; let s = this.nCachedObjects_, o = n.length; for (let e = 0, t = arguments.length; e !== t; ++e) { var l = arguments[e].uuid, c = r[l]; if (void 0 !== c) if (delete r[l], c < s) { var h = --s, l = n[h], u = --o, d = n[u]; r[l.uuid] = c, n[c] = l, r[d.uuid] = h, n[h] = d, n.pop(); for (let e = 0, t = a; e !== t; ++e) { const r = i[e], a = r[h], s = r[u]; r[c] = a, r[h] = s, r.pop() } } else { const s = --o, p = n[s]; 0 < s && (r[p.uuid] = c), n[c] = p, n.pop(); for (let e = 0, t = a; e !== t; ++e) { const r = i[e]; r[c] = r[s], r.pop() } } } this.nCachedObjects_ = s } subscribe_(n, r) { const e = this._bindingsIndicesByPath; let i = e[n]; const t = this._bindings; if (void 0 !== i) return t[i]; const a = this._paths, s = this._parsedPaths, o = this._objects, l = o.length, c = this.nCachedObjects_, h = new Array(l); i = t.length, e[n] = i, a.push(n), s.push(r), t.push(h); for (let e = c, t = o.length; e !== t; ++e) { const i = o[e]; h[e] = new M(i, n, r) } return h } unsubscribe_(e) { const t = this._bindingsIndicesByPath, n = t[e]; if (void 0 !== n) { const r = this._paths, i = this._parsedPaths, a = this._bindings, s = a.length - 1, o = a[s]; t[e[s]] = n, a[n] = o, a.pop(), i[n] = i[s], i.pop(), r[n] = r[s], r.pop() } } } nh.prototype.isAnimationObjectGroup = !0; class rh { constructor(e, t, n = null, r = t.blendMode) { this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = r; const i = t.tracks, a = i.length, s = new Array(a), o = { endingStart: ue, endingEnd: ue }; for (let e = 0; e !== a; ++e) { const t = i[e].createInterpolant(null); (s[e] = t).settings = o } this._interpolantSettings = o, this._interpolants = s, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(e) { return this._startTime = e, this } setLoop(e, t) { return this.loop = e, this.repetitions = t, this } setEffectiveWeight(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(e) { return this._scheduleFading(e, 0, 1) } fadeOut(e) { return this._scheduleFading(e, 1, 0) } crossFadeFrom(e, t, n) { if (e.fadeOut(t), this.fadeIn(t), n) { const n = this._clip.duration, r = e._clip.duration, i = r / n, a = n / r; e.warp(1, i, t), this.warp(a, 1, t) } return this } crossFadeTo(e, t, n) { return e.crossFadeFrom(this, t, n) } stopFading() { var e = this._weightInterpolant; return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } setEffectiveTimeScale(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() } syncWith(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() } halt(e) { return this.warp(this._effectiveTimeScale, 0, e) } warp(e, t, n) { const r = this._mixer, i = r.time, a = this.timeScale; let s = this._timeScaleInterpolant; null === s && (s = r._lendControlInterpolant(), this._timeScaleInterpolant = s); const o = s.parameterPositions, l = s.sampleValues; return o[0] = i, o[1] = i + n, l[0] = e / a, l[1] = t / a, this } stopWarping() { var e = this._timeScaleInterpolant; return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(n, r, e, i) { if (this.enabled) { var t = this._startTime; if (null !== t) { const i = (n - t) * e; if (i < 0 || 0 === e) return; this._startTime = null, r = e * i } r *= this._updateTimeScale(n); var a = this._updateTime(r), s = this._updateWeight(n); if (0 < s) { const n = this._interpolants, r = this._propertyBindings; if (this.blendMode === fe) for (let e = 0, t = n.length; e !== t; ++e)n[e].evaluate(a), r[e].accumulateAdditive(s); else { me; for (let e = 0, t = n.length; e !== t; ++e)n[e].evaluate(a), r[e].accumulate(i, s) } } } else this._updateWeight(n) } _updateWeight(e) { let t = 0; if (this.enabled) { t = this.weight; const r = this._weightInterpolant; var n; null !== r && (n = r.evaluate(e)[0], t *= n, e > r.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))) } return this._effectiveWeight = t } _updateTimeScale(e) { let t = 0; if (!this.paused) { t = this.timeScale; const n = this._timeScaleInterpolant; null !== n && (t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)) } return this._effectiveTimeScale = t } _updateTime(e) { const t = this._clip.duration, n = this.loop; let r = this.time + e, i = this._loopCount; var a = 2202 === n; if (0 === e) return -1 !== i && a && 1 == (1 & i) ? t - r : r; if (2200 === n) { -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (r >= t) r = t; else { if (!(r < 0)) { this.time = r; break e } r = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (-1 === i && (0 <= e ? (i = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), r >= t || r < 0) { const n = Math.floor(r / t); r -= t * n, i += Math.abs(n); var s = this.repetitions - i; if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = 0 < e ? t : 0, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: 0 < e ? 1 : -1 }); else { if (1 == s) { const t = e < 0; this._setEndings(t, !t, a) } else this._setEndings(!1, !1, a); this._loopCount = i, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n }) } } else this.time = r; if (a && 1 == (1 & i)) return t - r } return r } _setEndings(e, t, n) { const r = this._interpolantSettings; n ? (r.endingStart = de, r.endingEnd = de) : (r.endingStart = e ? this.zeroSlopeAtStart ? de : ue : pe, r.endingEnd = t ? this.zeroSlopeAtEnd ? de : ue : pe) } _scheduleFading(e, t, n) { const r = this._mixer, i = r.time; let a = this._weightInterpolant; null === a && (a = r._lendControlInterpolant(), this._weightInterpolant = a); const s = a.parameterPositions, o = a.sampleValues; return s[0] = i, o[0] = t, s[1] = i + e, o[1] = n, this } } class ih extends we { constructor(e) { super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction(e, n) { const r = e._localRoot || this._root, i = e._clip.tracks, a = i.length, s = e._propertyBindings, o = e._interpolants, l = r.uuid, c = this._bindingsByRootAndName; let h = c[l]; void 0 === h && (h = {}, c[l] = h); for (let t = 0; t !== a; ++t) { const a = i[t], c = a.name; let e = h[c]; if (void 0 !== e) s[t] = e; else { if (void 0 !== (e = s[t])) { null === e._cacheIndex && (++e.referenceCount, this._addInactiveBinding(e, l, c)); continue } const i = n && n._propertyBindings[t].binding.parsedPath; ++(e = new qc(M.create(r, c, i), a.ValueTypeName, a.getValueSize())).referenceCount, this._addInactiveBinding(e, l, c), s[t] = e } o[t].resultBuffer = e.buffer } } _activateAction(e) { if (!this._isActiveAction(e)) { null === e._cacheIndex && (t = (e._localRoot || this._root).uuid, n = e._clip.uuid, r = this._actionsByClip[n], this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t)); var t, n, r, i = e._propertyBindings; for (let e = 0, t = i.length; e !== t; ++e) { const a = i[e]; 0 == a.useCount++ && (this._lendBinding(a), a.saveOriginalState()) } this._lendAction(e) } } _deactivateAction(e) { if (this._isActiveAction(e)) { var n = e._propertyBindings; for (let e = 0, t = n.length; e !== t; ++e) { const r = n[e]; 0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r)) } this._takeBackAction(e) } } _initMemoryManager() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const e = this; this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } } _isActiveAction(e) { e = e._cacheIndex; return null !== e && e < this._nActiveActions } _addInactiveAction(e, t, n) { const r = this._actions, i = this._actionsByClip; let a = i[t]; if (void 0 === a) a = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, i[t] = a; else { const t = a.knownActions; e._byClipCacheIndex = t.length, t.push(e) } e._cacheIndex = r.length, r.push(e), a.actionByRoot[n] = e } _removeInactiveAction(e) { const t = this._actions, n = t[t.length - 1], r = e._cacheIndex, i = (n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null, e._clip.uuid), a = this._actionsByClip, s = a[i], o = s.knownActions, l = o[o.length - 1], c = e._byClipCacheIndex; l._byClipCacheIndex = c, o[c] = l, o.pop(), e._byClipCacheIndex = null, delete s.actionByRoot[(e._localRoot || this._root).uuid], 0 === o.length && delete a[i], this._removeInactiveBindingsForAction(e) } _removeInactiveBindingsForAction(e) { var n = e._propertyBindings; for (let e = 0, t = n.length; e !== t; ++e) { const r = n[e]; 0 == --r.referenceCount && this._removeInactiveBinding(r) } } _lendAction(e) { const t = this._actions, n = e._cacheIndex, r = this._nActiveActions++, i = t[r]; e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i } _takeBackAction(e) { const t = this._actions, n = e._cacheIndex, r = --this._nActiveActions, i = t[r]; e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i } _addInactiveBinding(e, t, n) { const r = this._bindingsByRootAndName, i = this._bindings; let a = r[t]; void 0 === a && (a = {}, r[t] = a), (a[n] = e)._cacheIndex = i.length, i.push(e) } _removeInactiveBinding(e) { const t = this._bindings, n = e.binding, r = n.rootNode.uuid, i = n.path, a = this._bindingsByRootAndName, s = a[r], o = t[t.length - 1], l = e._cacheIndex; o._cacheIndex = l, t[l] = o, t.pop(), delete s[i], 0 === Object.keys(s).length && delete a[r] } _lendBinding(e) { const t = this._bindings, n = e._cacheIndex, r = this._nActiveBindings++, i = t[r]; e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i } _takeBackBinding(e) { const t = this._bindings, n = e._cacheIndex, r = --this._nActiveBindings, i = t[r]; e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i } _lendControlInterpolant() { const e = this._controlInterpolants, t = this._nActiveControlInterpolants++; let n = e[t]; return void 0 === n && ((n = new Rl(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t, e[t] = n), n } _takeBackControlInterpolant(e) { const t = this._controlInterpolants, n = e.__cacheIndex, r = --this._nActiveControlInterpolants, i = t[r]; e.__cacheIndex = r, t[r] = e, i.__cacheIndex = n, t[n] = i } clipAction(e, t, n) { var r = t || this._root, i = r.uuid; let a = "string" == typeof e ? Bl.findByName(r, e) : e; var r = null !== a ? a.uuid : e, s = this._actionsByClip[r]; let o = null; if (void 0 === n && (n = null !== a ? a.blendMode : me), void 0 !== s) { const e = s.actionByRoot[i]; if (void 0 !== e && e.blendMode === n) return e; o = s.knownActions[0], null === a && (a = o._clip) } if (null === a) return null; e = new rh(this, a, t, n); return this._bindAction(e, o), this._addInactiveAction(e, r, i), e } existingAction(e, t) { var t = t || this._root, n = t.uuid, t = "string" == typeof e ? Bl.findByName(t, e) : e, t = t ? t.uuid : e, e = this._actionsByClip[t]; return void 0 !== e && e.actionByRoot[n] || null } stopAllAction() { const t = this._actions; for (let e = this._nActiveActions - 1; 0 <= e; --e)t[e].stop(); return this } update(t) { t *= this.timeScale; const n = this._actions, r = this._nActiveActions, i = this.time += t, a = Math.sign(t), s = this._accuIndex ^= 1; for (let e = 0; e !== r; ++e)n[e]._update(i, t, a, s); const o = this._bindings, l = this._nActiveBindings; for (let e = 0; e !== l; ++e)o[e].apply(s); return this } setTime(e) { for (let e = this.time = 0; e < this._actions.length; e++)this._actions[e].time = 0; return this.update(e) } getRoot() { return this._root } uncacheClip(n) { const r = this._actions, e = n.uuid, i = this._actionsByClip, a = i[e]; if (void 0 !== a) { const n = a.knownActions; for (let e = 0, t = n.length; e !== t; ++e) { const i = n[e], a = (this._deactivateAction(i), i._cacheIndex), s = r[r.length - 1]; i._cacheIndex = null, i._byClipCacheIndex = null, s._cacheIndex = a, r[a] = s, r.pop(), this._removeInactiveBindingsForAction(i) } delete i[e] } } uncacheRoot(e) { const t = e.uuid, n = this._actionsByClip; for (const e in n) { const r = n[e].actionByRoot[t]; void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r)) } const r = this._bindingsByRootAndName[t]; if (void 0 !== r) for (const e in r) { const t = r[e]; t.restoreOriginalState(), this._removeInactiveBinding(t) } } uncacheAction(e, t) { e = this.existingAction(e, t); null !== e && (this._deactivateAction(e), this._removeInactiveAction(e)) } } ih.prototype._controlInterpolantsResultBuffer = new Float32Array(1); class ah { constructor(e) { "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e } clone() { return new ah(void 0 === this.value.clone ? this.value : this.value.clone()) } } class sh extends $a { constructor(e, t, n = 1) { super(e, t), this.meshPerAttribute = n } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } clone(e) { const t = super.clone(e); return t.meshPerAttribute = this.meshPerAttribute, t } toJSON(e) { const t = super.toJSON(e); return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t } } class oh { constructor(e, t, n, r, i) { this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = r, this.count = i, this.version = 0 } set needsUpdate(e) { !0 === e && this.version++ } setBuffer(e) { return this.buffer = e, this } setType(e, t) { return this.type = e, this.elementSize = t, this } setItemSize(e) { return this.itemSize = e, this } setCount(e) { return this.count = e, this } } function lh(e, t) { return e.distance - t.distance } function ch(e, n, r, i) { if (e.layers.test(n.layers) && e.raycast(n, r), !0 === i) { const i = e.children; for (let e = 0, t = i.length; e < t; e++)ch(i[e], n, r, !0) } } oh.prototype.isGLBufferAttribute = sh.prototype.isInstancedInterleavedBuffer = !0; const hh = new k; class uh { constructor(e = new k(1 / 0, 1 / 0), t = new k(-1 / 0, -1 / 0)) { this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromPoints(n) { this.makeEmpty(); for (let e = 0, t = n.length; e < t; e++)this.expandByPoint(n[e]); return this } setFromCenterAndSize(e, t) { t = hh.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(t), this.max.copy(e).add(t), this } clone() { return (new this.constructor).copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter(e) { return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return hh.copy(e).clamp(this.min, this.max).sub(e).length() } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } uh.prototype.isBox2 = !0; const dh = new Le, ph = new Le; class mh { constructor(e = new Le, t = new Le) { this.start = e, this.end = t } set(e, t) { return this.start.copy(e), this.end.copy(t), this } copy(e) { return this.start.copy(e.start), this.end.copy(e.end), this } getCenter(e) { return e.addVectors(this.start, this.end).multiplyScalar(.5) } delta(e) { return e.subVectors(this.end, this.start) } distanceSq() { return this.start.distanceToSquared(this.end) } distance() { return this.start.distanceTo(this.end) } at(e, t) { return this.delta(t).multiplyScalar(e).add(this.start) } closestPointToPointParameter(e, t) { dh.subVectors(e, this.start), ph.subVectors(this.end, this.start); e = ph.dot(ph); let n = ph.dot(dh) / e; return n = t ? m(n, 0, 1) : n } closestPointToPoint(e, t, n) { e = this.closestPointToPointParameter(e, t); return this.delta(n).multiplyScalar(e).add(this.start) } applyMatrix4(e) { return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this } equals(e) { return e.start.equals(this.start) && e.end.equals(this.end) } clone() { return (new this.constructor).copy(this) } } class fh extends u { constructor(e) { super(), this.material = e, this.render = function () { }, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0 } } fh.prototype.isImmediateRenderObject = !0; const gh = new Le, vh = new Le, yh = new Ce, xh = new Ce; class _h extends Ws { constructor(e) { const t = function t(n) { const r = []; n && n.isBone && r.push(n); for (let e = 0; e < n.children.length; e++)r.push.apply(r, t(n.children[e])); return r }(e), n = new T, r = [], i = [], a = new y(0, 0, 1), s = new y(0, 1, 0); for (let e = 0; e < t.length; e++) { const n = t[e]; n.parent && n.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(a.r, a.g, a.b), i.push(s.r, s.g, s.b)) } n.setAttribute("position", new V(r, 3)), n.setAttribute("color", new V(i, 3)), super(n, new x({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1 } updateMatrixWorld(e) { const n = this.bones, t = this.geometry, r = t.getAttribute("position"); xh.copy(this.root.matrixWorld).invert(); for (let e = 0, t = 0; e < n.length; e++) { var i = n[e]; i.parent && i.parent.isBone && (yh.multiplyMatrices(xh, i.matrixWorld), vh.setFromMatrixPosition(yh), r.setXYZ(t, vh.x, vh.y, vh.z), yh.multiplyMatrices(xh, i.parent.matrixWorld), vh.setFromMatrixPosition(yh), r.setXYZ(t + 1, vh.x, vh.y, vh.z), t += 2) } t.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e) } } const bh = new Le, Mh = new y, wh = new y; class Th extends Ws { constructor(e = 10, r = 10, i = 4473924, a = 8947848) { i = new y(i), a = new y(a); const s = r / 2, o = e / r, l = e / 2, c = [], h = []; for (let e = 0, t = 0, n = -l; e <= r; e++, n += o) { c.push(-l, 0, n, l, 0, n), c.push(n, 0, -l, n, 0, l); const r = e === s ? i : a; r.toArray(h, t), t += 3, r.toArray(h, t), t += 3, r.toArray(h, t), t += 3, r.toArray(h, t), t += 3 } const t = new T; t.setAttribute("position", new V(c, 3)), t.setAttribute("color", new V(h, 3)), super(t, new x({ vertexColors: !0, toneMapped: !1 })), this.type = "GridHelper" } } const Eh = new Le, Sh = new Le, Ah = new Le, Rh = new Le, d = new ir; function p(n, e, t, r, i, a, s) { Rh.set(i, a, s).unproject(r); var o = e[n]; if (void 0 !== o) { const n = t.getAttribute("position"); for (let e = 0, t = o.length; e < t; e++)n.setXYZ(o[e], Rh.x, Rh.y, Rh.z) } } const Lh = new et; class Ch extends Ws { constructor(e, t = 16776960) { const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(24), i = new T; i.setIndex(new E(n, 1)), i.setAttribute("position", new E(r, 3)), super(i, new x({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update() } update(e) { if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Lh.setFromObject(this.object), !Lh.isEmpty()) { const t = Lh.min, n = Lh.max, r = this.geometry.attributes.position, i = r.array; i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = t.x, i[4] = n.y, i[5] = n.z, i[6] = t.x, i[7] = t.y, i[8] = n.z, i[9] = n.x, i[10] = t.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = t.z, i[15] = t.x, i[16] = n.y, i[17] = t.z, i[18] = t.x, i[19] = t.y, i[20] = t.z, i[21] = n.x, i[22] = t.y, i[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere() } } setFromObject(e) { return this.object = e, this.update(), this } copy(e) { return Ws.prototype.copy.call(this, e), this.object = e.object, this } } const Ph = new Le; let Ih, Dh; class Nh extends Ws { constructor(e = 1) { const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], n = new T; n.setAttribute("position", new V(t, 3)), n.setAttribute("color", new V([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(n, new x({ vertexColors: !0, toneMapped: !1 })), this.type = "AxesHelper" } setColors(e, t, n) { const r = new y, i = this.geometry.attributes.color.array; return r.set(e), r.toArray(i, 0), r.toArray(i, 3), r.set(t), r.toArray(i, 6), r.toArray(i, 9), r.set(n), r.toArray(i, 12), r.toArray(i, 15), this.geometry.attributes.color.needsUpdate = !0, this } dispose() { this.geometry.dispose(), this.material.dispose() } } const Hh = new Float32Array(1), Oh = new Int32Array(Hh.buffer); mo.create = function (e, t) { return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(mo.prototype), (e.prototype.constructor = e).prototype.getPoint = t, e }, Zl.prototype.fromPoints = function (e) { return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e) }, Th.prototype.setColors = function () { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, _h.prototype.update = function () { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, l.prototype.extractUrlBase = function (e) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), vc.extractUrlBase(e) }, l.Handlers = { add: function () { console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.") }, get: function () { console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.") } }, uh.prototype.center = function (e) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e) }, uh.prototype.empty = function () { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, uh.prototype.isIntersectionBox = function (e) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, uh.prototype.size = function (e) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e) }, et.prototype.center = function (e) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, et.prototype.empty = function () { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, et.prototype.isIntersectionBox = function (e) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, et.prototype.isIntersectionSphere = function (e) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) }, et.prototype.size = function (e) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e) }, xt.prototype.empty = function () { return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, mr.prototype.setFromMatrix = function (e) { return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e) }, mh.prototype.center = function (e) { return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, v.prototype.flattenToArrayOffset = function (e, t) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, v.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this) }, v.prototype.multiplyVector3Array = function () { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, v.prototype.applyToBufferAttribute = function (e) { return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), e.applyMatrix3(this) }, v.prototype.applyToVector3Array = function () { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") }, v.prototype.getInverse = function (e) { return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert() }, Ce.prototype.extractPosition = function (e) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e) }, Ce.prototype.flattenToArrayOffset = function (e, t) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, Ce.prototype.getPosition = function () { return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Le).setFromMatrixColumn(this, 3) }, Ce.prototype.setRotationFromQuaternion = function (e) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e) }, Ce.prototype.multiplyToArray = function () { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, Ce.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, Ce.prototype.multiplyVector4 = function (e) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, Ce.prototype.multiplyVector3Array = function () { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, Ce.prototype.rotateAxis = function (e) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this) }, Ce.prototype.crossVector = function (e) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, Ce.prototype.translate = function () { console.error("THREE.Matrix4: .translate() has been removed.") }, Ce.prototype.rotateX = function () { console.error("THREE.Matrix4: .rotateX() has been removed.") }, Ce.prototype.rotateY = function () { console.error("THREE.Matrix4: .rotateY() has been removed.") }, Ce.prototype.rotateZ = function () { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, Ce.prototype.rotateByAxis = function () { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, Ce.prototype.applyToBufferAttribute = function (e) { return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, Ce.prototype.applyToVector3Array = function () { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, Ce.prototype.makeFrustum = function (e, t, n, r, i, a) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, r, n, i, a) }, Ce.prototype.getInverse = function (e) { return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert() }, ur.prototype.isIntersectionLine = function (e) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e) }, f.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this) }, f.prototype.inverse = function () { return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert() }, At.prototype.isIntersectionBox = function (e) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, At.prototype.isIntersectionPlane = function (e) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e) }, At.prototype.isIntersectionSphere = function (e) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) }, g.prototype.area = function () { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, g.prototype.barycoordFromPoint = function (e, t) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t) }, g.prototype.midpoint = function (e) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e) }, g.prototypenormal = function (e) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e) }, g.prototype.plane = function (e) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e) }, g.barycoordFromPoint = function (e, t, n, r, i) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), g.getBarycoord(e, t, n, r, i) }, g.normal = function (e, t, n, r) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), g.getNormal(e, t, n, r) }, Jl.prototype.extractAllPoints = function (e) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e) }, Jl.prototype.extrude = function (e) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new $o(this, e) }, Jl.prototype.makeGeometry = function (e) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new sl(this, e) }, k.prototype.fromAttribute = function (e, t, n) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, k.prototype.distanceToManhattan = function (e) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, k.prototype.lengthManhattan = function () { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, Le.prototype.setEulerFromRotationMatrix = function () { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, Le.prototype.setEulerFromQuaternion = function () { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, Le.prototype.getPositionFromMatrix = function (e) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e) }, Le.prototype.getScaleFromMatrix = function (e) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e) }, Le.prototype.getColumnFromMatrix = function (e, t) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e) }, Le.prototype.applyProjection = function (e) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e) }, Le.prototype.fromAttribute = function (e, t, n) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, Le.prototype.distanceToManhattan = function (e) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, Le.prototype.lengthManhattan = function () { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, Re.prototype.fromAttribute = function (e, t, n) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, Re.prototype.lengthManhattan = function () { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, u.prototype.getChildByName = function (e) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e) }, u.prototype.renderDepth = function () { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, u.prototype.translate = function (e, t) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e) }, u.prototype.getWorldRotation = function () { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") }, u.prototype.applyMatrix = function (e) { return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e) }, Object.defineProperties(u.prototype, { eulerOrder: { get: function () { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function (e) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e } }, useQuaternion: { get: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), S.prototype.setDrawMode = function () { console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") }, Object.defineProperties(S.prototype, { drawMode: { get: function () { return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0 }, set: function () { console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } } }), Es.prototype.initBones = function () { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, C.prototype.setLens = function (e, t) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e) }, Object.defineProperties(Kl.prototype, { onlyShadow: { set: function () { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function (e) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e } }, shadowCameraLeft: { set: function (e) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e } }, shadowCameraRight: { set: function (e) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e } }, shadowCameraTop: { set: function (e) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e } }, shadowCameraBottom: { set: function (e) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e } }, shadowCameraNear: { set: function (e) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e } }, shadowCameraFar: { set: function (e) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e } }, shadowCameraVisible: { set: function () { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function (e) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e } }, shadowDarkness: { set: function () { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function (e) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e } }, shadowMapHeight: { set: function (e) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e } } }), Object.defineProperties(E.prototype, { length: { get: function () { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, dynamic: { get: function () { return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === be }, set: function () { console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(be) } } }), E.prototype.setDynamic = function (e) { return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? be : _e), this }, E.prototype.copyIndicesArray = function () { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") }, E.prototype.setArray = function () { console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, T.prototype.addIndex = function (e) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e) }, T.prototype.addAttribute = function (e, t) { return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e, new E(t, arguments[2]))) }, T.prototype.addDrawCall = function (e, t, n) { void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t) }, T.prototype.clearDrawCalls = function () { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, T.prototype.computeOffsets = function () { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") }, T.prototype.removeAttribute = function (e) { return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e) }, T.prototype.applyMatrix = function (e) { return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e) }, Object.defineProperties(T.prototype, { drawcalls: { get: function () { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function () { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), $a.prototype.setDynamic = function (e) { return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? be : _e), this }, $a.prototype.setArray = function () { console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, $o.prototype.getArrays = function () { console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.") }, $o.prototype.addShapeList = function () { console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.") }, $o.prototype.addShape = function () { console.error("THREE.ExtrudeGeometry: .addShape() has been removed.") }, Qa.prototype.dispose = function () { console.error("THREE.Scene: .dispose() has been removed.") }, ah.prototype.onUpdate = function () { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this }, Object.defineProperties(t.prototype, { wrapAround: { get: function () { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function () { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function () { console.warn("THREE.Material: .overdraw has been removed.") }, set: function () { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function () { return console.warn("THREE.Material: .wrapRGB has been removed."), new y } }, shading: { get: function () { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function (e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e } }, stencilMask: { get: function () { return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask }, set: function (e) { console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e } }, vertexTangents: { get: function () { console.warn("THREE." + this.type + ": .vertexTangents has been removed.") }, set: function () { console.warn("THREE." + this.type + ": .vertexTangents has been removed.") } } }), Object.defineProperties(rr.prototype, { derivatives: { get: function () { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function (e) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e } } }), s.prototype.clearTarget = function (e, t, n, r) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, r) }, s.prototype.animate = function (e) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e) }, s.prototype.getCurrentRenderTarget = function () { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, s.prototype.getMaxAnisotropy = function () { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, s.prototype.getPrecision = function () { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, s.prototype.resetGLState = function () { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, s.prototype.supportsFloatTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, s.prototype.supportsHalfFloatTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, s.prototype.supportsStandardDerivatives = function () { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, s.prototype.supportsCompressedTextureS3TC = function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, s.prototype.supportsCompressedTexturePVRTC = function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, s.prototype.supportsBlendMinMax = function () { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, s.prototype.supportsVertexTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, s.prototype.supportsInstancedArrays = function () { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, s.prototype.enableScissorTest = function (e) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e) }, s.prototype.initMaterial = function () { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, s.prototype.addPrePlugin = function () { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, s.prototype.addPostPlugin = function () { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, s.prototype.updateShadowMap = function () { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, s.prototype.setFaceCulling = function () { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") }, s.prototype.allocTextureUnit = function () { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.") }, s.prototype.setTexture = function () { console.warn("THREE.WebGLRenderer: .setTexture() has been removed.") }, s.prototype.setTexture2D = function () { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.") }, s.prototype.setTextureCube = function () { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.") }, s.prototype.getActiveMipMapLevel = function () { return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel() }, Object.defineProperties(s.prototype, { shadowMapEnabled: { get: function () { return this.shadowMap.enabled }, set: function (e) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e } }, shadowMapType: { get: function () { return this.shadowMap.type }, set: function (e) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e } }, shadowMapCullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } }, context: { get: function () { return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext() } }, vr: { get: function () { return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr } }, gammaInput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1 }, set: function () { console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.") } }, gammaOutput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1 }, set: function (e) { console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === e ? ge : Fe } }, toneMappingWhitePoint: { get: function () { return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1 }, set: function () { console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.") } } }), Object.defineProperties(Ua.prototype, { cullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(Ze.prototype, { wrapS: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e } }, wrapT: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e } }, magFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e } }, minFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e } }, anisotropy: { get: function () { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e } }, offset: { get: function () { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e } }, repeat: { get: function () { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e } }, format: { get: function () { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e } }, type: { get: function () { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e } }, generateMipmaps: { get: function () { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e } } }), zc.prototype.load = function (e) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); const t = this; return (new Lc).load(e, function (e) { t.setBuffer(e) }), this }, jc.prototype.getData = function () { return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData() }, ar.prototype.updateCubeMap = function (e, t) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t) }, ar.prototype.clear = function (e, t, n, r) { return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(e, t, n, r) }, qe.crossOrigin = void 0, qe.loadTexture = function (e, t, n, r) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); const i = new Xl, a = (i.setCrossOrigin(this.crossOrigin), i.load(e, n, void 0, r)); return t && (a.mapping = t), a }, qe.loadTextureCube = function (e, t, n, r) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); const i = new jl, a = (i.setCrossOrigin(this.crossOrigin), i.load(e, n, void 0, r)); return t && (a.mapping = t), a }, qe.loadCompressedTexture = function () { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, qe.loadCompressedTextureCube = function () { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }; var Fh = { createMultiMaterialObject: function () { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, detach: function () { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, attach: function () { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") } }; "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: R } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = R), e.ACESFilmicToneMapping = 4, e.AddEquation = q, e.AddOperation = 2, e.AdditiveAnimationBlendMode = fe, e.AdditiveBlending = 2, e.AlphaFormat = 1021, e.AlwaysDepth = 1, e.AlwaysStencilFunc = 519, e.AmbientLight = dc, e.AmbientLightProbe = Pc, e.AnimationClip = Bl, e.AnimationLoader = class extends l { constructor(e) { super(e) } load(t, n, e, r) { const i = this, a = new Vl(this.manager); a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, function (e) { try { n(i.parse(JSON.parse(e))) } catch (e) { r ? r(e) : console.error(e), i.manager.itemError(t) } }, e, r) } parse(t) { const n = []; for (let e = 0; e < t.length; e++) { var r = Bl.parse(t[e]); n.push(r) } return n } }, e.AnimationMixer = ih, e.AnimationObjectGroup = nh, e.AnimationUtils = b, e.ArcCurve = go, e.ArrayCamera = Va, e.ArrowHelper = class extends u { constructor(e = new Le(0, 0, 1), t = new Le(0, 0, 0), n = 1, r = 16776960, i = .2 * n, a = .2 * i) { super(), this.type = "ArrowHelper", void 0 === Ih && ((Ih = new T).setAttribute("position", new V([0, 0, 0, 0, 1, 0], 3)), (Dh = new io(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new Gs(Ih, new x({ color: r, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new S(Dh, new gn({ color: r, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, i, a) } setDirection(e) { .99999 < e.y ? this.quaternion.set(0, 0, 0, 1) : e.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (Ph.set(e.z, 0, -e.x).normalize(), e = Math.acos(e.y), this.quaternion.setFromAxisAngle(Ph, e)) } setLength(e, t = .2 * e, n = .2 * t) { this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix() } setColor(e) { this.line.material.color.set(e), this.cone.material.color.set(e) } copy(e) { return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this } }, e.Audio = zc, e.AudioAnalyser = jc, e.AudioContext = Rc, e.AudioListener = class extends u { constructor() { super(), this.type = "AudioListener", this.context = Rc.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Nc } getInput() { return this.gain } removeFilter() { return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this } getFilter() { return this.filter } setFilter(e) { return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this } getMasterVolume() { return this.gain.gain.value } setMasterVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } updateMatrixWorld(e) { super.updateMatrixWorld(e); const t = this.context.listener, n = this.up; if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Oc, Fc, Bc), Uc.set(0, 0, -1).applyQuaternion(Fc), t.positionX) { const e = this.context.currentTime + this.timeDelta; t.positionX.linearRampToValueAtTime(Oc.x, e), t.positionY.linearRampToValueAtTime(Oc.y, e), t.positionZ.linearRampToValueAtTime(Oc.z, e), t.forwardX.linearRampToValueAtTime(Uc.x, e), t.forwardY.linearRampToValueAtTime(Uc.y, e), t.forwardZ.linearRampToValueAtTime(Uc.z, e), t.upX.linearRampToValueAtTime(n.x, e), t.upY.linearRampToValueAtTime(n.y, e), t.upZ.linearRampToValueAtTime(n.z, e) } else t.setPosition(Oc.x, Oc.y, Oc.z), t.setOrientation(Uc.x, Uc.y, Uc.z, n.x, n.y, n.z) } }, e.AudioLoader = Lc, e.AxesHelper = Nh, e.AxisHelper = function (e) { return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Nh(e) }, e.BackSide = 1, e.BasicDepthPacking = 3200, e.BasicShadowMap = 0, e.BinaryTextureLoader = function (e) { return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new ql(e) }, e.Bone = Ss, e.BooleanKeyframeTrack = Pl, e.BoundingBoxHelper = function (e, t) { return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Ch(e, t) }, e.Box2 = uh, e.Box3 = et, e.Box3Helper = class extends Ws { constructor(e, t = 16776960) { const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new T; r.setIndex(new E(n, 1)), r.setAttribute("position", new V([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r, new x({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere() } updateMatrixWorld(e) { const t = this.box; t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e)) } }, e.BoxBufferGeometry = er, e.BoxGeometry = er, e.BoxHelper = Ch, e.BufferAttribute = E, e.BufferGeometry = T, e.BufferGeometryLoader = _c, e.ByteType = 1010, e.Cache = Ul, e.Camera = ir, e.CameraHelper = class extends Ws { constructor(e) { const t = new T, n = new x({ color: 16777215, vertexColors: !0, toneMapped: !1 }), r = [], i = [], a = {}, s = new y(16755200), o = new y(16711680), l = new y(43775), c = new y(16777215), h = new y(3355443); function u(e, t, n) { d(e, n), d(t, n) } function d(e, t) { r.push(0, 0, 0), i.push(t.r, t.g, t.b), void 0 === a[e] && (a[e] = []), a[e].push(r.length / 3 - 1) } u("n1", "n2", s), u("n2", "n4", s), u("n4", "n3", s), u("n3", "n1", s), u("f1", "f2", s), u("f2", "f4", s), u("f4", "f3", s), u("f3", "f1", s), u("n1", "f1", s), u("n2", "f2", s), u("n3", "f3", s), u("n4", "f4", s), u("p", "n1", o), u("p", "n2", o), u("p", "n3", o), u("p", "n4", o), u("u1", "u2", l), u("u2", "u3", l), u("u3", "u1", l), u("c", "t", c), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), t.setAttribute("position", new V(r, 3)), t.setAttribute("color", new V(i, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update() } update() { const e = this.geometry, t = this.pointMap; d.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), p("c", t, e, d, 0, 0, -1), p("t", t, e, d, 0, 0, 1), p("n1", t, e, d, -1, -1, -1), p("n2", t, e, d, 1, -1, -1), p("n3", t, e, d, -1, 1, -1), p("n4", t, e, d, 1, 1, -1), p("f1", t, e, d, -1, -1, 1), p("f2", t, e, d, 1, -1, 1), p("f3", t, e, d, -1, 1, 1), p("f4", t, e, d, 1, 1, 1), p("u1", t, e, d, .7, 1.1, -1), p("u2", t, e, d, -.7, 1.1, -1), p("u3", t, e, d, 0, 2, -1), p("cf1", t, e, d, -1, 0, 1), p("cf2", t, e, d, 1, 0, 1), p("cf3", t, e, d, 0, -1, 1), p("cf4", t, e, d, 0, 1, 1), p("cn1", t, e, d, -1, 0, -1), p("cn2", t, e, d, 1, 0, -1), p("cn3", t, e, d, 0, -1, -1), p("cn4", t, e, d, 0, 1, -1), e.getAttribute("position").needsUpdate = !0 } dispose() { this.geometry.dispose(), this.material.dispose() } }, e.CanvasRenderer = function () { console.error("THREE.CanvasRenderer has been removed") }, e.CanvasTexture = to, e.CatmullRomCurve3 = Mo, e.CineonToneMapping = 3, e.CircleBufferGeometry = ro, e.CircleGeometry = ro, e.ClampToEdgeWrapping = Pe, e.Clock = Nc, e.Color = y, e.ColorKeyframeTrack = Il, e.CompressedTexture = eo, e.CompressedTextureLoader = class extends l { constructor(e) { super(e) } load(n, r, i, a) { const s = this, o = [], l = new eo, c = new Vl(this.manager); c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(s.withCredentials); let h = 0; if (Array.isArray(n)) for (let e = 0, t = n.length; e < t; ++e)!function (t) { c.load(n[t], function (e) { e = s.parse(e, !0); o[t] = { width: e.width, height: e.height, format: e.format, mipmaps: e.mipmaps }, 6 === (h += 1) && (1 === e.mipmapCount && (l.minFilter = B), l.image = o, l.format = e.format, l.needsUpdate = !0, r && r(l)) }, i, a) }(e); else c.load(n, function (e) { var n = s.parse(e, !0); if (n.isCubemap) { const e = n.mipmaps.length / n.mipmapCount; for (let t = 0; t < e; t++) { o[t] = { mipmaps: [] }; for (let e = 0; e < n.mipmapCount; e++)o[t].mipmaps.push(n.mipmaps[t * n.mipmapCount + e]), o[t].format = n.format, o[t].width = n.width, o[t].height = n.height } l.image = o } else l.image.width = n.width, l.image.height = n.height, l.mipmaps = n.mipmaps; 1 === n.mipmapCount && (l.minFilter = B), l.format = n.format, l.needsUpdate = !0, r && r(l) }, i, a); return l } }, e.ConeBufferGeometry = ao, e.ConeGeometry = ao, e.CubeCamera = ar, e.CubeReflectionMapping = P, e.CubeRefractionMapping = I, e.CubeTexture = sr, e.CubeTextureLoader = jl, e.CubeUVReflectionMapping = H, e.CubeUVRefractionMapping = O, e.CubicBezierCurve = So, e.CubicBezierCurve3 = Ao, e.CubicInterpolant = Al, e.CullFaceBack = 1, e.CullFaceFront = 2, e.CullFaceFrontBack = 3, e.CullFaceNone = 0, e.Curve = mo, e.CurvePath = Yl, e.CustomBlending = 5, e.CustomToneMapping = 5, e.CylinderBufferGeometry = io, e.CylinderGeometry = io, e.Cylindrical = class { constructor(e = 1, t = 0, n = 0) { return this.radius = e, this.theta = t, this.y = n, this } set(e, t, n) { return this.radius = e, this.theta = t, this.y = n, this } copy(e) { return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, n) { return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this } clone() { return (new this.constructor).copy(this) } }, e.DataTexture = As, e.DataTexture2DArray = ai, e.DataTexture3D = si, e.DataTextureLoader = ql, e.DataUtils = class { static toHalfFloat(e) { Hh[0] = e; e = Oh[0]; let t = e >> 16 & 32768, n = e >> 12 & 2047; var r = e >> 23 & 255; return r < 103 || (142 < r ? t = t | 31744 | ((255 == r ? 0 : 1) && 8388607 & e) : r < 113 ? (n |= 2048, t |= (n >> 114 - r) + (n >> 113 - r & 1)) : t = (t |= r - 112 << 10 | n >> 1) + (1 & n)), t } }, e.DecrementStencilOp = 7683, e.DecrementWrapStencilOp = 34056, e.DefaultLoadingManager = Gl, e.DepthFormat = K, e.DepthStencilFormat = Q, e.DepthTexture = no, e.DirectionalLight = uc, e.DirectionalLightHelper = class extends u { constructor(e, t, n) { super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === t && (t = 1); let r = new T; r.setAttribute("position", new V([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)); e = new x({ fog: !1, toneMapped: !1 }); this.lightPlane = new Gs(r, e), this.add(this.lightPlane), (r = new T).setAttribute("position", new V([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Gs(r, e), this.add(this.targetLine), this.update() } dispose() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() } update() { Eh.setFromMatrixPosition(this.light.matrixWorld), Sh.setFromMatrixPosition(this.light.target.matrixWorld), Ah.subVectors(Sh, Eh), this.lightPlane.lookAt(Sh), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Sh), this.targetLine.scale.z = Ah.length() } }, e.DiscreteInterpolant = Ll, e.DodecahedronBufferGeometry = oo, e.DodecahedronGeometry = oo, e.DoubleSide = 2, e.DstAlphaFactor = 206, e.DstColorFactor = 208, e.DynamicBufferAttribute = function (e, t) { return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new E(e, t).setUsage(be) }, e.DynamicCopyUsage = 35050, e.DynamicDrawUsage = be, e.DynamicReadUsage = 35049, e.EdgesGeometry = po, e.EdgesHelper = function (e, t) { return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Ws(new po(e.geometry), new x({ color: void 0 !== t ? t : 16777215 })) }, e.EllipseCurve = fo, e.EqualDepth = 4, e.EqualStencilFunc = 514, e.EquirectangularReflectionMapping = D, e.EquirectangularRefractionMapping = N, e.Euler = Ft, e.EventDispatcher = we, e.ExtrudeBufferGeometry = $o, e.ExtrudeGeometry = $o, e.FaceColors = 1, e.FileLoader = Vl, e.FlatShading = 1, e.Float16BufferAttribute = En, e.Float32Attribute = function (e, t) { return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new V(e, t) }, e.Float32BufferAttribute = V, e.Float64Attribute = function (e, t) { return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Sn(e, t) }, e.Float64BufferAttribute = Sn, e.FloatType = Ne, e.Fog = Ka, e.FogExp2 = Ja, e.Font = Sc, e.FontLoader = class extends l { constructor(e) { super(e) } load(e, r, t, n) { const i = this, a = new Vl(this.manager); a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(i.withCredentials), a.load(e, function (t) { let n; try { n = JSON.parse(t) } catch (e) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2)) } t = i.parse(n); r && r(t) }, t, n) } parse(e) { return new Sc(e) } }, e.FrontSide = 0, e.Frustum = mr, e.GLBufferAttribute = oh, e.GLSL1 = "100", e.GLSL3 = Me, e.GammaEncoding = ve, e.GreaterDepth = 6, e.GreaterEqualDepth = 5, e.GreaterEqualStencilFunc = 518, e.GreaterStencilFunc = 516, e.GridHelper = Th, e.Group = Wa, e.HalfFloatType = He, e.HemisphereLight = Ql, e.HemisphereLightHelper = class extends u { constructor(e, t, n) { super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n; const r = new rl(t); r.rotateY(.5 * Math.PI), this.material = new gn({ wireframe: !0, fog: !1, toneMapped: !1 }), void 0 === this.color && (this.material.vertexColors = !0); e = r.getAttribute("position"), n = new Float32Array(3 * e.count); r.setAttribute("color", new E(n, 3)), this.add(new S(r, this.material)), this.update() } dispose() { this.children[0].geometry.dispose(), this.children[0].material.dispose() } update() { const e = this.children[0]; if (void 0 !== this.color) this.material.color.set(this.color); else { const r = e.geometry.getAttribute("color"); Mh.copy(this.light.color), wh.copy(this.light.groundColor); for (let e = 0, t = r.count; e < t; e++) { var n = e < t / 2 ? Mh : wh; r.setXYZ(e, n.r, n.g, n.b) } r.needsUpdate = !0 } e.lookAt(bh.setFromMatrixPosition(this.light.matrixWorld).negate()) } }, e.HemisphereLightProbe = Cc, e.IcosahedronBufferGeometry = tl, e.IcosahedronGeometry = tl, e.ImageBitmapLoader = Tc, e.ImageLoader = Wl, e.ImageUtils = qe, e.ImmediateRenderObject = fh, e.IncrementStencilOp = 7682, e.IncrementWrapStencilOp = 34055, e.InstancedBufferAttribute = xc, e.InstancedBufferGeometry = yc, e.InstancedInterleavedBuffer = sh, e.InstancedMesh = Hs, e.Int16Attribute = function (e, t) { return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new bn(e, t) }, e.Int16BufferAttribute = bn, e.Int32Attribute = function (e, t) { return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new wn(e, t) }, e.Int32BufferAttribute = wn, e.Int8Attribute = function (e, t) { return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new yn(e, t) }, e.Int8BufferAttribute = yn, e.IntType = 1013, e.InterleavedBuffer = $a, e.InterleavedBufferAttribute = es, e.Interpolant = Sl, e.InterpolateDiscrete = le, e.InterpolateLinear = ce, e.InterpolateSmooth = he, e.InvertStencilOp = 5386, e.JSONLoader = function () { console.error("THREE.JSONLoader has been removed.") }, e.KeepStencilOp = 7680, e.KeyframeTrack = Cl, e.LOD = xs, e.LatheBufferGeometry = nl, e.LatheGeometry = nl, e.Layers = Bt, e.LensFlare = function () { console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js") }, e.LessDepth = 2, e.LessEqualDepth = 3, e.LessEqualStencilFunc = 515, e.LessStencilFunc = 513, e.Light = Kl, e.LightProbe = fc, e.Line = Gs, e.Line3 = mh, e.LineBasicMaterial = x, e.LineCurve = Ro, e.LineCurve3 = Lo, e.LineDashedMaterial = Tl, e.LineLoop = js, e.LinePieces = 1, e.LineSegments = Ws, e.LineStrip = 0, e.LinearEncoding = Fe, e.LinearFilter = B, e.LinearInterpolant = Rl, e.LinearMipMapLinearFilter = 1008, e.LinearMipMapNearestFilter = 1007, e.LinearMipmapLinearFilter = Ie, e.LinearMipmapNearestFilter = j, e.LinearToneMapping = 1, e.Loader = l, e.LoaderUtils = vc, e.LoadingManager = zl, e.LogLuvEncoding = 3003, e.LoopOnce = 2200, e.LoopPingPong = 2202, e.LoopRepeat = 2201, e.LuminanceAlphaFormat = 1025, e.LuminanceFormat = 1024, e.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, e.Material = t, e.MaterialLoader = gc, e.Math = We, e.MathUtils = We, e.Matrix3 = v, e.Matrix4 = Ce, e.MaxEquation = 104, e.Mesh = S, e.MeshBasicMaterial = gn, e.MeshDepthMaterial = Fa, e.MeshDistanceMaterial = Ba, e.MeshFaceMaterial = function (e) { return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e }, e.MeshLambertMaterial = Ml, e.MeshMatcapMaterial = wl, e.MeshNormalMaterial = bl, e.MeshPhongMaterial = xl, e.MeshPhysicalMaterial = yl, e.MeshStandardMaterial = vl, e.MeshToonMaterial = _l, e.MinEquation = 103, e.MirroredRepeatWrapping = z, e.MixOperation = 1, e.MultiMaterial = function (e = []) { return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, (e.materials = e).clone = function () { return e.slice() }, e }, e.MultiplyBlending = 4, e.MultiplyOperation = 0, e.NearestFilter = Ae, e.NearestMipMapLinearFilter = 1005, e.NearestMipMapNearestFilter = 1004, e.NearestMipmapLinearFilter = W, e.NearestMipmapNearestFilter = G, e.NeverDepth = 0, e.NeverStencilFunc = 512, e.NoBlending = 0, e.NoColors = 0, e.NoToneMapping = 0, e.NormalAnimationBlendMode = me, e.NormalBlending = 1, e.NotEqualDepth = 7, e.NotEqualStencilFunc = 517, e.NumberKeyframeTrack = Dl, e.Object3D = u, e.ObjectLoader = class extends l { constructor(e) { super(e) } load(r, i, e, a) { const s = this, t = "" === this.path ? vc.extractUrlBase(r) : this.path, n = (this.resourcePath = this.resourcePath || t, new Vl(this.manager)); n.setPath(this.path), n.setRequestHeader(this.requestHeader), n.setWithCredentials(this.withCredentials), n.load(r, function (e) { let t = null; try { t = JSON.parse(e) } catch (e) { return void 0 !== a && a(e), void console.error("THREE:ObjectLoader: Can't parse " + r + ".", e.message) } const n = t.metadata; void 0 !== n && void 0 !== n.type && "geometry" !== n.type.toLowerCase() ? s.parse(t, i) : console.error("THREE.ObjectLoader: Can't load " + r) }, e, a) } async loadAsync(e, t) { var n = "" === this.path ? vc.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || n; const r = new Vl(this.manager), i = (r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), await r.loadAsync(e, t)), a = JSON.parse(i), s = a.metadata; if (void 0 === s || void 0 === s.type || "geometry" === s.type.toLowerCase()) throw new Error("THREE.ObjectLoader: Can't load " + e); return this.parseAsync(a) } parse(e, t) { const n = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, r), a = this.parseImages(e.images, function () { void 0 !== t && t(l) }), s = this.parseTextures(e.textures, a), o = this.parseMaterials(e.materials, s), l = this.parseObject(e.object, i, o, s, n), c = this.parseSkeletons(e.skeletons, l); if (this.bindSkeletons(l, c), void 0 !== t) { let e = !1; for (const t in a) if (a[t] instanceof HTMLImageElement) { e = !0; break } !1 === e && t(l) } return l } async parseAsync(e) { var t = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), n = this.parseGeometries(e.geometries, n), r = await this.parseImagesAsync(e.images), r = this.parseTextures(e.textures, r), i = this.parseMaterials(e.materials, r), n = this.parseObject(e.object, n, i, r, t), i = this.parseSkeletons(e.skeletons, n); return this.bindSkeletons(n, i), n } parseShapes(n) { const r = {}; if (void 0 !== n) for (let e = 0, t = n.length; e < t; e++) { var i = (new Jl).fromJSON(n[e]); r[i.uuid] = i } return r } parseSkeletons(n, e) { const r = {}, i = {}; if (e.traverse(function (e) { e.isBone && (i[e.uuid] = e) }), void 0 !== n) for (let e = 0, t = n.length; e < t; e++) { var a = (new Cs).fromJSON(n[e], i); r[a.uuid] = a } return r } parseGeometries(n, r) { const i = {}; if (void 0 !== n) { const s = new _c; for (let t = 0, e = n.length; t < e; t++) { let e; var a = n[t]; switch (a.type) { case "BufferGeometry": case "InstancedBufferGeometry": e = s.parse(a); break; case "Geometry": console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported."); break; default: a.type in fl ? e = fl[a.type].fromJSON(a, r) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`) }e.uuid = a.uuid, void 0 !== a.name && (e.name = a.name), !0 === e.isBufferGeometry && void 0 !== a.userData && (e.userData = a.userData), i[a.uuid] = e } } return i } parseMaterials(n, e) { const r = {}, i = {}; if (void 0 !== n) { const s = new gc; s.setTextures(e); for (let e = 0, t = n.length; e < t; e++) { var a = n[e]; if ("MultiMaterial" === a.type) { const n = []; for (let e = 0; e < a.materials.length; e++) { const i = a.materials[e]; void 0 === r[i.uuid] && (r[i.uuid] = s.parse(i)), n.push(r[i.uuid]) } i[a.uuid] = n } else void 0 === r[a.uuid] && (r[a.uuid] = s.parse(a)), i[a.uuid] = r[a.uuid] } } return i } parseAnimations(t) { const n = {}; if (void 0 !== t) for (let e = 0; e < t.length; e++) { var r = t[e], r = Bl.parse(r); n[r.uuid] = r } return n } parseImages(n, r) { const i = this, a = {}; let s; function o(e) { var t, n; return "string" == typeof e ? (n = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(t = e) ? t : i.resourcePath + t, i.manager.itemStart(n), s.load(n, function () { i.manager.itemEnd(n) }, void 0, function () { i.manager.itemError(n), i.manager.itemEnd(n) })) : e.data ? { data: Ln(e.type, e.data), width: e.width, height: e.height } : null } if (void 0 !== n && 0 < n.length) { const i = new zl(r); (s = new Wl(i)).setCrossOrigin(this.crossOrigin); for (let e = 0, t = n.length; e < t; e++) { const i = n[e], s = i.url; if (Array.isArray(s)) { a[i.uuid] = []; for (let e = 0, t = s.length; e < t; e++) { const r = o(s[e]); null !== r && (r instanceof HTMLImageElement ? a[i.uuid].push(r) : a[i.uuid].push(new As(r.data, r.width, r.height))) } } else { const n = o(i.url); null !== n && (a[i.uuid] = n) } } } return a } async parseImagesAsync(n) { const r = this, i = {}; let a; async function s(e) { var t; return "string" == typeof e ? (t = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(t = e) ? t : r.resourcePath + t, a.loadAsync(t)) : e.data ? { data: Ln(e.type, e.data), width: e.width, height: e.height } : null } if (void 0 !== n && 0 < n.length) { (a = new Wl(this.manager)).setCrossOrigin(this.crossOrigin); for (let e = 0, t = n.length; e < t; e++) { const a = n[e], o = a.url; if (Array.isArray(o)) { i[a.uuid] = []; for (let e = 0, t = o.length; e < t; e++) { const r = o[e], l = await s(r); null !== l && (l instanceof HTMLImageElement ? i[a.uuid].push(l) : i[a.uuid].push(new As(l.data, l.width, l.height))) } } else { const n = await s(a.url); null !== n && (i[a.uuid] = n) } } } return i } parseTextures(n, r) { function i(e, t) { return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e]) } const a = {}; if (void 0 !== n) for (let t = 0, e = n.length; t < e; t++) { var s = n[t]; let e; void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === r[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image); var o = r[s.image]; Array.isArray(o) ? (e = new sr(o), 6 === o.length && (e.needsUpdate = !0)) : (e = o && o.data ? new As(o.data, o.width, o.height) : new h(o), o && (e.needsUpdate = !0)), e.uuid = s.uuid, void 0 !== s.name && (e.name = s.name), void 0 !== s.mapping && (e.mapping = i(s.mapping, bc)), void 0 !== s.offset && e.offset.fromArray(s.offset), void 0 !== s.repeat && e.repeat.fromArray(s.repeat), void 0 !== s.center && e.center.fromArray(s.center), void 0 !== s.rotation && (e.rotation = s.rotation), void 0 !== s.wrap && (e.wrapS = i(s.wrap[0], Mc), e.wrapT = i(s.wrap[1], Mc)), void 0 !== s.format && (e.format = s.format), void 0 !== s.type && (e.type = s.type), void 0 !== s.encoding && (e.encoding = s.encoding), void 0 !== s.minFilter && (e.minFilter = i(s.minFilter, wc)), void 0 !== s.magFilter && (e.magFilter = i(s.magFilter, wc)), void 0 !== s.anisotropy && (e.anisotropy = s.anisotropy), void 0 !== s.flipY && (e.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (e.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (e.unpackAlignment = s.unpackAlignment), a[s.uuid] = e } return a } parseObject(e, t, a, n, r) { let i, s, o; function l(e) { return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e] } function c(n) { if (void 0 !== n) { if (Array.isArray(n)) { const i = []; for (let e = 0, t = n.length; e < t; e++) { var r = n[e]; void 0 === a[r] && console.warn("THREE.ObjectLoader: Undefined material", r), i.push(a[r]) } return i } return void 0 === a[n] && console.warn("THREE.ObjectLoader: Undefined material", n), a[n] } } function h(e) { return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined texture", e), n[e] } switch (e.type) { case "Scene": i = new Qa, void 0 !== e.background && (Number.isInteger(e.background) ? i.background = new y(e.background) : i.background = h(e.background)), void 0 !== e.environment && (i.environment = h(e.environment)), void 0 !== e.fog && ("Fog" === e.fog.type ? i.fog = new Ka(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (i.fog = new Ja(e.fog.color, e.fog.density))); break; case "PerspectiveCamera": i = new C(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (i.focus = e.focus), void 0 !== e.zoom && (i.zoom = e.zoom), void 0 !== e.filmGauge && (i.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (i.filmOffset = e.filmOffset), void 0 !== e.view && (i.view = Object.assign({}, e.view)); break; case "OrthographicCamera": i = new Er(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (i.zoom = e.zoom), void 0 !== e.view && (i.view = Object.assign({}, e.view)); break; case "AmbientLight": i = new dc(e.color, e.intensity); break; case "DirectionalLight": i = new uc(e.color, e.intensity); break; case "PointLight": i = new cc(e.color, e.intensity, e.distance, e.decay); break; case "RectAreaLight": i = new pc(e.color, e.intensity, e.width, e.height); break; case "SpotLight": i = new ic(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay); break; case "HemisphereLight": i = new Ql(e.color, e.groundColor, e.intensity); break; case "LightProbe": i = (new fc).fromJSON(e); break; case "SkinnedMesh": s = l(e.geometry), o = c(e.material), i = new Es(s, o), void 0 !== e.bindMode && (i.bindMode = e.bindMode), void 0 !== e.bindMatrix && i.bindMatrix.fromArray(e.bindMatrix), void 0 !== e.skeleton && (i.skeleton = e.skeleton); break; case "Mesh": s = l(e.geometry), o = c(e.material), i = new S(s, o); break; case "InstancedMesh": s = l(e.geometry), o = c(e.material); const t = e.count, a = e.instanceMatrix, n = e.instanceColor; (i = new Hs(s, o, t)).instanceMatrix = new E(new Float32Array(a.array), 16), void 0 !== n && (i.instanceColor = new E(new Float32Array(n.array), n.itemSize)); break; case "LOD": i = new xs; break; case "Line": i = new Gs(l(e.geometry), c(e.material)); break; case "LineLoop": i = new js(l(e.geometry), c(e.material)); break; case "LineSegments": i = new Ws(l(e.geometry), c(e.material)); break; case "PointCloud": case "Points": i = new Ks(l(e.geometry), c(e.material)); break; case "Sprite": i = new fs(c(e.material)); break; case "Group": i = new Wa; break; case "Bone": i = new Ss; break; default: i = new u }if (i.uuid = e.uuid, void 0 !== e.name && (i.name = e.name), void 0 !== e.matrix ? (i.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (i.matrixAutoUpdate = e.matrixAutoUpdate), i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== e.position && i.position.fromArray(e.position), void 0 !== e.rotation && i.rotation.fromArray(e.rotation), void 0 !== e.quaternion && i.quaternion.fromArray(e.quaternion), void 0 !== e.scale && i.scale.fromArray(e.scale)), void 0 !== e.castShadow && (i.castShadow = e.castShadow), void 0 !== e.receiveShadow && (i.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (i.shadow.bias = e.shadow.bias), void 0 !== e.shadow.normalBias && (i.shadow.normalBias = e.shadow.normalBias), void 0 !== e.shadow.radius && (i.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && i.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (i.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (i.visible = e.visible), void 0 !== e.frustumCulled && (i.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (i.renderOrder = e.renderOrder), void 0 !== e.userData && (i.userData = e.userData), void 0 !== e.layers && (i.layers.mask = e.layers), void 0 !== e.children) { const s = e.children; for (let e = 0; e < s.length; e++)i.add(this.parseObject(s[e], t, a, n, r)) } if (void 0 !== e.animations) { const t = e.animations; for (let e = 0; e < t.length; e++) { const a = t[e]; i.animations.push(r[a]) } } if ("LOD" === e.type) { void 0 !== e.autoUpdate && (i.autoUpdate = e.autoUpdate); const t = e.levels; for (let e = 0; e < t.length; e++) { const a = t[e], n = i.getObjectByProperty("uuid", a.object); void 0 !== n && i.addLevel(n, a.distance) } } return i } bindSkeletons(e, n) { 0 !== Object.keys(n).length && e.traverse(function (e) { var t; !0 === e.isSkinnedMesh && void 0 !== e.skeleton && (void 0 === (t = n[e.skeleton]) ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e.skeleton) : e.bind(t, e.bindMatrix)) }) } setTexturePath(e) { return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e) } }, e.ObjectSpaceNormalMap = 1, e.OctahedronBufferGeometry = rl, e.OctahedronGeometry = rl, e.OneFactor = 201, e.OneMinusDstAlphaFactor = 207, e.OneMinusDstColorFactor = 209, e.OneMinusSrcAlphaFactor = 205, e.OneMinusSrcColorFactor = 203, e.OrthographicCamera = Er, e.PCFShadowMap = 1, e.PCFSoftShadowMap = 2, e.PMREMGenerator = Vr, e.ParametricBufferGeometry = il, e.ParametricGeometry = il, e.Particle = function (e) { return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new fs(e) }, e.ParticleBasicMaterial = function (e) { return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new qs(e) }, e.ParticleSystem = function (e, t) { return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Ks(e, t) }, e.ParticleSystemMaterial = function (e) { return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new qs(e) }, e.Path = Zl, e.PerspectiveCamera = C, e.Plane = ur, e.PlaneBufferGeometry = vr, e.PlaneGeometry = vr, e.PlaneHelper = class extends Gs { constructor(e, t = 1, n = 16776960) { const r = n, i = new T, a = (i.setAttribute("position", new V([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), i.computeBoundingSphere(), super(i, new x({ color: r, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t, new T); a.setAttribute("position", new V([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), a.computeBoundingSphere(), this.add(new S(a, new gn({ color: r, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 }))) } updateMatrixWorld(e) { let t = -this.plane.constant; Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? 1 : 0, this.lookAt(this.plane.normal), super.updateMatrixWorld(e) } }, e.PointCloud = function (e, t) { return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Ks(e, t) }, e.PointCloudMaterial = function (e) { return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new qs(e) }, e.PointLight = cc, e.PointLightHelper = class extends S { constructor(e, t, n) { super(new ol(t, 4, 2), new gn({ wireframe: !0, fog: !1, toneMapped: !1 })), this.light = e, this.light.updateMatrixWorld(), this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } dispose() { this.geometry.dispose(), this.material.dispose() } update() { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) } }, e.Points = Ks, e.PointsMaterial = qs, e.PolarGridHelper = class extends Ws { constructor(t = 10, n = 16, r = 8, i = 64, a = 4473924, s = 8947848) { a = new y(a), s = new y(s); const o = [], l = []; for (let e = 0; e <= n; e++) { const i = e / n * (2 * Math.PI), p = Math.sin(i) * t, m = Math.cos(i) * t; o.push(0, 0, 0), o.push(p, 0, m); var c = 1 & e ? a : s; l.push(c.r, c.g, c.b), l.push(c.r, c.g, c.b) } for (let e = 0; e <= r; e++) { const p = 1 & e ? a : s, f = t - t / r * e; for (let e = 0; e < i; e++) { var h = e / i * (2 * Math.PI), u = Math.sin(h) * f, d = Math.cos(h) * f; o.push(u, 0, d), l.push(p.r, p.g, p.b), h = (e + 1) / i * (2 * Math.PI), u = Math.sin(h) * f, d = Math.cos(h) * f, o.push(u, 0, d), l.push(p.r, p.g, p.b) } } const p = new T; p.setAttribute("position", new V(o, 3)), p.setAttribute("color", new V(l, 3)), super(p, new x({ vertexColors: !0, toneMapped: !1 })), this.type = "PolarGridHelper" } }, e.PolyhedronBufferGeometry = so, e.PolyhedronGeometry = so, e.PositionalAudio = class extends zc { constructor(e) { super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } getOutput() { return this.panner } getRefDistance() { return this.panner.refDistance } setRefDistance(e) { return this.panner.refDistance = e, this } getRolloffFactor() { return this.panner.rolloffFactor } setRolloffFactor(e) { return this.panner.rolloffFactor = e, this } getDistanceModel() { return this.panner.distanceModel } setDistanceModel(e) { return this.panner.distanceModel = e, this } getMaxDistance() { return this.panner.maxDistance } setMaxDistance(e) { return this.panner.maxDistance = e, this } setDirectionalCone(e, t, n) { return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this } updateMatrixWorld(e) { if (super.updateMatrixWorld(e), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) { this.matrixWorld.decompose(Gc, kc, Vc), Wc.set(0, 0, 1).applyQuaternion(kc); const t = this.panner; if (t.positionX) { const e = this.context.currentTime + this.listener.timeDelta; t.positionX.linearRampToValueAtTime(Gc.x, e), t.positionY.linearRampToValueAtTime(Gc.y, e), t.positionZ.linearRampToValueAtTime(Gc.z, e), t.orientationX.linearRampToValueAtTime(Wc.x, e), t.orientationY.linearRampToValueAtTime(Wc.y, e), t.orientationZ.linearRampToValueAtTime(Wc.z, e) } else t.setPosition(Gc.x, Gc.y, Gc.z), t.setOrientation(Wc.x, Wc.y, Wc.z) } } }, e.PropertyBinding = M, e.PropertyMixer = qc, e.QuadraticBezierCurve = Co, e.QuadraticBezierCurve3 = Po, e.Quaternion = f, e.QuaternionKeyframeTrack = Hl, e.QuaternionLinearInterpolant = Nl, e.REVISION = R, e.RGBADepthPacking = 3201, e.RGBAFormat = Oe, e.RGBAIntegerFormat = 1033, e.RGBA_ASTC_10x10_Format = 37819, e.RGBA_ASTC_10x5_Format = 37816, e.RGBA_ASTC_10x6_Format = 37817, e.RGBA_ASTC_10x8_Format = 37818, e.RGBA_ASTC_12x10_Format = 37820, e.RGBA_ASTC_12x12_Format = 37821, e.RGBA_ASTC_4x4_Format = 37808, e.RGBA_ASTC_5x4_Format = 37809, e.RGBA_ASTC_5x5_Format = 37810, e.RGBA_ASTC_6x5_Format = 37811, e.RGBA_ASTC_6x6_Format = 37812, e.RGBA_ASTC_8x5_Format = 37813, e.RGBA_ASTC_8x6_Format = 37814, e.RGBA_ASTC_8x8_Format = 37815, e.RGBA_BPTC_Format = 36492, e.RGBA_ETC2_EAC_Format = oe, e.RGBA_PVRTC_2BPPV1_Format = ae, e.RGBA_PVRTC_4BPPV1_Format = ie, e.RGBA_S3TC_DXT1_Format = $, e.RGBA_S3TC_DXT3_Format = ee, e.RGBA_S3TC_DXT5_Format = te, e.RGBDEncoding = 3006, e.RGBEEncoding = ye, e.RGBEFormat = 1023, e.RGBFormat = J, e.RGBIntegerFormat = 1032, e.RGBM16Encoding = 3005, e.RGBM7Encoding = xe, e.RGB_ETC1_Format = 36196, e.RGB_ETC2_Format = se, e.RGB_PVRTC_2BPPV1_Format = re, e.RGB_PVRTC_4BPPV1_Format = ne, e.RGB_S3TC_DXT1_Format = F, e.RGFormat = 1030, e.RGIntegerFormat = 1031, e.RawShaderMaterial = Sr, e.Ray = At, e.Raycaster = class { constructor(e, t, n = 0, r = 1 / 0) { this.ray = new At(e, t), this.near = n, this.far = r, this.camera = null, this.layers = new Bt, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } } set(e, t) { this.ray.set(e, t) } setFromCamera(e, t) { t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type) } intersectObject(e, t = !1, n = []) { return ch(e, this, n, t), n.sort(lh), n } intersectObjects(n, r = !1, i = []) { for (let e = 0, t = n.length; e < t; e++)ch(n[e], this, i, r); return i.sort(lh), i } }, e.RectAreaLight = pc, e.RedFormat = 1028, e.RedIntegerFormat = 1029, e.ReinhardToneMapping = 2, e.RepeatWrapping = U, e.ReplaceStencilOp = 7681, e.ReverseSubtractEquation = 102, e.RingBufferGeometry = al, e.RingGeometry = al, e.SRGB8_ALPHA8_ASTC_10x10_Format = 37851, e.SRGB8_ALPHA8_ASTC_10x5_Format = 37848, e.SRGB8_ALPHA8_ASTC_10x6_Format = 37849, e.SRGB8_ALPHA8_ASTC_10x8_Format = 37850, e.SRGB8_ALPHA8_ASTC_12x10_Format = 37852, e.SRGB8_ALPHA8_ASTC_12x12_Format = 37853, e.SRGB8_ALPHA8_ASTC_4x4_Format = 37840, e.SRGB8_ALPHA8_ASTC_5x4_Format = 37841, e.SRGB8_ALPHA8_ASTC_5x5_Format = 37842, e.SRGB8_ALPHA8_ASTC_6x5_Format = 37843, e.SRGB8_ALPHA8_ASTC_6x6_Format = 37844, e.SRGB8_ALPHA8_ASTC_8x5_Format = 37845, e.SRGB8_ALPHA8_ASTC_8x6_Format = 37846, e.SRGB8_ALPHA8_ASTC_8x8_Format = 37847, e.Scene = Qa, e.SceneUtils = Fh, e.ShaderChunk = w, e.ShaderLib = yr, e.ShaderMaterial = rr, e.ShadowMaterial = gl, e.Shape = Jl, e.ShapeBufferGeometry = sl, e.ShapeGeometry = sl, e.ShapePath = Ec, e.ShapeUtils = Jo, e.ShortType = 1011, e.Skeleton = Cs, e.SkeletonHelper = _h, e.SkinnedMesh = Es, e.SmoothShading = 2, e.Sphere = xt, e.SphereBufferGeometry = ol, e.SphereGeometry = ol, e.Spherical = class { constructor(e = 1, t = 0, n = 0) { return this.radius = e, this.phi = t, this.theta = n, this } set(e, t, n) { return this.radius = e, this.phi = t, this.theta = n, this } copy(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this } makeSafe() { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, n) { return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(m(t / this.radius, -1, 1))), this } clone() { return (new this.constructor).copy(this) } }, e.SphericalHarmonics3 = mc, e.SplineCurve = Io, e.SpotLight = ic, e.SpotLightHelper = class extends u { constructor(e, t) { super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t; const n = new T, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (let e = 0, t = 1; e < 32; e++, t++) { const i = e / 32 * Math.PI * 2, a = t / 32 * Math.PI * 2; r.push(Math.cos(i), Math.sin(i), 1, Math.cos(a), Math.sin(a), 1) } n.setAttribute("position", new V(r, 3)); const i = new x({ fog: !1, toneMapped: !1 }); this.cone = new Ws(n, i), this.add(this.cone), this.update() } dispose() { this.cone.geometry.dispose(), this.cone.material.dispose() } update() { this.light.updateMatrixWorld(); var e = this.light.distance || 1e3, t = e * Math.tan(this.light.angle); this.cone.scale.set(t, t, e), gh.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(gh), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) } }, e.Sprite = fs, e.SpriteMaterial = ts, e.SrcAlphaFactor = 204, e.SrcAlphaSaturateFactor = 210, e.SrcColorFactor = 202, e.StaticCopyUsage = 35046, e.StaticDrawUsage = _e, e.StaticReadUsage = 35045, e.StereoCamera = class { constructor() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new C, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new C, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } } update(e) { const t = this._cache; if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) { t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep; const i = e.projectionMatrix.clone(), a = t.eyeSep / 2, s = a * t.near / t.focus, o = t.near * Math.tan(Ee * t.fov * .5) / t.zoom; var n, r; Dc.elements[12] = -a, Ic.elements[12] = a, n = -o * t.aspect + s, r = o * t.aspect + s, i.elements[0] = 2 * t.near / (r - n), i.elements[8] = (r + n) / (r - n), this.cameraL.projectionMatrix.copy(i), n = -o * t.aspect - s, r = o * t.aspect - s, i.elements[0] = 2 * t.near / (r - n), i.elements[8] = (r + n) / (r - n), this.cameraR.projectionMatrix.copy(i) } this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Dc), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Ic) } }, e.StreamCopyUsage = 35042, e.StreamDrawUsage = 35040, e.StreamReadUsage = 35041, e.StringKeyframeTrack = Ol, e.SubtractEquation = 101, e.SubtractiveBlending = 3, e.TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, e.TangentSpaceNormalMap = 0, e.TetrahedronBufferGeometry = ll, e.TetrahedronGeometry = ll, e.TextBufferGeometry = cl, e.TextGeometry = cl, e.Texture = h, e.TextureLoader = Xl, e.TorusBufferGeometry = hl, e.TorusGeometry = hl, e.TorusKnotBufferGeometry = ul, e.TorusKnotGeometry = ul, e.Triangle = g, e.TriangleFanDrawMode = 2, e.TriangleStripDrawMode = 1, e.TrianglesDrawMode = 0, e.TubeBufferGeometry = dl, e.TubeGeometry = dl, e.UVMapping = L, e.Uint16Attribute = function (e, t) { return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Mn(e, t) }, e.Uint16BufferAttribute = Mn, e.Uint32Attribute = function (e, t) { return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Tn(e, t) }, e.Uint32BufferAttribute = Tn, e.Uint8Attribute = function (e, t) { return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new xn(e, t) }, e.Uint8BufferAttribute = xn, e.Uint8ClampedAttribute = function (e, t) { return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new _n(e, t) }, e.Uint8ClampedBufferAttribute = _n, e.Uniform = ah, e.UniformsLib = A, e.UniformsUtils = nr, e.UnsignedByteType = De, e.UnsignedInt248Type = Z, e.UnsignedIntType = Y, e.UnsignedShort4444Type = 1017, e.UnsignedShort5551Type = 1018, e.UnsignedShort565Type = 1019, e.UnsignedShortType = X, e.VSMShadowMap = 3, e.Vector2 = k, e.Vector3 = Le, e.Vector4 = Re, e.VectorKeyframeTrack = Fl, e.Vertex = function (e, t, n) { return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Le(e, t, n) }, e.VertexColors = 2, e.VideoTexture = $s, e.WebGL1Renderer = Za, e.WebGLCubeRenderTarget = or, e.WebGLMultipleRenderTargets = Je, e.WebGLMultisampleRenderTarget = Ke, e.WebGLRenderTarget = Ze, e.WebGLRenderTargetCube = function (e, t, n) { return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new or(e, n) }, e.WebGLRenderer = s, e.WebGLUtils = ka, e.WireframeGeometry = pl, e.WireframeHelper = function (e, t) { return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Ws(new pl(e.geometry), new x({ color: void 0 !== t ? t : 16777215 })) }, e.WrapAroundEnding = pe, e.XHRLoader = function (e) { return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Vl(e) }, e.ZeroCurvatureEnding = ue, e.ZeroFactor = 200, e.ZeroSlopeEnding = de, e.ZeroStencilOp = 0, e.sRGBEncoding = ge, Object.defineProperty(e, "__esModule", { value: !0 })
}), function () { const Y = { type: "change" }, Z = { type: "start" }, J = { type: "end" }; class e extends THREE.EventDispatcher { constructor(e, t) { super(), void 0 === t && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), t === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new THREE.Vector3, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN }, this.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function () { return p.phi }, this.getAzimuthalAngle = function () { return p.theta }, this.getDistance = function () { return this.object.position.distanceTo(this.target) }, this.listenToKeyEvents = function (e) { e.addEventListener("keydown", W), this._domElementKeyEvents = e }, this.saveState = function () { c.target0.copy(c.target), c.position0.copy(c.object.position), c.zoom0 = c.object.zoom }, this.reset = function () { c.target.copy(c.target0), c.object.position.copy(c.position0), c.object.zoom = c.zoom0, c.object.updateProjectionMatrix(), c.dispatchEvent(Y), c.update(), u = h.NONE }, this.update = function () { const r = new THREE.Vector3, i = (new THREE.Quaternion).setFromUnitVectors(e.up, new THREE.Vector3(0, 1, 0)), a = i.clone().invert(), s = new THREE.Vector3, o = new THREE.Quaternion, l = 2 * Math.PI; return function () { const e = c.object.position; r.copy(e).sub(c.target), r.applyQuaternion(i), p.setFromVector3(r), c.autoRotate && u === h.NONE && w(2 * Math.PI / 60 / 60 * c.autoRotateSpeed), c.enableDamping ? (p.theta += m.theta * c.dampingFactor, p.phi += m.phi * c.dampingFactor) : (p.theta += m.theta, p.phi += m.phi); let t = c.minAzimuthAngle, n = c.maxAzimuthAngle; return isFinite(t) && isFinite(n) && (t < -Math.PI ? t += l : t > Math.PI && (t -= l), n < -Math.PI ? n += l : n > Math.PI && (n -= l), p.theta = t <= n ? Math.max(t, Math.min(n, p.theta)) : p.theta > (t + n) / 2 ? Math.max(t, p.theta) : Math.min(n, p.theta)), p.phi = Math.max(c.minPolarAngle, Math.min(c.maxPolarAngle, p.phi)), p.makeSafe(), p.radius *= f, p.radius = Math.max(c.minDistance, Math.min(c.maxDistance, p.radius)), !0 === c.enableDamping ? c.target.addScaledVector(g, c.dampingFactor) : c.target.add(g), r.setFromSpherical(p), r.applyQuaternion(a), e.copy(c.target).add(r), c.object.lookAt(c.target), !0 === c.enableDamping ? (m.theta *= 1 - c.dampingFactor, m.phi *= 1 - c.dampingFactor, g.multiplyScalar(1 - c.dampingFactor)) : (m.set(0, 0, 0), g.set(0, 0, 0)), f = 1, !!(v || s.distanceToSquared(c.object.position) > d || 8 * (1 - o.dot(c.object.quaternion)) > d) && (c.dispatchEvent(Y), s.copy(c.object.position), o.copy(c.object.quaternion), !(v = !1)) } }(), this.dispose = function () { c.domElement.removeEventListener("contextmenu", j), c.domElement.removeEventListener("pointerdown", G), c.domElement.removeEventListener("pointercancel", k), c.domElement.removeEventListener("wheel", V), c.domElement.removeEventListener("pointermove", D), c.domElement.removeEventListener("pointerup", N), null !== c._domElementKeyEvents && c._domElementKeyEvents.removeEventListener("keydown", W) }; const c = this, h = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }; let u = h.NONE; const d = 1e-6, p = new THREE.Spherical, m = new THREE.Spherical; let f = 1; const g = new THREE.Vector3; let v = !1; const i = new THREE.Vector2, a = new THREE.Vector2, s = new THREE.Vector2, r = new THREE.Vector2, o = new THREE.Vector2, l = new THREE.Vector2, y = new THREE.Vector2, x = new THREE.Vector2, _ = new THREE.Vector2, b = [], n = {}; function M() { return Math.pow(.95, c.zoomSpeed) } function w(e) { m.theta -= e } function T(e) { m.phi -= e } const E = function () { const n = new THREE.Vector3; return function (e, t) { n.setFromMatrixColumn(t, 0), n.multiplyScalar(-e), g.add(n) } }(), S = function () { const n = new THREE.Vector3; return function (e, t) { !0 === c.screenSpacePanning ? n.setFromMatrixColumn(t, 1) : (n.setFromMatrixColumn(t, 0), n.crossVectors(c.object.up, n)), n.multiplyScalar(e), g.add(n) } }(), A = function () { const i = new THREE.Vector3; return function (e, t) { var n, r = c.domElement; c.object.isPerspectiveCamera ? (n = c.object.position, i.copy(n).sub(c.target), n = i.length(), n *= Math.tan(c.object.fov / 2 * Math.PI / 180), E(2 * e * n / r.clientHeight, c.object.matrix), S(2 * t * n / r.clientHeight, c.object.matrix)) : c.object.isOrthographicCamera ? (E(e * (c.object.right - c.object.left) / c.object.zoom / r.clientWidth, c.object.matrix), S(t * (c.object.top - c.object.bottom) / c.object.zoom / r.clientHeight, c.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), c.enablePan = !1) } }(); function R(e) { c.object.isPerspectiveCamera ? f /= e : c.object.isOrthographicCamera ? (c.object.zoom = Math.max(c.minZoom, Math.min(c.maxZoom, c.object.zoom * e)), c.object.updateProjectionMatrix(), v = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), c.enableZoom = !1) } function L(e) { c.object.isPerspectiveCamera ? f *= e : c.object.isOrthographicCamera ? (c.object.zoom = Math.max(c.minZoom, Math.min(c.maxZoom, c.object.zoom / e)), c.object.updateProjectionMatrix(), v = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), c.enableZoom = !1) } function C(e) { i.set(e.clientX, e.clientY) } function P(e) { r.set(e.clientX, e.clientY) } function I() { var e, t; 1 === b.length ? i.set(b[0].pageX, b[0].pageY) : (e = .5 * (b[0].pageX + b[1].pageX), t = .5 * (b[0].pageY + b[1].pageY), i.set(e, t)) } function O() { var e, t; 1 === b.length ? r.set(b[0].pageX, b[0].pageY) : (e = .5 * (b[0].pageX + b[1].pageX), t = .5 * (b[0].pageY + b[1].pageY), r.set(e, t)) } function F() { var e = b[0].pageX - b[1].pageX, t = b[0].pageY - b[1].pageY, e = Math.sqrt(e * e + t * t); y.set(0, e) } function B(e) { if (1 == b.length) a.set(e.pageX, e.pageY); else { const t = H(e), n = .5 * (e.pageX + t.x), r = .5 * (e.pageY + t.y); a.set(n, r) } s.subVectors(a, i).multiplyScalar(c.rotateSpeed); const t = c.domElement; w(2 * Math.PI * s.x / t.clientHeight), T(2 * Math.PI * s.y / t.clientHeight), i.copy(a) } function U(e) { var t, n; 1 === b.length ? o.set(e.pageX, e.pageY) : (t = H(e), n = .5 * (e.pageX + t.x), e = .5 * (e.pageY + t.y), o.set(n, e)), l.subVectors(o, r).multiplyScalar(c.panSpeed), A(l.x, l.y), r.copy(o) } function z(e) { var t = H(e), n = e.pageX - t.x, e = e.pageY - t.y, t = Math.sqrt(n * n + e * e); x.set(0, t), _.set(0, Math.pow(x.y / y.y, c.zoomSpeed)), R(_.y), y.copy(x) } function G(e) { var t; !1 !== c.enabled && (0 === b.length && (c.domElement.setPointerCapture(e.pointerId), c.domElement.addEventListener("pointermove", D), c.domElement.addEventListener("pointerup", N)), t = e, b.push(t), "touch" === e.pointerType ? function () { switch (X(e), b.length) { case 1: switch (c.touches.ONE) { case THREE.TOUCH.ROTATE: if (!1 === c.enableRotate) return; I(), u = h.TOUCH_ROTATE; break; case THREE.TOUCH.PAN: if (!1 === c.enablePan) return; O(), u = h.TOUCH_PAN; break; default: u = h.NONE }break; case 2: switch (c.touches.TWO) { case THREE.TOUCH.DOLLY_PAN: if (!1 === c.enableZoom && !1 === c.enablePan) return; c.enableZoom && F(), c.enablePan && O(), u = h.TOUCH_DOLLY_PAN; break; case THREE.TOUCH.DOLLY_ROTATE: if (!1 === c.enableZoom && !1 === c.enableRotate) return; c.enableZoom && F(), c.enableRotate && I(), u = h.TOUCH_DOLLY_ROTATE; break; default: u = h.NONE }break; default: u = h.NONE }u !== h.NONE && c.dispatchEvent(Z) }() : function (e) { let t; switch (e.button) { case 0: t = c.mouseButtons.LEFT; break; case 1: t = c.mouseButtons.MIDDLE; break; case 2: t = c.mouseButtons.RIGHT; break; default: t = -1 }switch (t) { case THREE.MOUSE.DOLLY: if (!1 === c.enableZoom) return; n = e, y.set(n.clientX, n.clientY), u = h.DOLLY; break; case THREE.MOUSE.ROTATE: if (e.ctrlKey || e.metaKey || e.shiftKey) { if (!1 === c.enablePan) return; P(e), u = h.PAN } else { if (!1 === c.enableRotate) return; C(e), u = h.ROTATE } break; case THREE.MOUSE.PAN: if (e.ctrlKey || e.metaKey || e.shiftKey) { if (!1 === c.enableRotate) return; C(e), u = h.ROTATE } else { if (!1 === c.enablePan) return; P(e), u = h.PAN } break; default: u = h.NONE }var n; u !== h.NONE && c.dispatchEvent(Z) }(e)) } function D(e) { !1 !== c.enabled && ("touch" === e.pointerType ? function (e) { switch (X(e), u) { case h.TOUCH_ROTATE: if (!1 === c.enableRotate) return; B(e), c.update(); break; case h.TOUCH_PAN: if (!1 === c.enablePan) return; U(e), c.update(); break; case h.TOUCH_DOLLY_PAN: if (!1 === c.enableZoom && !1 === c.enablePan) return; t = e, c.enableZoom && z(t), c.enablePan && U(t), c.update(); break; case h.TOUCH_DOLLY_ROTATE: if (!1 === c.enableZoom && !1 === c.enableRotate) return; t = e, c.enableZoom && z(t), c.enableRotate && B(t), c.update(); break; default: u = h.NONE }var t } : function (e) { var t; if (!1 !== c.enabled) switch (u) { case h.ROTATE: if (!1 === c.enableRotate) return; var n = e; a.set(n.clientX, n.clientY), s.subVectors(a, i).multiplyScalar(c.rotateSpeed), n = c.domElement, w(2 * Math.PI * s.x / n.clientHeight), T(2 * Math.PI * s.y / n.clientHeight), i.copy(a), c.update(); break; case h.DOLLY: if (!1 === c.enableZoom) return; n = e, x.set(n.clientX, n.clientY), _.subVectors(x, y), 0 < _.y ? R(M()) : _.y < 0 && L(M()), y.copy(x), c.update(); break; case h.PAN: if (!1 === c.enablePan) return; t = e, o.set(t.clientX, t.clientY), l.subVectors(o, r).multiplyScalar(c.panSpeed), A(l.x, l.y), r.copy(o), c.update() } })(e) } function N(e) { !1 !== c.enabled && (e.pointerType, c.dispatchEvent(J), u = h.NONE, q(e), 0 === b.length && (c.domElement.releasePointerCapture(e.pointerId), c.domElement.removeEventListener("pointermove", D), c.domElement.removeEventListener("pointerup", N))) } function k(e) { q(e) } function V(e) { !1 === c.enabled || !1 === c.enableZoom || u !== h.NONE && u !== h.ROTATE || (e.preventDefault(), c.dispatchEvent(Z), (e = e).deltaY < 0 ? L(M()) : 0 < e.deltaY && R(M()), c.update(), c.dispatchEvent(J)) } function W(t) { if (!1 !== c.enabled && !1 !== c.enablePan) { let e = !1; switch (t.code) { case c.keys.UP: A(0, c.keyPanSpeed), e = !0; break; case c.keys.BOTTOM: A(0, -c.keyPanSpeed), e = !0; break; case c.keys.LEFT: A(c.keyPanSpeed, 0), e = !0; break; case c.keys.RIGHT: A(-c.keyPanSpeed, 0), e = !0 }e && (t.preventDefault(), c.update()) } } function j(e) { !1 !== c.enabled && e.preventDefault() } function q(t) { delete n[t.pointerId]; for (let e = 0; e < b.length; e++)if (b[e].pointerId == t.pointerId) return b.splice(e, 1) } function X(e) { let t = n[e.pointerId]; void 0 === t && (t = new THREE.Vector2, n[e.pointerId] = t), t.set(e.pageX, e.pageY) } function H(e) { e = e.pointerId === b[0].pointerId ? b[1] : b[0]; return n[e.pointerId] } c.domElement.addEventListener("contextmenu", j), c.domElement.addEventListener("pointerdown", G), c.domElement.addEventListener("pointercancel", k), c.domElement.addEventListener("wheel", V, { passive: !1 }), this.update() } } THREE.MapControls = class extends e { constructor(e, t) { super(e, t), this.screenSpacePanning = !1, this.mouseButtons.LEFT = THREE.MOUSE.PAN, this.mouseButtons.RIGHT = THREE.MOUSE.ROTATE, this.touches.ONE = THREE.TOUCH.PAN, this.touches.TWO = THREE.TOUCH.DOLLY_ROTATE } }, THREE.OrbitControls = e }(), function () { class e extends THREE.Loader { constructor(e) { super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (e) { return new r(e) }), this.register(function (e) { return new l(e) }), this.register(function (e) { return new u(e) }), this.register(function (e) { return new i(e) }), this.register(function (e) { return new a(e) }), this.register(function (e) { return new s(e) }), this.register(function (e) { return new o(e) }), this.register(function (e) { return new t(e) }), this.register(function (e) { return new d(e) }) } load(t, n, e, r) { const i = this; let a; a = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : THREE.LoaderUtils.extractUrlBase(t), this.manager.itemStart(t); function s(e) { r ? r(e) : console.error(e), i.manager.itemError(t), i.manager.itemEnd(t) } const o = new THREE.FileLoader(this.manager); o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(t, function (e) { try { i.parse(e, a, function (e) { n(e), i.manager.itemEnd(t) }, s) } catch (e) { s(e) } }, e, s) } setDRACOLoader(e) { return this.dracoLoader = e, this } setDDSLoader() { throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') } setKTX2Loader(e) { return this.ktx2Loader = e, this } setMeshoptDecoder(e) { return this.meshoptDecoder = e, this } register(e) { return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this } unregister(e) { return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this } parse(e, t, n, r) { let i; const a = {}, s = {}; if ("string" == typeof e) i = e; else if (THREE.LoaderUtils.decodeText(new Uint8Array(e, 0, 4)) === p) { try { a[h.KHR_BINARY_GLTF] = new m(e) } catch (e) { return void (r && r(e)) } i = a[h.KHR_BINARY_GLTF].content } else i = THREE.LoaderUtils.decodeText(new Uint8Array(e)); var o = JSON.parse(i); if (void 0 === o.asset || o.asset.version[0] < 2) r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")); else { const l = new D(o, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); l.fileLoader.setRequestHeader(this.requestHeader); for (let e = 0; e < this.pluginCallbacks.length; e++) { const t = this.pluginCallbacks[e](l); s[t.name] = t, a[t.name] = !0 } if (o.extensionsUsed) for (let e = 0; e < o.extensionsUsed.length; ++e) { const t = o.extensionsUsed[e], n = o.extensionsRequired || []; switch (t) { case h.KHR_MATERIALS_UNLIT: a[t] = new c; break; case h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: a[t] = new y; break; case h.KHR_DRACO_MESH_COMPRESSION: a[t] = new f(o, this.dracoLoader); break; case h.KHR_TEXTURE_TRANSFORM: a[t] = new g; break; case h.KHR_MESH_QUANTIZATION: a[t] = new x; break; default: 0 <= n.indexOf(t) && void 0 === s[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".') } } l.setExtensions(a), l.setPlugins(s), l.parse(n, r) } } } function n() { let n = {}; return { get: function (e) { return n[e] }, add: function (e, t) { n[e] = t }, remove: function (e) { delete n[e] }, removeAll: function () { n = {} } } } const h = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" }; class t { constructor(e) { this.parser = e, this.name = h.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } _markDefs() { const n = this.parser, r = this.parser.json.nodes || []; for (let e = 0, t = r.length; e < t; e++) { var i = r[e]; i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && n._addNodeRef(this.cache, i.extensions[this.name].light) } } _loadLight(e) { const t = this.parser, n = "light:" + e; let r = t.cache.get(n); if (r) return r; const i = t.json, a = ((i.extensions && i.extensions[this.name] || {}).lights || [])[e]; let s; const o = new THREE.Color(16777215); void 0 !== a.color && o.fromArray(a.color); var l = void 0 !== a.range ? a.range : 0; switch (a.type) { case "directional": (s = new THREE.DirectionalLight(o)).target.position.set(0, 0, -1), s.add(s.target); break; case "point": (s = new THREE.PointLight(o)).distance = l; break; case "spot": (s = new THREE.SpotLight(o)).distance = l, a.spot = a.spot || {}, a.spot.innerConeAngle = void 0 !== a.spot.innerConeAngle ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = void 0 !== a.spot.outerConeAngle ? a.spot.outerConeAngle : Math.PI / 4, s.angle = a.spot.outerConeAngle, s.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, s.target.position.set(0, 0, -1), s.add(s.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type) }return s.position.set(0, 0, 0), s.decay = 2, void 0 !== a.intensity && (s.intensity = a.intensity), s.name = t.createUniqueName(a.name || "light_" + e), r = Promise.resolve(s), t.cache.add(n, r), r } createNodeAttachment(e) { const t = this, n = this.parser, r = n.json.nodes[e], i = (r.extensions && r.extensions[this.name] || {}).light; return void 0 === i ? null : this._loadLight(i).then(function (e) { return n._getNodeRef(t.cache, i, e) }) } } class c { constructor() { this.name = h.KHR_MATERIALS_UNLIT } getMaterialType() { return THREE.MeshBasicMaterial } extendParams(e, t, n) { const r = []; e.color = new THREE.Color(1, 1, 1), e.opacity = 1; var i = t.pbrMetallicRoughness; if (i) { if (Array.isArray(i.baseColorFactor)) { const t = i.baseColorFactor; e.color.fromArray(t), e.opacity = t[3] } void 0 !== i.baseColorTexture && r.push(n.assignTexture(e, "map", i.baseColorTexture)) } return Promise.all(r) } } class r { constructor(e) { this.parser = e, this.name = h.KHR_MATERIALS_CLEARCOAT } getMaterialType(e) { e = this.parser.json.materials[e]; return e.extensions && e.extensions[this.name] ? THREE.MeshPhysicalMaterial : null } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const i = [], a = r.extensions[this.name]; if (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor), void 0 !== a.clearcoatTexture && i.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), void 0 !== a.clearcoatRoughnessFactor && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), void 0 !== a.clearcoatRoughnessTexture && i.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), void 0 !== a.clearcoatNormalTexture && (i.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), void 0 !== a.clearcoatNormalTexture.scale)) { const e = a.clearcoatNormalTexture.scale; t.clearcoatNormalScale = new THREE.Vector2(e, -e) } return Promise.all(i) } } class i { constructor(e) { this.parser = e, this.name = h.KHR_MATERIALS_TRANSMISSION } getMaterialType(e) { e = this.parser.json.materials[e]; return e.extensions && e.extensions[this.name] ? THREE.MeshPhysicalMaterial : null } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const i = [], a = r.extensions[this.name]; return void 0 !== a.transmissionFactor && (t.transmission = a.transmissionFactor), void 0 !== a.transmissionTexture && i.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(i) } } class a { constructor(e) { this.parser = e, this.name = h.KHR_MATERIALS_VOLUME } getMaterialType(e) { e = this.parser.json.materials[e]; return e.extensions && e.extensions[this.name] ? THREE.MeshPhysicalMaterial : null } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const i = [], a = r.extensions[this.name]; t.thickness = void 0 !== a.thicknessFactor ? a.thicknessFactor : 0, void 0 !== a.thicknessTexture && i.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 0; e = a.attenuationColor || [1, 1, 1]; return t.attenuationTint = new THREE.Color(e[0], e[1], e[2]), Promise.all(i) } } class s { constructor(e) { this.parser = e, this.name = h.KHR_MATERIALS_IOR } getMaterialType(e) { e = this.parser.json.materials[e]; return e.extensions && e.extensions[this.name] ? THREE.MeshPhysicalMaterial : null } extendMaterialParams(e, t) { e = this.parser.json.materials[e]; if (!e.extensions || !e.extensions[this.name]) return Promise.resolve(); e = e.extensions[this.name]; return t.ior = void 0 !== e.ior ? e.ior : 1.5, Promise.resolve() } } class o { constructor(e) { this.parser = e, this.name = h.KHR_MATERIALS_SPECULAR } getMaterialType(e) { e = this.parser.json.materials[e]; return e.extensions && e.extensions[this.name] ? THREE.MeshPhysicalMaterial : null } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const i = [], a = r.extensions[this.name]; t.specularIntensity = void 0 !== a.specularFactor ? a.specularFactor : 1, void 0 !== a.specularTexture && i.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture)); e = a.specularColorFactor || [1, 1, 1]; return t.specularTint = new THREE.Color(e[0], e[1], e[2]), void 0 !== a.specularColorTexture && i.push(n.assignTexture(t, "specularTintMap", a.specularColorTexture).then(function (e) { e.encoding = THREE.sRGBEncoding })), Promise.all(i) } } class l { constructor(e) { this.parser = e, this.name = h.KHR_TEXTURE_BASISU } loadTexture(e) { const t = this.parser, n = t.json, r = n.textures[e]; if (!r.extensions || !r.extensions[this.name]) return null; var i = r.extensions[this.name], i = n.images[i.source], a = t.options.ktx2Loader; if (a) return t.loadTextureImage(e, i, a); if (n.extensionsRequired && 0 <= n.extensionsRequired.indexOf(this.name)) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } } class u { constructor(e) { this.parser = e, this.name = h.EXT_TEXTURE_WEBP, this.isSupported = null } loadTexture(t) { const n = this.name, r = this.parser, i = r.json, e = i.textures[t]; if (!e.extensions || !e.extensions[n]) return null; const a = e.extensions[n], s = i.images[a.source]; let o = r.textureLoader; if (s.uri) { const t = r.options.manager.getHandler(s.uri); null !== t && (o = t) } return this.detectSupport().then(function (e) { if (e) return r.loadTextureImage(t, s, o); if (i.extensionsRequired && 0 <= i.extensionsRequired.indexOf(n)) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return r.loadTexture(t) }) } detectSupport() { return this.isSupported || (this.isSupported = new Promise(function (e) { const t = new Image; t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () { e(1 === t.height) } })), this.isSupported } } class d { constructor(e) { this.name = h.EXT_MESHOPT_COMPRESSION, this.parser = e } loadBufferView(s) { const e = this.parser.json, t = e.bufferViews[s]; if (t.extensions && t.extensions[this.name]) { const s = t.extensions[this.name], n = this.parser.getDependency("buffer", s.buffer), o = this.parser.options.meshoptDecoder; if (o && o.supported) return Promise.all([n, o.ready]).then(function (e) { var t = s.byteOffset || 0, n = s.byteLength || 0, r = s.count, i = s.byteStride, a = new ArrayBuffer(r * i), e = new Uint8Array(e[0], t, n); return o.decodeGltfBuffer(new Uint8Array(a), r, i, e, s.mode, s.filter), a }); if (e.extensionsRequired && 0 <= e.extensionsRequired.indexOf(this.name)) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return null } } const p = "glTF"; class m { constructor(e) { this.name = h.KHR_BINARY_GLTF, this.content = null, this.body = null; const t = new DataView(e, 0, 12); if (this.header = { magic: THREE.LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== p) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); const n = this.header.length - 12, r = new DataView(e, 12); let i = 0; for (; i < n;) { const t = r.getUint32(i, !0), h = (i += 4, r.getUint32(i, !0)); if (i += 4, 1313821514 === h) { const h = new Uint8Array(e, 12 + i, t); this.content = THREE.LoaderUtils.decodeText(h) } else if (5130562 === h) { const h = 12 + i; this.body = e.slice(h, h + t) } i += t } if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.") } } class f { constructor(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = h.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } decodePrimitive(e, t) { const n = this.json, i = this.dracoLoader, r = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, s = {}, o = {}, l = {}; for (const e in a) { const t = E[e] || e.toLowerCase(); s[t] = a[e] } for (const t in e.attributes) { const i = E[t] || t.toLowerCase(); if (void 0 !== a[t]) { const r = n.accessors[e.attributes[t]], a = b[r.componentType]; l[i] = a, o[i] = !0 === r.normalized } } return t.getDependency("bufferView", r).then(function (e) { return new Promise(function (r) { i.decodeDracoFile(e, function (e) { for (const r in e.attributes) { const t = e.attributes[r], n = o[r]; void 0 !== n && (t.normalized = n) } r(e) }, s, l) }) }) } } class g { constructor() { this.name = h.KHR_TEXTURE_TRANSFORM } extendTexture(e, t) { return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e } } class v extends THREE.MeshStandardMaterial { constructor(e) { super(), this.isGLTFSpecularGlossinessMaterial = !0; const t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"), n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"), r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), i = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), a = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"), s = { specular: { value: (new THREE.Color).setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } }; this._extraUniforms = s, this.onBeforeCompile = function (e) { for (const t in s) e.uniforms[t] = s[t]; e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", i).replace("#include <lights_physical_fragment>", a) }, Object.defineProperties(this, { specular: { get: function () { return s.specular.value }, set: function (e) { s.specular.value = e } }, specularMap: { get: function () { return s.specularMap.value }, set: function (e) { (s.specularMap.value = e) ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP } }, glossiness: { get: function () { return s.glossiness.value }, set: function (e) { s.glossiness.value = e } }, glossinessMap: { get: function () { return s.glossinessMap.value }, set: function (e) { (s.glossinessMap.value = e) ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV) } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e) } copy(e) { return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this } } class y { constructor() { this.name = h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"] } getMaterialType() { return v } extendParams(e, t, n) { var r = t.extensions[this.name]; e.color = new THREE.Color(1, 1, 1), e.opacity = 1; const i = []; if (Array.isArray(r.diffuseFactor)) { const t = r.diffuseFactor; e.color.fromArray(t), e.opacity = t[3] } if (void 0 !== r.diffuseTexture && i.push(n.assignTexture(e, "map", r.diffuseTexture)), e.emissive = new THREE.Color(0, 0, 0), e.glossiness = void 0 !== r.glossinessFactor ? r.glossinessFactor : 1, e.specular = new THREE.Color(1, 1, 1), Array.isArray(r.specularFactor) && e.specular.fromArray(r.specularFactor), void 0 !== r.specularGlossinessTexture) { const t = r.specularGlossinessTexture; i.push(n.assignTexture(e, "glossinessMap", t)), i.push(n.assignTexture(e, "specularMap", t)) } return Promise.all(i) } createMaterial(e) { const t = new v(e); return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = THREE.TangentSpaceNormalMap, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t } } class x { constructor() { this.name = h.KHR_MESH_QUANTIZATION } } class _ extends THREE.Interpolant { constructor(e, t, n, r) { super(e, t, n, r) } copySampleValue_(e) { const t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r * 3 + r; for (let e = 0; e !== r; e++)t[e] = n[i + e]; return t } } _.prototype.beforeStart_ = _.prototype.copySampleValue_, _.prototype.afterEnd_ = _.prototype.copySampleValue_, _.prototype.interpolate_ = function (e, t, n, r) { const i = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = 2 * s, l = 3 * s, c = r - t, h = (n - t) / c, u = h * h, d = u * h, p = e * l, m = p - l, f = -2 * d + 3 * u, g = d - u, v = 1 - f, y = g - u + h; for (let e = 0; e !== s; e++) { const t = a[m + e + s], n = a[m + e + o] * c, r = a[p + e + s], l = a[p + e] * c; i[e] = v * t + y * n + f * r + g * l } return i }; const b = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, M = { 9728: THREE.NearestFilter, 9729: THREE.LinearFilter, 9984: THREE.NearestMipmapNearestFilter, 9985: THREE.LinearMipmapNearestFilter, 9986: THREE.NearestMipmapLinearFilter, 9987: THREE.LinearMipmapLinearFilter }, w = { 33071: THREE.ClampToEdgeWrapping, 33648: THREE.MirroredRepeatWrapping, 10497: THREE.RepeatWrapping }, T = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, E = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, S = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, A = { CUBICSPLINE: void 0, LINEAR: THREE.InterpolateLinear, STEP: THREE.InterpolateDiscrete }; function R(e, t) { return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e) } function L(e, t, n) { for (const r in n.extensions) void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r] = n.extensions[r]) } function C(e, t) { void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras)) } function P(n) { let r = ""; var i = Object.keys(n).sort(); for (let e = 0, t = i.length; e < t; e++)r += i[e] + ":" + n[i[e]] + ";"; return r } function I(e) { switch (e) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.") } } class D { constructor(e = {}, t = {}) { this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new n, this.associations = new Map, this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.textureCache = {}, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new THREE.ImageBitmapLoader(this.options.manager) : this.textureLoader = new THREE.TextureLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new THREE.FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) } setExtensions(e) { this.extensions = e } setPlugins(e) { this.plugins = e } parse(n, e) { const r = this, i = this.json, a = this.extensions; this.cache.removeAll(), this._invokeAll(function (e) { return e._markDefs && e._markDefs() }), Promise.all(this._invokeAll(function (e) { return e.beforeRoot && e.beforeRoot() })).then(function () { return Promise.all([r.getDependencies("scene"), r.getDependencies("animation"), r.getDependencies("camera")]) }).then(function (e) { const t = { scene: e[0][i.scene || 0], scenes: e[0], animations: e[1], cameras: e[2], asset: i.asset, parser: r, userData: {} }; L(a, t, i), C(t, i), Promise.all(r._invokeAll(function (e) { return e.afterRoot && e.afterRoot(t) })).then(function () { n(t) }) }).catch(e) } _markDefs() { const n = this.json.nodes || [], r = this.json.skins || [], i = this.json.meshes || []; for (let e = 0, t = r.length; e < t; e++) { var a = r[e].joints; for (let e = 0, t = a.length; e < t; e++)n[a[e]].isBone = !0 } for (let e = 0, t = n.length; e < t; e++) { var s = n[e]; void 0 !== s.mesh && (this._addNodeRef(this.meshCache, s.mesh), void 0 !== s.skin && (i[s.mesh].isSkinnedMesh = !0)), void 0 !== s.camera && this._addNodeRef(this.cameraCache, s.camera) } } _addNodeRef(e, t) { void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++) } _getNodeRef(e, t, n) { if (e.refs[t] <= 1) return n; const r = n.clone(); return r.name += "_instance_" + e.uses[t]++, r } _invokeOne(t) { const n = Object.values(this.plugins); n.push(this); for (let e = 0; e < n.length; e++) { var r = t(n[e]); if (r) return r } return null } _invokeAll(t) { const n = Object.values(this.plugins), r = (n.unshift(this), []); for (let e = 0; e < n.length; e++) { var i = t(n[e]); i && r.push(i) } return r } getDependency(e, t) { var n = e + ":" + t; let r = this.cache.get(n); if (!r) { switch (e) { case "scene": r = this.loadScene(t); break; case "node": r = this.loadNode(t); break; case "mesh": r = this._invokeOne(function (e) { return e.loadMesh && e.loadMesh(t) }); break; case "accessor": r = this.loadAccessor(t); break; case "bufferView": r = this._invokeOne(function (e) { return e.loadBufferView && e.loadBufferView(t) }); break; case "buffer": r = this.loadBuffer(t); break; case "material": r = this._invokeOne(function (e) { return e.loadMaterial && e.loadMaterial(t) }); break; case "texture": r = this._invokeOne(function (e) { return e.loadTexture && e.loadTexture(t) }); break; case "skin": r = this.loadSkin(t); break; case "animation": r = this.loadAnimation(t); break; case "camera": r = this.loadCamera(t); break; default: throw new Error("Unknown type: " + e) }this.cache.add(n, r) } return r } getDependencies(n) { let e = this.cache.get(n); if (!e) { const r = this, t = this.json[n + ("mesh" === n ? "es" : "s")] || []; e = Promise.all(t.map(function (e, t) { return r.getDependency(n, t) })), this.cache.add(n, e) } return e } loadBuffer(e) { const n = this.json.buffers[e], r = this.fileLoader; if (n.type && "arraybuffer" !== n.type) throw new Error("THREE.GLTFLoader: " + n.type + " buffer type is not supported."); if (void 0 === n.uri && 0 === e) return Promise.resolve(this.extensions[h.KHR_BINARY_GLTF].body); const i = this.options; return new Promise(function (e, t) { r.load(R(n.uri, i.path), e, void 0, function () { t(new Error('THREE.GLTFLoader: Failed to load buffer "' + n.uri + '".')) }) }) } loadBufferView(e) { const r = this.json.bufferViews[e]; return this.getDependency("buffer", r.buffer).then(function (e) { var t = r.byteLength || 0, n = r.byteOffset || 0; return e.slice(n, n + t) }) } loadAccessor(e) { const u = this, d = this.json, p = this.json.accessors[e]; if (void 0 === p.bufferView && void 0 === p.sparse) return Promise.resolve(null); const t = []; return void 0 !== p.bufferView ? t.push(this.getDependency("bufferView", p.bufferView)) : t.push(null), void 0 !== p.sparse && (t.push(this.getDependency("bufferView", p.sparse.indices.bufferView)), t.push(this.getDependency("bufferView", p.sparse.values.bufferView))), Promise.all(t).then(function (t) { const n = t[0], r = T[p.type], i = b[p.componentType], a = i.BYTES_PER_ELEMENT, e = a * r, s = p.byteOffset || 0, o = void 0 !== p.bufferView ? d.bufferViews[p.bufferView].byteStride : void 0, l = !0 === p.normalized; let c, h; if (o && o !== e) { const t = Math.floor(s / o), d = "InterleavedBuffer:" + p.bufferView + ":" + p.componentType + ":" + t + ":" + p.count; let e = u.cache.get(d); e || (c = new i(n, t * o, p.count * o / a), e = new THREE.InterleavedBuffer(c, o / a), u.cache.add(d, e)), h = new THREE.InterleavedBufferAttribute(e, r, s % o / a, l) } else c = null === n ? new i(p.count * r) : new i(n, s, p.count * r), h = new THREE.BufferAttribute(c, r, l); if (void 0 !== p.sparse) { const u = T.SCALAR, d = b[p.sparse.indices.componentType], a = p.sparse.indices.byteOffset || 0, e = p.sparse.values.byteOffset || 0, s = new d(t[1], a, p.sparse.count * u), o = new i(t[2], e, p.sparse.count * r); null !== n && (h = new THREE.BufferAttribute(h.array.slice(), h.itemSize, h.normalized)); for (let e = 0, t = s.length; e < t; e++) { const u = s[e]; if (h.setX(u, o[e * r]), 2 <= r && h.setY(u, o[e * r + 1]), 3 <= r && h.setZ(u, o[e * r + 2]), 4 <= r && h.setW(u, o[e * r + 3]), 5 <= r) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse THREE.BufferAttribute.") } } return h }) } loadTexture(e) { const t = this.json, n = this.options, r = t.textures[e], i = t.images[r.source]; let a = this.textureLoader; if (i.uri) { const e = n.manager.getHandler(i.uri); null !== e && (a = e) } return this.loadTextureImage(e, i, a) } loadTextureImage(n, t, i) { const r = this, a = this.json, s = this.options, o = a.textures[n], e = (t.uri || t.bufferView) + ":" + o.sampler; if (this.textureCache[e]) return this.textureCache[e]; const l = self.URL || self.webkitURL; let c = t.uri || "", h = !1, u = !0; var d = 0 < c.search(/\.jpe?g($|\?)/i) || 0 === c.search(/^data\:image\/jpeg/); if ("image/jpeg" !== t.mimeType && !d || (u = !1), void 0 !== t.bufferView) c = r.getDependency("bufferView", t.bufferView).then(function (e) { if ("image/png" === t.mimeType) { const t = new DataView(e, 25, 1).getUint8(0, !1); u = 6 === t || 4 === t || 3 === t } h = !0; e = new Blob([e], { type: t.mimeType }); return c = l.createObjectURL(e) }); else if (void 0 === t.uri) throw new Error("THREE.GLTFLoader: Image " + n + " is missing URI and bufferView"); d = Promise.resolve(c).then(function (r) { return new Promise(function (n, e) { let t = n; !0 === i.isImageBitmapLoader && (t = function (e) { const t = new THREE.Texture(e); t.needsUpdate = !0, n(t) }), i.load(R(r, s.path), t, void 0, e) }) }).then(function (e) { !0 === h && l.revokeObjectURL(c), e.flipY = !1, o.name && (e.name = o.name), u || (e.format = THREE.RGBFormat); var t = (a.samplers || {})[o.sampler] || {}; return e.magFilter = M[t.magFilter] || THREE.LinearFilter, e.minFilter = M[t.minFilter] || THREE.LinearMipmapLinearFilter, e.wrapS = w[t.wrapS] || THREE.RepeatWrapping, e.wrapT = w[t.wrapT] || THREE.RepeatWrapping, r.associations.set(e, { type: "textures", index: n }), e }).catch(function () { return console.error("THREE.GLTFLoader: Couldn't load texture", c), null }); return this.textureCache[e] = d } assignTexture(t, n, r) { const i = this; return this.getDependency("texture", r.index).then(function (e) { if (void 0 === r.texCoord || 0 == r.texCoord || "aoMap" === n && 1 == r.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + r.texCoord + " for texture " + n + " not yet supported."), i.extensions[h.KHR_TEXTURE_TRANSFORM]) { const t = void 0 !== r.extensions ? r.extensions[h.KHR_TEXTURE_TRANSFORM] : void 0; if (t) { const n = i.associations.get(e); e = i.extensions[h.KHR_TEXTURE_TRANSFORM].extendTexture(e, t), i.associations.set(e, n) } } return t[n] = e }) } assignFinalMaterial(t) { const e = t.geometry; let n = t.material; var r = void 0 !== e.attributes.tangent, i = void 0 !== e.attributes.color, a = void 0 === e.attributes.normal; if (t.isPoints) { const t = "PointsMaterial:" + n.uuid; let e = this.cache.get(t); e || (e = new THREE.PointsMaterial, THREE.Material.prototype.copy.call(e, n), e.color.copy(n.color), e.map = n.map, e.sizeAttenuation = !1, this.cache.add(t, e)), n = e } else if (t.isLine) { const t = "LineBasicMaterial:" + n.uuid; let e = this.cache.get(t); e || (e = new THREE.LineBasicMaterial, THREE.Material.prototype.copy.call(e, n), e.color.copy(n.color), this.cache.add(t, e)), n = e } if (r || i || a) { let e = "ClonedMaterial:" + n.uuid + ":", t = (n.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"), r && (e += "vertex-tangents:"), i && (e += "vertex-colors:"), a && (e += "flat-shading:"), this.cache.get(e)); t || (t = n.clone(), i && (t.vertexColors = !0), a && (t.flatShading = !0), r && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t } n.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv), t.material = n } getMaterialType() { return THREE.MeshStandardMaterial } loadMaterial(t) { const n = this, e = this.json, r = this.extensions, i = e.materials[t]; let a; const s = {}, o = i.extensions || {}, l = []; if (o[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) { const t = r[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]; a = t.getMaterialType(), l.push(t.extendParams(s, i, n)) } else if (o[h.KHR_MATERIALS_UNLIT]) { const t = r[h.KHR_MATERIALS_UNLIT]; a = t.getMaterialType(), l.push(t.extendParams(s, i, n)) } else { const h = i.pbrMetallicRoughness || {}; if (s.color = new THREE.Color(1, 1, 1), s.opacity = 1, Array.isArray(h.baseColorFactor)) { const t = h.baseColorFactor; s.color.fromArray(t), s.opacity = t[3] } void 0 !== h.baseColorTexture && l.push(n.assignTexture(s, "map", h.baseColorTexture)), s.metalness = void 0 !== h.metallicFactor ? h.metallicFactor : 1, s.roughness = void 0 !== h.roughnessFactor ? h.roughnessFactor : 1, void 0 !== h.metallicRoughnessTexture && (l.push(n.assignTexture(s, "metalnessMap", h.metallicRoughnessTexture)), l.push(n.assignTexture(s, "roughnessMap", h.metallicRoughnessTexture))), a = this._invokeOne(function (e) { return e.getMaterialType && e.getMaterialType(t) }), l.push(Promise.all(this._invokeAll(function (e) { return e.extendMaterialParams && e.extendMaterialParams(t, s) }))) } !0 === i.doubleSided && (s.side = THREE.DoubleSide); var c = i.alphaMode || "OPAQUE"; return "BLEND" === c ? (s.transparent = !0, s.depthWrite = !1) : (s.transparent = !1, "MASK" === c && (s.alphaTest = void 0 !== i.alphaCutoff ? i.alphaCutoff : .5)), void 0 !== i.normalTexture && a !== THREE.MeshBasicMaterial && (l.push(n.assignTexture(s, "normalMap", i.normalTexture)), s.normalScale = new THREE.Vector2(1, -1), void 0 !== i.normalTexture.scale && s.normalScale.set(i.normalTexture.scale, -i.normalTexture.scale)), void 0 !== i.occlusionTexture && a !== THREE.MeshBasicMaterial && (l.push(n.assignTexture(s, "aoMap", i.occlusionTexture)), void 0 !== i.occlusionTexture.strength && (s.aoMapIntensity = i.occlusionTexture.strength)), void 0 !== i.emissiveFactor && a !== THREE.MeshBasicMaterial && (s.emissive = (new THREE.Color).fromArray(i.emissiveFactor)), void 0 !== i.emissiveTexture && a !== THREE.MeshBasicMaterial && l.push(n.assignTexture(s, "emissiveMap", i.emissiveTexture)), Promise.all(l).then(function () { let e; return e = a === v ? r[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(s) : new a(s), i.name && (e.name = i.name), e.map && (e.map.encoding = THREE.sRGBEncoding), e.emissiveMap && (e.emissiveMap.encoding = THREE.sRGBEncoding), C(e, i), n.associations.set(e, { type: "materials", index: t }), i.extensions && L(r, e, i), e }) } createUniqueName(e) { var t = THREE.PropertyBinding.sanitizeNodeName(e || ""); let n = t; for (let e = 1; this.nodeNamesUsed[n]; ++e)n = t + "_" + e; return this.nodeNamesUsed[n] = !0, n } loadGeometries(n) { const r = this, i = this.extensions, a = this.primitiveCache; const s = []; for (let e = 0, t = n.length; e < t; e++) { var o = n[e], l = (l = void 0, (l = (c = o).extensions && c.extensions[h.KHR_DRACO_MESH_COMPRESSION]) ? "draco:" + l.bufferView + ":" + l.indices + ":" + P(l.attributes) : c.indices + ":" + P(c.attributes) + ":" + c.mode), c = a[l]; c ? s.push(c.promise) : (c = o.extensions && o.extensions[h.KHR_DRACO_MESH_COMPRESSION] ? function (t) { return i[h.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, r).then(function (e) { return N(e, t, r) }) }(o) : N(new THREE.BufferGeometry, o, r), a[l] = { primitive: o, promise: c }, s.push(c)) } var l; return Promise.all(s) } loadMesh(u) { const d = this, e = this.json, p = this.extensions, m = e.meshes[u], f = m.primitives, n = []; for (let e = 0, t = f.length; e < t; e++) { const d = void 0 === f[e].material ? (void 0 === (r = this.cache).DefaultMaterial && (r.DefaultMaterial = new THREE.MeshStandardMaterial({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: THREE.FrontSide })), r.DefaultMaterial) : this.getDependency("material", f[e].material); n.push(d) } var r; return n.push(d.loadGeometries(f)), Promise.all(n).then(function (e) { const n = e.slice(0, e.length - 1), r = e[e.length - 1], i = []; for (let t = 0, e = r.length; t < e; t++) { const c = r[t], h = f[t]; let e; var a = n[t]; if (4 === h.mode || 5 === h.mode || 6 === h.mode || void 0 === h.mode) !0 !== (e = new (!0 === m.isSkinnedMesh ? THREE.SkinnedMesh : THREE.Mesh)(c, a)).isSkinnedMesh || e.geometry.attributes.skinWeight.normalized || e.normalizeSkinWeights(), 5 === h.mode ? e.geometry = H(e.geometry, THREE.TriangleStripDrawMode) : 6 === h.mode && (e.geometry = H(e.geometry, THREE.TriangleFanDrawMode)); else if (1 === h.mode) e = new THREE.LineSegments(c, a); else if (3 === h.mode) e = new THREE.Line(c, a); else if (2 === h.mode) e = new THREE.LineLoop(c, a); else { if (0 !== h.mode) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode); e = new THREE.Points(c, a) } if (0 < Object.keys(e.geometry.morphAttributes).length) { s = void 0; o = void 0; l = void 0; var s = e; var o = m; if (s.updateMorphTargets(), void 0 !== o.weights) for (let e = 0, t = o.weights.length; e < t; e++)s.morphTargetInfluences[e] = o.weights[e]; if (o.extras && Array.isArray(o.extras.targetNames)) { var l = o.extras.targetNames; if (s.morphTargetInfluences.length === l.length) { s.morphTargetDictionary = {}; for (let e = 0, t = l.length; e < t; e++)s.morphTargetDictionary[l[e]] = e } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } e.name = d.createUniqueName(m.name || "mesh_" + u), C(e, m), h.extensions && L(p, e, h), d.assignFinalMaterial(e), i.push(e) } if (1 === i.length) return i[0]; const c = new THREE.Group; for (let e = 0, t = i.length; e < t; e++)c.add(i[e]); return c }) } loadCamera(e) { let t; var e = this.json.cameras[e], n = e[e.type]; if (n) return "perspective" === e.type ? t = new THREE.PerspectiveCamera(THREE.MathUtils.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : "orthographic" === e.type && (t = new THREE.OrthographicCamera(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), e.name && (t.name = this.createUniqueName(e.name)), C(t, e), Promise.resolve(t); console.warn("THREE.GLTFLoader: Missing camera parameters.") } loadSkin(e) { const t = this.json.skins[e], n = { joints: t.joints }; return void 0 === t.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then(function (e) { return n.inverseBindMatrices = e, n }) } loadAnimation(f) { const g = this.json.animations[f], n = [], r = [], i = [], a = [], s = []; for (let e = 0, t = g.channels.length; e < t; e++) { var o = g.channels[e], l = g.samplers[o.sampler], o = o.target, c = void 0 !== o.node ? o.node : o.id, h = void 0 !== g.parameters ? g.parameters[l.input] : l.input, u = void 0 !== g.parameters ? g.parameters[l.output] : l.output; n.push(this.getDependency("node", c)), r.push(this.getDependency("accessor", h)), i.push(this.getDependency("accessor", u)), a.push(l), s.push(o) } return Promise.all([Promise.all(n), Promise.all(r), Promise.all(i), Promise.all(a), Promise.all(s)]).then(function (i) { const n = i[0], r = i[1], a = i[2], s = i[3], o = i[4], l = []; for (let e = 0, t = n.length; e < t; e++) { const g = n[e], i = r[e], c = a[e], h = s[e], u = o[e]; if (void 0 !== g) { let n; switch (g.updateMatrix(), g.matrixAutoUpdate = !0, S[u.path]) { case S.weights: n = THREE.NumberKeyframeTrack; break; case S.rotation: n = THREE.QuaternionKeyframeTrack; break; case S.position: case S.scale: default: n = THREE.VectorKeyframeTrack }const d = g.name || g.uuid, p = void 0 !== h.interpolation ? A[h.interpolation] : THREE.InterpolateLinear, m = []; S[u.path] === S.weights ? g.traverse(function (e) { !0 === e.isMesh && e.morphTargetInfluences && m.push(e.name || e.uuid) }) : m.push(d); let r = c.array; if (c.normalized) { const f = I(r.constructor), g = new Float32Array(r.length); for (let e = 0, t = r.length; e < t; e++)g[e] = r[e] * f; r = g } for (let e = 0, t = m.length; e < t; e++) { const g = new n(m[e] + "." + S[u.path], i.array, r, p); "CUBICSPLINE" === h.interpolation && (g.createInterpolant = function (e) { return new _(this.times, this.values, this.getValueSize() / 3, e) }, g.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(g) } } } const c = g.name || "animation_" + f; return new THREE.AnimationClip(c, void 0, l) }) } createNodeMesh(e) { const t = this.json, n = this, r = t.nodes[e]; return void 0 === r.mesh ? null : n.getDependency("mesh", r.mesh).then(function (e) { const t = n._getNodeRef(n.meshCache, r.mesh, e); return void 0 !== r.weights && t.traverse(function (n) { if (n.isMesh) for (let e = 0, t = r.weights.length; e < t; e++)n.morphTargetInfluences[e] = r.weights[e] }), t }) } loadNode(i) { const e = this.json, t = this.extensions, a = this, s = e.nodes[i], o = s.name ? a.createUniqueName(s.name) : ""; return function () { const t = [], e = a._invokeOne(function (e) { return e.createNodeMesh && e.createNodeMesh(i) }); return e && t.push(e), void 0 !== s.camera && t.push(a.getDependency("camera", s.camera).then(function (e) { return a._getNodeRef(a.cameraCache, s.camera, e) })), a._invokeAll(function (e) { return e.createNodeAttachment && e.createNodeAttachment(i) }).forEach(function (e) { t.push(e) }), Promise.all(t) }().then(function (n) { let r; if ((r = !0 === s.isBone ? new THREE.Bone : 1 < n.length ? new THREE.Group : 1 === n.length ? n[0] : new THREE.Object3D) !== n[0]) for (let e = 0, t = n.length; e < t; e++)r.add(n[e]); if (s.name && (r.userData.name = s.name, r.name = o), C(r, s), s.extensions && L(t, r, s), void 0 !== s.matrix) { const i = new THREE.Matrix4; i.fromArray(s.matrix), r.applyMatrix4(i) } else void 0 !== s.translation && r.position.fromArray(s.translation), void 0 !== s.rotation && r.quaternion.fromArray(s.rotation), void 0 !== s.scale && r.scale.fromArray(s.scale); return a.associations.set(r, { type: "nodes", index: i }), r }) } loadScene(e) { const n = this.json, t = this.extensions, r = this.json.scenes[e], i = new THREE.Group, a = (r.name && (i.name = this.createUniqueName(r.name)), C(i, r), r.extensions && L(t, i, r), r.nodes || []), s = []; for (let e = 0, t = a.length; e < t; e++)s.push(function a(e, s, o, l) { const t = o.nodes[e]; return l.getDependency("node", e).then(function (e) { if (void 0 === t.skin) return e; let s; return l.getDependency("skin", t.skin).then(function (e) { s = e; const n = []; for (let e = 0, t = s.joints.length; e < t; e++)n.push(l.getDependency("node", s.joints[e])); return Promise.all(n) }).then(function (a) { return e.traverse(function (e) { if (e.isMesh) { const n = [], r = []; for (let e = 0, t = a.length; e < t; e++) { const i = a[e]; if (i) { n.push(i); const a = new THREE.Matrix4; void 0 !== s.inverseBindMatrices && a.fromArray(s.inverseBindMatrices.array, 16 * e), r.push(a) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', s.joints[e]) } e.bind(new THREE.Skeleton(n, r), e.matrixWorld) } }), e }) }).then(function (n) { s.add(n); const r = []; if (t.children) { const s = t.children; for (let e = 0, t = s.length; e < t; e++) { const i = s[e]; r.push(a(i, n, o, l)) } } return Promise.all(r) }) }(a[e], i, n, this)); return Promise.all(s).then(function () { return i }) } } function N(h, e, u) { const t = e.attributes, n = []; function r(e, t) { return u.getDependency("accessor", e).then(function (e) { h.setAttribute(t, e) }) } for (const e in t) { const u = E[e] || e.toLowerCase(); u in h.attributes || n.push(r(t[e], u)) } if (void 0 !== e.indices && !h.index) { const t = u.getDependency("accessor", e.indices).then(function (e) { h.setIndex(e) }); n.push(t) } return C(h, e), function (n, r, i) { const a = r.attributes, s = new THREE.Box3; if (void 0 !== a.POSITION) { { const n = i.json.accessors[a.POSITION], r = n.min, o = n.max; if (void 0 === r || void 0 === o) return console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."); if (s.set(new THREE.Vector3(r[0], r[1], r[2]), new THREE.Vector3(o[0], o[1], o[2])), n.normalized) { const r = I(b[n.componentType]); s.min.multiplyScalar(r), s.max.multiplyScalar(r) } } const o = r.targets; if (void 0 !== o) { const n = new THREE.Vector3, r = new THREE.Vector3; for (let e = 0, t = o.length; e < t; e++) { const s = o[e]; if (void 0 !== s.POSITION) { const a = i.json.accessors[s.POSITION], o = a.min, l = a.max; if (void 0 !== o && void 0 !== l) { if (r.setX(Math.max(Math.abs(o[0]), Math.abs(l[0]))), r.setY(Math.max(Math.abs(o[1]), Math.abs(l[1]))), r.setZ(Math.max(Math.abs(o[2]), Math.abs(l[2]))), a.normalized) { const n = I(b[a.componentType]); r.multiplyScalar(n) } n.max(r) } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } } s.expandByVector(n) } n.boundingBox = s; const l = new THREE.Sphere; s.getCenter(l.center), l.radius = s.min.distanceTo(s.max) / 2, n.boundingSphere = l } }(h, e, u), Promise.all(n).then(function () { if (void 0 === e.targets) return h; { var i = h, a = e.targets, s = u; let n = !1, r = !1; for (let e = 0, t = a.length; e < t; e++) { const s = a[e]; if (void 0 !== s.POSITION && (n = !0), void 0 !== s.NORMAL && (r = !0), n && r) break } if (!n && !r) return Promise.resolve(i); const l = [], c = []; for (let e = 0, t = a.length; e < t; e++) { var o = a[e]; if (n) { const a = void 0 !== o.POSITION ? s.getDependency("accessor", o.POSITION) : i.attributes.position; l.push(a) } if (r) { const a = void 0 !== o.NORMAL ? s.getDependency("accessor", o.NORMAL) : i.attributes.normal; c.push(a) } } return Promise.all([Promise.all(l), Promise.all(c)]).then(function (e) { var t = e[0], e = e[1]; return n && (i.morphAttributes.position = t), r && (i.morphAttributes.normal = e), i.morphTargetsRelative = !0, i }) } }) } function H(e, t) { let n = e.getIndex(); if (null === n) { const t = [], r = e.getAttribute("position"); if (void 0 === r) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e; for (let e = 0; e < r.count; e++)t.push(e); e.setIndex(t), n = e.getIndex() } const r = n.count - 2, i = []; if (t === THREE.TriangleFanDrawMode) for (let e = 1; e <= r; e++)i.push(n.getX(0)), i.push(n.getX(e)), i.push(n.getX(e + 1)); else for (let e = 0; e < r; e++)e % 2 == 0 ? (i.push(n.getX(e)), i.push(n.getX(e + 1)), i.push(n.getX(e + 2))) : (i.push(n.getX(e + 2)), i.push(n.getX(e + 1)), i.push(n.getX(e))); i.length / 3 !== r && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); const a = e.clone(); return a.setIndex(i), a } THREE.GLTFLoader = e }(), function () { const o = new WeakMap; class e extends THREE.Loader { constructor(e) { super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" } } setDecoderPath(e) { return this.decoderPath = e, this } setDecoderConfig(e) { return this.decoderConfig = e, this } setWorkerLimit(e) { return this.workerLimit = e, this } load(e, n, t, r) { const i = new THREE.FileLoader(this.manager); i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(e, e => { var t = { attributeIDs: this.defaultAttributeIDs, attributeTypes: this.defaultAttributeTypes, useUniqueIDs: !1 }; this.decodeGeometry(e, t).then(n).catch(r) }, t, r) } decodeDracoFile(e, t, n, r) { r = { attributeIDs: n || this.defaultAttributeIDs, attributeTypes: r || this.defaultAttributeTypes, useUniqueIDs: !!n }; this.decodeGeometry(e, r).then(t) } decodeGeometry(n, r) { for (const o in r.attributeTypes) { const n = r.attributeTypes[o]; void 0 !== n.BYTES_PER_ELEMENT && (r.attributeTypes[o] = n.name) } var e = JSON.stringify(r); if (o.has(n)) { const r = o.get(n); if (r.key === e) return r.promise; if (0 === n.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.") } let i; const a = this.workerNextTaskID++, t = n.byteLength, s = this._getWorker(a, t).then(e => (i = e, new Promise((e, t) => { i._callbacks[a] = { resolve: e, reject: t }, i.postMessage({ type: "decode", id: a, taskConfig: r, buffer: n }, [n]) }))).then(e => this._createGeometry(e.geometry)); return s.catch(() => !0).then(() => { i && a && this._releaseTask(i, a) }), o.set(n, { key: e, promise: s }), s } _createGeometry(t) { const n = new THREE.BufferGeometry; t.index && n.setIndex(new THREE.BufferAttribute(t.index.array, 1)); for (let e = 0; e < t.attributes.length; e++) { var r = t.attributes[e], i = r.name, a = r.array, r = r.itemSize; n.setAttribute(i, new THREE.BufferAttribute(a, r)) } return n } _loadLibrary(n, e) { const r = new THREE.FileLoader(this.manager); return r.setPath(this.decoderPath), r.setResponseType(e), r.setWithCredentials(this.withCredentials), new Promise((e, t) => { r.load(n, e, void 0, t) }) } preload() { return this._initDecoder(), this } _initDecoder() { if (this.decoderPending) return this.decoderPending; const i = "object" != typeof WebAssembly || "js" === this.decoderConfig.type, e = []; return i ? e.push(this._loadLibrary("draco_decoder.js", "text")) : (e.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), e.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(e).then(e => { const t = e[0], n = (i || (this.decoderConfig.wasmBinary = e[1]), function () { let e, t; onmessage = function (i) { const a = i.data; switch (a.type) { case "init": e = a.decoderConfig, t = new Promise(function (t) { e.onModuleLoaded = function (e) { t({ draco: e }) }, DracoDecoderModule(e) }); break; case "decode": const i = a.buffer, s = a.taskConfig; t.then(e => { const t = e.draco, n = new t.Decoder, r = new t.DecoderBuffer; r.Init(new Int8Array(i), i.byteLength); try { const e = function (n, r, i, a) { var s = a.attributeIDs, o = a.attributeTypes; let l, c; var h, u, d, p, m, f, g, v, y, x, _, e, t, b, M, w = r.GetEncodedGeometryType(i); if (w === n.TRIANGULAR_MESH) l = new n.Mesh, c = r.DecodeBufferToMesh(i, l); else { if (w !== n.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type."); l = new n.PointCloud, c = r.DecodeBufferToPointCloud(i, l) } if (!c.ok() || 0 === l.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + c.error_msg()); const T = { index: null, attributes: [] }; for (const i in s) { const c = self[o[i]]; let e, t; if (a.useUniqueIDs) t = s[i], e = r.GetAttributeByUniqueId(l, t); else { if (-1 === (t = r.GetAttributeId(l, n[s[i]]))) continue; e = r.GetAttribute(l, t) } T.attributes.push((h = n, u = r, d = l, p = i, m = c, f = e, _ = x = y = v = g = void 0, g = f.num_components(), v = d.num_points() * g, y = v * m.BYTES_PER_ELEMENT, x = function (e) { switch (m) { case Float32Array: return e.DT_FLOAT32; case Int8Array: return e.DT_INT8; case Int16Array: return e.DT_INT16; case Int32Array: return e.DT_INT32; case Uint8Array: return e.DT_UINT8; case Uint16Array: return e.DT_UINT16; case Uint32Array: return e.DT_UINT32 } }(h), _ = h._malloc(y), u.GetAttributeDataArrayForAllPoints(d, f, x, y, _), u = new m(h.HEAPF32.buffer, _, v).slice(), h._free(_), { name: p, array: u, itemSize: g })) } return w === n.TRIANGULAR_MESH && (T.index = (i = n, w = r, e = l, t = 3 * e.num_faces(), b = 4 * t, M = i._malloc(b), w.GetTrianglesUInt32Array(e, b, M), w = new Uint32Array(i.HEAPF32.buffer, M, t).slice(), i._free(M), { array: w, itemSize: 1 })), n.destroy(l), T }(t, n, r, s), i = e.attributes.map(e => e.array.buffer); e.index && i.push(e.index.array.buffer), self.postMessage({ type: "decode", id: a.id, geometry: e }, i) } catch (e) { console.error(e), self.postMessage({ type: "error", id: a.id, error: e.message }) } finally { t.destroy(r), t.destroy(n) } }) } } }.toString()), r = ["/* draco decoder */", t, "", "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n"); this.workerSourceURL = URL.createObjectURL(new Blob([r])) }), this.decoderPending } _getWorker(n, t) { return this._initDecoder().then(() => { if (this.workerPool.length < this.workerLimit) { const n = new Worker(this.workerSourceURL); n._callbacks = {}, n._taskCosts = {}, n._taskLoad = 0, n.postMessage({ type: "init", decoderConfig: this.decoderConfig }), n.onmessage = function (e) { var t = e.data; switch (t.type) { case "decode": n._callbacks[t.id].resolve(t); break; case "error": n._callbacks[t.id].reject(t); break; default: console.error('THREE.DRACOLoader: Unexpected message, "' + t.type + '"') } }, this.workerPool.push(n) } else this.workerPool.sort(function (e, t) { return e._taskLoad > t._taskLoad ? -1 : 1 }); const e = this.workerPool[this.workerPool.length - 1]; return e._taskCosts[n] = t, e._taskLoad += t, e }) } _releaseTask(e, t) { e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t] } debug() { console.log("Task load: ", this.workerPool.map(e => e._taskLoad)) } dispose() { for (let e = 0; e < this.workerPool.length; ++e)this.workerPool[e].terminate(); return this.workerPool.length = 0, this } } THREE.DRACOLoader = e }(), function () { const s = new THREE.Triangle, o = new THREE.Vector3; THREE.MeshSurfaceSampler = class { constructor(e) { let t = e.geometry; if (!t.isBufferGeometry || 3 !== t.attributes.position.itemSize) throw new Error("THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh."); t.index && (console.warn("THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry."), t = t.toNonIndexed()), this.geometry = t, this.randomFunction = Math.random, this.positionAttribute = this.geometry.getAttribute("position"), this.colorAttribute = this.geometry.getAttribute("color"), this.weightAttribute = null, this.distribution = null } setWeightAttribute(e) { return this.weightAttribute = e ? this.geometry.getAttribute(e) : null, this } build() { const n = this.positionAttribute, r = this.weightAttribute, i = new Float32Array(n.count / 3); for (let t = 0; t < n.count; t += 3) { let e = 1; r && (e = r.getX(t) + r.getX(t + 1) + r.getX(t + 2)), s.a.fromBufferAttribute(n, t), s.b.fromBufferAttribute(n, t + 1), s.c.fromBufferAttribute(n, t + 2), e *= s.getArea(), i[t / 3] = e } this.distribution = new Float32Array(n.count / 3); let t = 0; for (let e = 0; e < i.length; e++)t += i[e], this.distribution[e] = t; return this } setRandomGenerator(e) { return this.randomFunction = e, this } sample(e, t, n) { var r = this.distribution[this.distribution.length - 1], r = this.binarySearch(this.randomFunction() * r); return this.sampleFace(r, e, t, n) } binarySearch(e) { var t = this.distribution; let n = 0, r = t.length - 1, i = -1; for (; n <= r;) { var a = Math.ceil((n + r) / 2); if (0 === a || t[a - 1] <= e && t[a] > e) { i = a; break } e < t[a] ? r = a - 1 : n = a + 1 } return i } sampleFace(e, t, n, r) { let i = this.randomFunction(), a = this.randomFunction(); return 1 < i + a && (i = 1 - i, a = 1 - a), s.a.fromBufferAttribute(this.positionAttribute, 3 * e), s.b.fromBufferAttribute(this.positionAttribute, 3 * e + 1), s.c.fromBufferAttribute(this.positionAttribute, 3 * e + 2), t.set(0, 0, 0).addScaledVector(s.a, i).addScaledVector(s.b, a).addScaledVector(s.c, 1 - (i + a)), void 0 !== n && s.getNormal(n), void 0 !== r && void 0 !== this.colorAttribute && (s.a.fromBufferAttribute(this.colorAttribute, 3 * e), s.b.fromBufferAttribute(this.colorAttribute, 3 * e + 1), s.c.fromBufferAttribute(this.colorAttribute, 3 * e + 2), o.set(0, 0, 0).addScaledVector(s.a, i).addScaledVector(s.b, a).addScaledVector(s.c, 1 - (i + a)), r.r = o.x, r.g = o.y, r.b = o.z), this } } }(), function () { const t = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), n = new THREE.BufferGeometry; n.setAttribute("position", new THREE.Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), n.setAttribute("uv", new THREE.Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2)); THREE.EffectComposer = class { constructor(e, t) { var n; this.renderer = e, void 0 === t ? (n = e.getSize(new THREE.Vector2), this._pixelRatio = e.getPixelRatio(), this._width = n.width, this._height = n.height, (t = new THREE.WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio)).texture.name = "EffectComposer.rt1") : (this._pixelRatio = 1, this._width = t.width, this._height = t.height), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], void 0 === THREE.CopyShader && console.error("THREE.EffectComposer relies on THREE.CopyShader"), void 0 === THREE.ShaderPass && console.error("THREE.EffectComposer relies on THREE.ShaderPass"), this.copyPass = new THREE.ShaderPass(THREE.CopyShader), this.clock = new THREE.Clock } swapBuffers() { var e = this.readBuffer; this.readBuffer = this.writeBuffer, this.writeBuffer = e } addPass(e) { this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio) } insertPass(e, t) { this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio) } removePass(e) { e = this.passes.indexOf(e); -1 !== e && this.passes.splice(e, 1) } isLastEnabledPass(t) { for (let e = t + 1; e < this.passes.length; e++)if (this.passes[e].enabled) return !1; return !0 } render(n) { void 0 === n && (n = this.clock.getDelta()); var e = this.renderer.getRenderTarget(); let r = !1; for (let e = 0, t = this.passes.length; e < t; e++) { const a = this.passes[e]; if (!1 !== a.enabled) { if (a.renderToScreen = this.renderToScreen && this.isLastEnabledPass(e), a.render(this.renderer, this.writeBuffer, this.readBuffer, n, r), a.needsSwap) { if (r) { var i = this.renderer.getContext(); const s = this.renderer.state.buffers.stencil; s.setFunc(i.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, n), s.setFunc(i.EQUAL, 1, 4294967295) } this.swapBuffers() } void 0 !== THREE.MaskPass && (a instanceof THREE.MaskPass ? r = !0 : a instanceof THREE.ClearMaskPass && (r = !1)) } } this.renderer.setRenderTarget(e) } reset(e) { var t; void 0 === e && (t = this.renderer.getSize(new THREE.Vector2), this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, (e = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)), this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2 } setSize(e, t) { this._width = e, this._height = t; var n = this._width * this._pixelRatio, r = this._height * this._pixelRatio; this.renderTarget1.setSize(n, r), this.renderTarget2.setSize(n, r); for (let e = 0; e < this.passes.length; e++)this.passes[e].setSize(n, r) } setPixelRatio(e) { this._pixelRatio = e, this.setSize(this._width, this._height) } }, THREE.FullScreenQuad = class { constructor(e) { this._mesh = new THREE.Mesh(n, e) } dispose() { this._mesh.geometry.dispose() } render(e) { e.render(this._mesh, t) } get material() { return this._mesh.material } set material(e) { this._mesh.material = e } }, THREE.Pass = class { constructor() { this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1 } setSize() { } render() { console.error("THREE.Pass: .render() must be implemented in derived pass.") } } }(), function () { class e extends THREE.Pass { constructor(e, t, n, r, i) { super(), this.scene = e, this.camera = t, this.overrideMaterial = n, this.clearColor = r, this.clearAlpha = void 0 !== i ? i : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new THREE.Color } render(e, t, n) { var r = e.autoClear; e.autoClear = !1; let i, a; void 0 !== this.overrideMaterial && (a = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (e.getClearColor(this._oldClearColor), i = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : n), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor && e.setClearColor(this._oldClearColor, i), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = a), e.autoClear = r } } THREE.RenderPass = e }(), function () { class e extends THREE.Pass { constructor(e, t) { super(), this.textureID = void 0 !== t ? t : "tDiffuse", e instanceof THREE.ShaderMaterial ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = THREE.UniformsUtils.clone(e.uniforms), this.material = new THREE.ShaderMaterial({ defines: Object.assign({}, e.defines), uniforms: this.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader })), this.fsQuad = new THREE.FullScreenQuad(this.material) } render(e, t, n) { this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? e.setRenderTarget(null) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil)), this.fsQuad.render(e) } } THREE.ShaderPass = e }(), function () { class e extends THREE.Pass { constructor(e, t, n, r) { super(), void 0 === THREE.FilmShader && console.error("THREE.FilmPass relies on THREE.FilmShader"); var i = THREE.FilmShader; this.uniforms = THREE.UniformsUtils.clone(i.uniforms), this.material = new THREE.ShaderMaterial({ uniforms: this.uniforms, vertexShader: i.vertexShader, fragmentShader: i.fragmentShader }), void 0 !== r && (this.uniforms.grayscale.value = r), void 0 !== e && (this.uniforms.nIntensity.value = e), void 0 !== t && (this.uniforms.sIntensity.value = t), void 0 !== n && (this.uniforms.sCount.value = n), this.fsQuad = new THREE.FullScreenQuad(this.material) } render(e, t, n, r) { this.uniforms.tDiffuse.value = n.texture, this.uniforms.time.value += r, this.renderToScreen ? e.setRenderTarget(null) : (e.setRenderTarget(t), this.clear && e.clear()), this.fsQuad.render(e) } } THREE.FilmPass = e }(), function () {
    class o extends THREE.Pass {
        constructor(e, t, n, r) { super(), this.strength = void 0 !== t ? t : 1, this.radius = n, this.threshold = r, this.resolution = void 0 !== e ? new THREE.Vector2(e.x, e.y) : new THREE.Vector2(256, 256), this.clearColor = new THREE.Color(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5; let i = Math.round(this.resolution.x / 2), a = Math.round(this.resolution.y / 2); this.renderTargetBright = new THREE.WebGLRenderTarget(i, a), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1; for (let e = 0; e < this.nMips; e++) { const o = new THREE.WebGLRenderTarget(i, a), l = (o.texture.name = "UnrealBloomPass.h" + e, o.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(o), new THREE.WebGLRenderTarget(i, a)); l.texture.name = "UnrealBloomPass.v" + e, l.texture.generateMipmaps = !1, this.renderTargetsVertical.push(l), i = Math.round(i / 2), a = Math.round(a / 2) } void 0 === THREE.LuminosityHighPassShader && console.error("THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader"); var n = THREE.LuminosityHighPassShader, s = (this.highPassUniforms = THREE.UniformsUtils.clone(n.uniforms), this.highPassUniforms.luminosityThreshold.value = r, this.highPassUniforms.smoothWidth.value = .01, this.materialHighPassFilter = new THREE.ShaderMaterial({ uniforms: this.highPassUniforms, vertexShader: n.vertexShader, fragmentShader: n.fragmentShader, defines: {} }), this.separableBlurMaterials = [], [3, 5, 7, 9, 11]); i = Math.round(this.resolution.x / 2), a = Math.round(this.resolution.y / 2); for (let e = 0; e < this.nMips; e++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(s[e])), this.separableBlurMaterials[e].uniforms.texSize.value = new THREE.Vector2(i, a), i = Math.round(i / 2), a = Math.round(a / 2); this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = t, this.compositeMaterial.uniforms.bloomRadius.value = .1, this.compositeMaterial.needsUpdate = !0; this.compositeMaterial.uniforms.bloomFactors.value = [1, .8, .6, .4, .2], this.bloomTintColors = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, void 0 === THREE.CopyShader && console.error("THREE.UnrealBloomPass relies on THREE.CopyShader"); e = THREE.CopyShader; this.copyUniforms = THREE.UniformsUtils.clone(e.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new THREE.ShaderMaterial({ uniforms: this.copyUniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader, blending: THREE.AdditiveBlending, depthTest: !1, depthWrite: !1, transparent: !0 }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new THREE.Color, this.oldClearAlpha = 1, this.basic = new THREE.MeshBasicMaterial, this.fsQuad = new THREE.FullScreenQuad(null) } dispose() { for (let e = 0; e < this.renderTargetsHorizontal.length; e++)this.renderTargetsHorizontal[e].dispose(); for (let e = 0; e < this.renderTargetsVertical.length; e++)this.renderTargetsVertical[e].dispose(); this.renderTargetBright.dispose() } setSize(e, t) { let n = Math.round(e / 2), r = Math.round(t / 2); this.renderTargetBright.setSize(n, r); for (let e = 0; e < this.nMips; e++)this.renderTargetsHorizontal[e].setSize(n, r), this.renderTargetsVertical[e].setSize(n, r), this.separableBlurMaterials[e].uniforms.texSize.value = new THREE.Vector2(n, r), n = Math.round(n / 2), r = Math.round(r / 2) } render(t, e, n, r, i) { t.getClearColor(this._oldClearColor), this.oldClearAlpha = t.getClearAlpha(); var a = t.autoClear; t.autoClear = !1, t.setClearColor(this.clearColor, 0), i && t.state.buffers.stencil.setTest(!1), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, t.setRenderTarget(null), t.clear(), this.fsQuad.render(t)), this.highPassUniforms.tDiffuse.value = n.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, t.setRenderTarget(this.renderTargetBright), t.clear(), this.fsQuad.render(t); let s = this.renderTargetBright; for (let e = 0; e < this.nMips; e++)this.fsQuad.material = this.separableBlurMaterials[e], this.separableBlurMaterials[e].uniforms.colorTexture.value = s.texture, this.separableBlurMaterials[e].uniforms.direction.value = o.BlurDirectionX, t.setRenderTarget(this.renderTargetsHorizontal[e]), t.clear(), this.fsQuad.render(t), this.separableBlurMaterials[e].uniforms.colorTexture.value = this.renderTargetsHorizontal[e].texture, this.separableBlurMaterials[e].uniforms.direction.value = o.BlurDirectionY, t.setRenderTarget(this.renderTargetsVertical[e]), t.clear(), this.fsQuad.render(t), s = this.renderTargetsVertical[e]; this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, t.setRenderTarget(this.renderTargetsHorizontal[0]), t.clear(), this.fsQuad.render(t), this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, i && t.state.buffers.stencil.setTest(!0), this.renderToScreen ? t.setRenderTarget(null) : t.setRenderTarget(n), this.fsQuad.render(t), t.setClearColor(this._oldClearColor, this.oldClearAlpha), t.autoClear = a } getSeperableBlurMaterial(e) {
            return new THREE.ShaderMaterial({
                defines: { KERNEL_RADIUS: e, SIGMA: e }, uniforms: { colorTexture: { value: null }, texSize: { value: new THREE.Vector2(.5, .5) }, direction: { value: new THREE.Vector2(.5, .5) } }, vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`})
        } getCompositeMaterial(e) {
            return new THREE.ShaderMaterial({
                defines: { NUM_MIPS: e }, uniforms: { blurTexture1: { value: null }, blurTexture2: { value: null }, blurTexture3: { value: null }, blurTexture4: { value: null }, blurTexture5: { value: null }, dirtTexture: { value: null }, bloomStrength: { value: 1 }, bloomFactors: { value: null }, bloomTintColors: { value: null }, bloomRadius: { value: 0 } }, vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform sampler2D dirtTexture;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`})
        }
    } o.BlurDirectionX = new THREE.Vector2(1, 0), o.BlurDirectionY = new THREE.Vector2(0, 1), THREE.UnrealBloomPass = o
}(), function () {
    var e = {
        shaderID: "luminosityHighPass", uniforms: { tDiffuse: { value: null }, luminosityThreshold: { value: 1 }, smoothWidth: { value: 1 }, defaultColor: { value: new THREE.Color(0) }, defaultOpacity: { value: 0 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`}; THREE.LuminosityHighPassShader = e
}(), THREE.CopyShader = {
    uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`}, THREE.FilmShader = {
        uniforms: { tDiffuse: { value: null }, time: { value: 0 }, nIntensity: { value: .5 }, sIntensity: { value: .05 }, sCount: { value: 4096 }, grayscale: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		#include <common>

		// control parameter
		uniform float time;

		uniform bool grayscale;

		// noise effect intensity value (0 = no effect, 1 = full effect)
		uniform float nIntensity;

		// scanlines effect intensity value (0 = no effect, 1 = full effect)
		uniform float sIntensity;

		// scanlines effect count value (0 = no effect, 4096 = full effect)
		uniform float sCount;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

		// sample the source
			vec4 cTextureScreen = texture2D( tDiffuse, vUv );

		// make some noise
			float dx = rand( vUv + time );

		// add noise
			vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );

		// get us a sine and cosine
			vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );

		// add scanlines
			cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;

		// interpolate between source and result by intensity
			cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );

		// convert to grayscale if desired
			if( grayscale ) {

				cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );

			}

			gl_FragColor =  vec4( cResult, cTextureScreen.a );

		}`};